{"meta":{"title":"xiaotong's blog","subtitle":null,"description":null,"author":"Xiaotong CHEN","url":"https://xiaotong1996.github.io"},"pages":[{"title":"About","date":"2019-01-08T20:01:50.000Z","updated":"2019-01-08T20:03:30.111Z","comments":true,"path":"about/index.html","permalink":"https://xiaotong1996.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-01-08T21:13:48.666Z","updated":"2019-01-08T21:13:48.666Z","comments":true,"path":"tags/index.html","permalink":"https://xiaotong1996.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"UnityCI尝试","slug":"UnityCI尝试","date":"2020-09-23T13:06:23.000Z","updated":"2020-09-23T13:06:56.036Z","comments":true,"path":"2020/09/23/UnityCI尝试/","link":"","permalink":"https://xiaotong1996.github.io/2020/09/23/UnityCI尝试/","excerpt":"","text":"UnityCIOnly unity pro can use commandline to build, otherwise will get Failed to activate/update license problem Setting CI/CD for a Unity Project in GitHub Actionstested in 2018.4.10f1 run docker image docker run -it gableroux/unity3d:X.X.X in docker create activation file ./Unity -quit -batchmode -nographics -logFile -createManualActivationFile 参数 说明 quit 执行完后结束 batchmode 只在commandline 执行 nographics 没有图像输出 logFile 结果输出到console createManualActivationFile 创建 activation file 包含license cat Unity_v2018.2.21f1.alf copy paste content to local file active this version in unity with alf file encrypt this file with openssl aes-256-cbc -e -in &quot;D:\\Shared Projects\\Unity\\UnityCI\\Unity_v2017.x.ulf&quot; -out &quot;D:\\Shared Projects\\Unity\\UnityCI\\Unity_v2017.x.ulf.enc&quot; -k wTnz@rW7Ru9@^JhEcYSC-P#=fzNX4%d2 set GitHub settings secret key add .github folder in project, put encrypt file in it create workflows folder in it add yml configuration file in it push to github using another way copy BuildScript.cs in Assets/Scripts/Editor, this script is used to build unity project copy ci file .trvais.yml copy ci folder","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://xiaotong1996.github.io/tags/Unity/"},{"name":"CI/CD","slug":"CI-CD","permalink":"https://xiaotong1996.github.io/tags/CI-CD/"}]},{"title":"Docker学习","slug":"Docker学习","date":"2020-09-23T13:05:15.000Z","updated":"2020-09-23T13:05:35.309Z","comments":true,"path":"2020/09/23/Docker学习/","link":"","permalink":"https://xiaotong1996.github.io/2020/09/23/Docker学习/","excerpt":"","text":"Dockercontainer（容器）Simply put, a container is simply another process on your machine that has been isolated from all other processes on the host machine. 容器就是一个独立于其他所有主机上的进程的进程 container image （镜像） This custom filesystem is provided by a container image. Since the image contains the container’s filesystem, it must contain everything needed to run an application - all dependencies, configuration, scripts, binaries, etc. The image also contains other configuration for the container, such as environment variables, a default command to run, and other metadata 镜像是容器的文件系统，提供运行程序的所有文件和容器的配置文件 使用Container和Image 的 Steps 将源代码置入Docker（clone） 构建app的container image 创建一个Dockerfile 文件 12345FROM node:10-alpineWORKDIR /appCOPY . .RUN yarn install --productionCMD [&quot;node&quot;, &quot;/app/src/index.js&quot;] 使用docker build构建container image 1docker build -t docker-101 . 说明：docker-101是这个container image的名字 . 代表本地目录（其中包含Dockerfile） FROM 从node：10-alpine镜像开始构建 复制到本地 用yarn安装应用依赖 CMD指示从image开启container的默认命令 开启app容器 1docker run -dp 3000:3000 docker-101 -d 表示 detached模式（后台运行）-p创建主机端口3000到容器端口3000的映射 主机端口只能有一个进程占用。 想要映射之前的端口，需要替换掉旧的容器 docker ps 查询容器信息 docker stop 杀死容器 docker rm 移除容器 docker rm -f 杀死并移除容器 分享image分享image需要使用docker registry注册器，默认的registry是Docker HUB 创建一个repo（仓库） 前往 Docker Hub 创建仓库 设置名字和visibility 创建 Publish Imagedocker image ls 显示image信息 登录到dockerhubdocker login -u YOUR-USER-NAME. tag imagedocker tag docker-101 YOUR-USER-NAME/101-todo-app 发布到dockerHUbdocker push YOUR-USER-NAME/101-todo-app Persisting our DB容器的文件系统当容器运行时，使用多个layer从image到文件系统，每个容器也有自己的scratch space来创建/更新/删除 文件。所以容器上的修改对于其他容器是不可见的，即使使用同样的image 1docker run -d ubuntu bash -c &quot;shuf -i 1-10000 -n 1 -o /data.txt &amp;&amp; tail -f /dev/null&quot; Validate we can see the output by exec‘ing into the container. To do so, you need to get the container’s ID (use docker ps to get it). 1docker exec &lt;container-id&gt; cat /data.txt Container VolumesVolumes provide the ability to connect specific filesystem paths of the container back to the host machine. If a directory in the container is mounted, changes in that directory are also seen on the host machine. If we mount that same directory across container restarts, we’d see the same files. 卷提供了将容器的特定文件系统路径连接回主机的功能。 如果装入了容器中的目录，则在主机上也会看到该目录中的更改。 如果在重新启动容器时安装相同的目录，则会看到相同的文件。 使用docker volume create来创建一个卷 1docker volume create todo-db 开启容器，加上-v表明挂载一个卷 1docker run -dp 3000:3000 -v todo-db:/etc/todos docker-101 docker volume inspect 123456789101112docker volume inspect todo-db[ &#123; &quot;CreatedAt&quot;: &quot;2019-09-26T02:18:36Z&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: &#123;&#125;, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/todo-db/_data&quot;, &quot;Name&quot;: &quot;todo-db&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Scope&quot;: &quot;local&quot; &#125;] Using Bind MountsWith bind mounts, we control the exact mountpoint on the host. We can use this to persist data, but is often used to provide additional data into containers. When working on an application, we can use a bind mount to mount our source code into the container to let it see code changes, respond, and let us see the changes right away. 例子：开始一个开发模式容器 把源代码挂载到容器 安装所有依赖，包含开发依赖 开启nodemon（类似工具）来检测文件变化 修改代码 刷新网页来查看变化 一旦结束修改，stop容器并就构建自己的新的镜像docker build -t getting-started . 1234docker run -dp 3000:3000 \\ -w /app -v $PWD:/app \\ node:10-alpine \\ sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; 指令 说明 -dp 3000:3000 用后台模式运行，并且创建一个端口映射 -w /app 设置工作目录，指令从此处开始 -v ${PWD}:/app 绑定挂载容器中的主机当前目录到/app中 node:12-alpine 使用的镜像 sh -c “yarn install &amp;&amp; yarn run dev” 指令。运行一个shell指令，运行yarn install来安装所有依赖，运行yarn run dev开始开发环境 docker logs -f 查看log Multi-Container Apps 多容器应用每个容器只做一件事 Container Networking默认情况，容器独立运行。如何实现容器间的通信，需要使用网络。当两个容器在同一网络中，他们能互相通信。 开启MySQL有两种方式能把容器放在网路中：1）在开始的时候声明。2）连接到一个已经存在的容器 创建网络 docker network create todo-app 开启一个MySQL容器并把它连接到网络 123456docker run -d \\ --network todo-app --network-alias mysql \\ -v todo-mysql-data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=secret \\ -e MYSQL_DATABASE=todos \\ mysql:5.7 这里创建了一个volume名叫todo-mysql-data并挂载到/var/lib/mysql上，不需要使用docker volume create， Docker会检测并自动为我们创建 连接到mysql 1docker exec -it &lt;mysql-container-id&gt; mysql -p 使用mysql 1mysql&gt; SHOW DATABASES; 连接到MySQL如果我们在同一个网络运行另一个容器，如何找到这个容器？ 使用nicolaka/netshoot容器，这是一个搭载很多用于troubleshooting和网络问题debugging的工具镜像 开启一个使用这个工具镜像的容器 1docker run -it --network todo-app nicolaka/netshoot 在这个容器中，使用dig命令，DNS工具用于查询ip地址 1dig mysql 12345678910111213141516; &lt;&lt;&gt;&gt; DiG 9.14.1 &lt;&lt;&gt;&gt; mysql;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 32162;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;mysql. IN A;; ANSWER SECTION:mysql. 600 IN A 172.23.0.2;; Query time: 0 msec;; SERVER: 127.0.0.11#53(127.0.0.11);; WHEN: Tue Oct 01 23:47:24 UTC 2019;; MSG SIZE rcvd: 44 ANSWER SECTION A 记录了mysql ip地址 172.18.0.2 使用MySQL运行appThe todo app supports the setting of a few environment variables to specify MySQL connection settings. They are: MYSQL_HOST - the hostname for the running MySQL server MYSQL_USER - the username to use for the connection MYSQL_PASSWORD - the password to use for the connection MYSQL_DB - the database to use once connected 定义环境变量，连接容器到app network 123456789docker run -dp 3000:3000 \\ -w /app -v $&#123;PWD&#125;:/app \\ --network todo-app \\ -e MYSQL_HOST=mysql \\ -e MYSQL_USER=root \\ -e MYSQL_PASSWORD=secret \\ -e MYSQL_DB=todos \\ node:12-alpine \\ sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; 用docker logs container-id查看 12345678# Previous log messages omitted$ nodemon src/index.js[nodemon] 1.19.2[nodemon] to restart at any time, enter `rs`[nodemon] watching dir(s): *.*[nodemon] starting `node src/index.js`Connected to mysql db at host mysqlListening on port 3000 在网页app中修改 连接到mysql 查看 1docker exec -ti &lt;mysql-container-id&gt; mysql -p todos 1234567mysql&gt; select * from todo_items;+--------------------------------------+--------------------+-----------+| id | name | completed |+--------------------------------------+--------------------+-----------+| c906ff08-60e6-44e6-8f49-ed56a0853e85 | Do amazing things! | 0 || 2912a79e-8486-4bc3-a4c5-460793a575ab | Be awesome! | 0 |+--------------------------------------+--------------------+-----------+ 使用Docker ComposeDocker Compose is a tool that was developed to help define and share multi-container applications. With Compose, we can create a YAML file to define the services and with a single command, can spin everything up or tear it all down. 查看version1docker-compose version 创建Compose文件 在app项目root中，创建一个名为docker-compose.yml的文件 在compose文件中，先定义version，可通过Compose file reference查看最新版本 接下来，定义需要的service或容器列表 定义app service 首先为容器定义service entry和image，可以为其选择任意名字，这个名字会自动成为network alias 接下来定义command 通过ports定义接口映射 使用working_dir定义工作路径，volumes定义volume mapping 使用environment定义环境变量 12345678910111213141516version: &quot;3.7&quot;services: app: image: node:12-alpine command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; ports: - 3000:3000 working_dir: /app volumes: - ./:/app environment: MYSQL_HOST: mysql MYSQL_USER: root MYSQL_PASSWORD: secret MYSQL_DB: todos 定义MySQL service 定义新服务，并命名为mysql来自动创建network alias，定义image 接下来，定义volume mapping，用docker run运行时，命名的volume会自动创建，但是用compose不会，需要使用volumes来定义 定义环境变量 123456789101112131415version: &quot;3.7&quot;services: app: # The app service definition mysql: image: mysql:5.7 volumes: - todo-mysql-data:/var/lib/mysql environment: MYSQL_ROOT_PASSWORD: secret MYSQL_DATABASE: todosvolumes: todo-mysql-data: docker-compose.yml 例子123456789101112131415161718192021222324252627version: &quot;3.7&quot;services: app: image: node:12-alpine command: sh -c &quot;yarn install &amp;&amp; yarn run dev&quot; ports: - 3000:3000 working_dir: /app volumes: - ./:/app environment: MYSQL_HOST: mysql MYSQL_USER: root MYSQL_PASSWORD: secret MYSQL_DB: todos mysql: image: mysql:5.7 volumes: - todo-mysql-data:/var/lib/mysql environment: MYSQL_ROOT_PASSWORD: secret MYSQL_DATABASE: todosvolumes: todo-mysql-data: 运行app stack使用docker-compose up 来开启app stack，-d 后台 使用docker-compose logs -f来查看logs -f follow，可以查看即时输出 使用docker-compose down 来拆除容器 Image Building PracticesImage Layering使用docker image history来查看layers Layer Caching一旦一个层被修改了，它的下游层都要修改 回到映像历史记录输出，我们看到Dockerfile中的每个命令都成为映像中的新层。 您可能还记得，当我们对映像进行更改时，必须重新安装yarn依赖项。 有没有办法来解决这个问题？ 每次我们构建时都带着相同的依赖关系是没有意义的，对吧？ 要解决此问题，我们需要重组Dockerfile来帮助支持依赖项的缓存。 对于基于节点的应用程序，那些依赖项在package.json文件中定义。 因此，如果我们仅先复制该文件，安装依赖项，然后再复制其他所有内容，那该怎么办？ 然后，仅当package.json发生更改时，我们才重新创建yarn依赖项。 合理？ 更新Dockerfile以首先复制到package.json中，安装依赖项，然后再复制其他所有内容。 123456FROM node:12-alpineWORKDIR /appCOPY package.json yarn.lock ./RUN yarn install --productionCOPY . .CMD [&quot;node&quot;, &quot;/app/src/index.js&quot;] Multi-Stage Builds好处： Separate build-time dependencies from runtime dependencies Reduce overall image size by shipping only what your app needs to run Maven/Tomcat 例子1234567FROM maven AS buildWORKDIR /appCOPY . .RUN mvn packageFROM tomcatCOPY --from=build /app/target/file.war /usr/local/tomcat/webapps In this example, we use one stage (called build) to perform the actual Java build using Maven. In the second stage (starting at FROM tomcat), we copy in files from the build stage. The final image is only the last stage being created (which can be overridden using the --target flag). React 例子12345678910FROM node:12 AS buildWORKDIR /appCOPY package* yarn.lock ./RUN yarn installCOPY public ./publicCOPY src ./srcRUN yarn run buildFROM nginx:alpineCOPY --from=build /app/build /usr/share/nginx/html","categories":[],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://xiaotong1996.github.io/tags/Docker/"}]},{"title":"Android Dagger与MVP","slug":"Android-Dagger与MVP","date":"2020-09-23T12:57:29.000Z","updated":"2020-09-23T12:57:43.453Z","comments":true,"path":"2020/09/23/Android-Dagger与MVP/","link":"","permalink":"https://xiaotong1996.github.io/2020/09/23/Android-Dagger与MVP/","excerpt":"","text":"RESUME for Dagger2 and MVI prepare dagger for application and activity define a contract which includes interactor and view define needed functions in these interfaces 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * mainActivity contract */public interface MainActivityContract &#123; /** * interactor for mainActivity */ interface Interactor &#123; /** * attach view to mainActivity * * @param view */ void onAttachView(View view); /** * detach view form mainActivity */ void onDetachView(); /** * user login * * @param userName * @param password */ void login(String userName, String password); &#125; /** * view for mainActivity */ interface View &#123; /** * execute if login success */ void loginSuccess(); /** * execute if login fail */ void loginFail(); &#125;&#125; create a new class to implement interactor, override functions implement view in MainActivity; override functions add interactor dependecy for MainActivity by adding @Inject 12@InjectMainActivityContract.Interactor interactor; implement interactor injector by creating a interactor module 12345678910111213141516/** * interactor module */@Modulepublic class InteractorModule &#123; /** * provide mainActivity&apos;s interactor implementation * @param authManager get instance from authManagerModule injection * @return return instance implementation */ @Provides public MainActivityContract.Interactor getMainActivityContract()&#123; return new MainActivityInteractorImpl(); &#125;&#125; associate this module and dependent class here is MainActivity by adding this module to a component 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * application dagger component */@Singleton@Component(modules = &#123; AndroidInjectionModule.class , AppWidgetModule.class , ApplicationModule.class , InteractorModule.class , AuthManagerModule.class&#125;)public interface AppComponent &#123; /** * provide custom builder for dagger component */ @Component.Builder interface Builder &#123; /** * provide app context * * @param authApplication auth application * @return instance */ @BindsInstance Builder application(AuthApplication authApplication); /** * builder * * @return app component */ AppComponent build(); &#125; /** * method to inject app * * @param authApplication auth app instance */ void inject(AuthApplication authApplication);&#125; implement detail functions in interactor and mainActivity(view) if during step 8 we need some ohter modules/libraries ex, here we need a authManager to get token from backend, 12345678910111213141516171819202122232425262728293031323334353637/** * mainActivity interactor implementation */public class MainActivityInteractorImpl implements MainActivityContract.Interactor &#123; @Nullable MainActivityContract.View view; @NonNull final AuthManager authManager; @Override public void onAttachView(MainActivityContract.View view) &#123; this.view = view; &#125; @Override public void onDetachView() &#123; this.view = null; &#125; @Override public void login(String userName, String password) &#123; authManager.login(userName, password, EnumSet.noneOf(AuthScope.class), new Listener() &#123; @Override public void onSuccess() &#123; view.loginSuccess(); &#125; @Override public boolean onFailure(@NonNull RequestError error, boolean alreadyHandled) &#123; view.loginFail(); return false; &#125; &#125;); &#125;&#125; we can encapsulate its functions in a dagger module don’t forget add it to component to associate it with Interactor class 12345678910111213141516/** * authManager module */@Module()public class AuthManagerModule &#123; /** * provide authManager implementation * @param applicationContext get instance from ApplicationModule injection * @return instance */ @Provides AuthManager getAuthManagerProvider(Context applicationContext)&#123; return new DebugAuthManagerProvider(applicationContext).get(); &#125;&#125; but we still can’t get its instance cause it hasn’t been associated with interactor module. We need to add authManager in Paramater 12345678910111213141516/** * interactor module */@Modulepublic class InteractorModule &#123; /** * provide mainActivity&apos;s interactor implementation * @param authManager get instance from authManagerModule injection * @return return instance implementation */ @Provides public MainActivityContract.Interactor getMainActivityContract(AuthManager authManager)&#123; return new MainActivityInteractorImpl(authManager); &#125;&#125; Then create a new interactor construction function which takes authManager as parameter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * mainActivity interactor implementation */public class MainActivityInteractorImpl implements MainActivityContract.Interactor &#123; @Nullable MainActivityContract.View view; @NonNull final AuthManager authManager; /** * constructor * * @param authManager used to get token */ public MainActivityInteractorImpl(AuthManager authManager) &#123; this.authManager = authManager; &#125; @Override public void onAttachView(MainActivityContract.View view) &#123; this.view = view; &#125; @Override public void onDetachView() &#123; this.view = null; &#125; @Override public void login(String userName, String password) &#123; authManager.login(userName, password, EnumSet.noneOf(AuthScope.class), new Listener() &#123; @Override public void onSuccess() &#123; view.loginSuccess(); &#125; @Override public boolean onFailure(@NonNull RequestError error, boolean alreadyHandled) &#123; view.loginFail(); return false; &#125; &#125;); &#125;&#125; Important ThingDagger Inject for android component(ex. activity, fragment, application etc ) and for java class(or interface) is different. Cause for android, with FSM activity’s construction function is implicit. So we use @inject or @module and some dagger 2 Android annotation to realise injection. It seems simple and easy. But for other our custom classes, we need to do in common ways, like add dependencies as parameters in construction functions. GO BACK TO DaggerThe simplest concept: First we need to know the importance and usage of DI and Constructor Injection. You pass the dependencies of a class to its constructor. Here explains why we need another way for injection. Constructor Injection. This is the way described above. You pass the dependencies of a class to its constructor. Field Injection (or Setter Injection). Certain Android framework classes such as activities and fragments are instantiated by the system, so constructor injection is not possible. With field injection, dependencies are instantiated after the class is created. The code would look like this: Why we need auto Injection framework? For big apps, taking all the dependencies and connecting them correctly can require a large amount of boilerplate code. In a multi-layered architecture, in order to create an object for a top layer, you have to provide all the dependencies of the layers below it. As a concrete example, to build a real car you might need an engine, a transmission, a chassis, and other parts; and an engine in turn needs cylinders and spark plugs. When you’re not able to construct dependencies before passing them in — for example when using lazy initializations or scoping objects to flows of your app — you need to write and maintain a custom container (or graph of dependencies) that manages the lifetimes of your dependencies in memory. Another way to improve decoupling of classesservice locator You create a class known as the service locator that creates and stores dependencies and then provides those dependencies on demand. Compare The collection of dependencies required by a service locator makes code harder to test because all the tests have to interact with the same global service locator. Dependencies are encoded in the class implementation, not in the API surface. As a result, it’s harder to know what a class needs from the outside. As a result, changes to Car or the dependencies available in the service locator might result in runtime or test failures by causing references to fail. Managing lifetimes of objects is more difficult if you want to scope to anything other than the lifetime of the entire app.","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiaotong1996.github.io/tags/Android/"}]},{"title":"Anddroid IPC","slug":"Anddroid-IPC","date":"2020-09-23T12:50:52.000Z","updated":"2020-09-23T12:55:27.116Z","comments":true,"path":"2020/09/23/Anddroid-IPC/","link":"","permalink":"https://xiaotong1996.github.io/2020/09/23/Anddroid-IPC/","excerpt":"","text":"How to realize IPCBound services A bound service is the server in a client-server interface. It allows components (such as activities) to bind to the service, send requests, receive responses, and perform interprocess communication (IPC). How to create Bound ServiceWhen creating a service that provides binding, you must provide an IBinder that provides the programming interface that clients can use to interact with the service. How to define an IBinderUsing AIDL Android Interface Definition Language (AIDL) decomposes objects into primitives that the operating system can understand and marshals them across processes to perform IPC. How to create a bounded service using AIDL Create the .aidl file This file defines the programming interface with method signatures. Implement the interface The Android SDK tools generate an interface in the Java programming language, based on your .aidl file. This interface has an inner abstract class named Stub that extends Binder and implements methods from your AIDL interface. You must extend the Stub class and implement the methods. Expose the interface to clients Implement a Service and override onBind() to return your implementation of the Stub class. General Steps create aidl file create service implement IBinder for service instantiate service in client (activity) AccountManagerhttps://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/accounts Theory Example: IPC between service and accountManager Define Bound service MyAccountTypeService implement onBind provide IBinder return MyAccountAuthenticator.getIBinder(); use AIDL define IBinder create the .aidl file IAccountAuthenticator.aidlIAccountAuthenticatorResponse.aidl Implement the interface private class Transport extends IAccountAuthenticator.Stub line:152 Expose the interface to clients return MyAccountAuthenticator.getIBinder(); Work flowAccountManager : getAuthToken() -&gt; new AmsTask() -&gt; mService.getAuthToken() mService is IAccountManager created by system the real invoke is AccountManagerService (extends IAccountManager.Stub) AccountManagerService : getAuthToken() -&gt; new Session() -&gt; bind to mAuthenticator related service -&gt; mAuthenticator.getAuthToken() *mAuthenticatoir is IAccountAuthenticator assaigned In Session(extend IAccountAuthenticatorResponse.Stub and implement ServiceConnection): onServiceConnected() method `mAuthenticator = IAccountAuthenticator.Stub.asInterface(service);` AbstractAccountAuthenticator : getAuthToken() -&gt; AbstractAccountAuthenticator.this.getAuthToken() here invoke our proper method AccountAuthenticator : intent.putExtra(AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response) pass AccountAuthenticatorResponse by intent return bundle AccountAuthenticatorResponse implements Parcelable contains IAccountAuthenticatorResponse Session : onResult() -&gt; result contain KEY_INTENT -&gt; response.onResult() response is IAccountManagerResponse.Stub declare in AccountManager Response : onResult() -&gt; mActivity.startActivity(intent) ShareMyAccountActivity : getIntent() -&gt; AccountAuthenticatorResponse.onResult() -&gt; mAccountAuthenticatorResponse.onResult() mAccountAuthenticatorResponse is IAccountAuthenticatorResponse is assaigned in AccountManagerService.newRequestAccountAccessIntent() How AccountAuthenticatorResponse work ? define a IAccountAuthenticatorResponse aidl file 123456789101112/** * The interface used to return responses from an &#123;@link IAccountAuthenticator&#125; * @hide */oneway interface IAccountAuthenticatorResponse &#123; @UnsupportedAppUsage void onResult(in Bundle value); @UnsupportedAppUsage void onRequestContinued(); @UnsupportedAppUsage void onError(int errorCode, String errorMessage);&#125; implement this interface 123456789101112131415161718192021222324252627282930313233343536private abstract class Session extends IAccountAuthenticatorResponse.Stub implements IBinder.DeathRecipient, ServiceConnection &#123; IAccountManagerResponse mResponse; ... IAccountAuthenticator mAuthenticator = null; ... void bind() &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; Log.v(TAG, \"initiating bind to authenticator type \" + mAccountType); &#125; if (!bindToAuthenticator(mAccountType)) &#123; Log.d(TAG, \"bind attempt failed for \" + toDebugString()); onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"bind failure\"); &#125; &#125; ... @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mAuthenticator = IAccountAuthenticator.Stub.asInterface(service); try &#123; run(); &#125; catch (RemoteException e) &#123; onError(AccountManager.ERROR_CODE_REMOTE_EXCEPTION, \"remote exception\"); &#125; &#125; ... @Override public void onResult(Bundle result) &#123; ... IAccountManagerResponse response; response = mResponse response.onResult(); ... &#125; &#125; accountManager -&gt; AmTask -&gt; AccountManagerService -&gt; Session( instantiate IAccountAuthenticatorResponse ) -&gt; bind to authenticator service -&gt; call mAuthenticator.getAuthToken(pass IAccountAuthenticatorResponse) 1234567891011121314151617181920212223242526272829303132@Overridepublic void getAuthToken( IAccountManagerResponse response, final Account account, final String authTokenType, final boolean notifyOnAuthFailure, final boolean expectActivityLaunch, final Bundle loginOptions) &#123; ... new Session( accounts, response, account.type, expectActivityLaunch, false /* stripAuthTokenFromResult */, account.name, false /* authDetailsRequired */) &#123; @Override public void run() throws RemoteException &#123; // If the caller doesn't have permission then create and return the // \"grant permission\" intent instead of the \"getAuthToken\" intent. if (!permissionGranted) &#123; mAuthenticator.getAuthTokenLabel(this, authTokenType); &#125; else &#123; mAuthenticator.getAuthToken(this, account, authTokenType, loginOptions); &#125; &#125; ... &#125;.bind(); ...&#125; define an object to get passed IAccountAuthenticatorResponse and use callback send back result 123456789101112131415161718192021/** * Object used to communicate responses back to the AccountManager */public class AccountAuthenticatorResponse implements Parcelable &#123;...private IAccountAuthenticatorResponse mAccountAuthenticatorResponse;...public void onResult(Bundle result) &#123; if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; result.keySet(); // force it to be unparcelled Log.v(TAG, \"AccountAuthenticatorResponse.onResult: \" + AccountManager.sanitizeResult(result)); &#125; try &#123; mAccountAuthenticatorResponse.onResult(result); &#125; catch (RemoteException e) &#123; // this should never happen &#125; &#125;...&#125; AbstactAccountAuthenticator get this response and instantiate it again pass to our proper authenticator 12345678910111213141516171819public abstract class AbstractAccountAuthenticator &#123; private class Transport extends IAccountAuthenticator.Stub &#123; ... @Override public void getAuthToken(IAccountAuthenticatorResponse response, Account account, String authTokenType, Bundle loginOptions) throws RemoteException &#123; ... final Bundle result = AbstractAccountAuthenticator.this.getAuthToken( new AccountAuthenticatorResponse(response), account, authTokenType, loginOptions); ... if (result != null) &#123; response.onResult(result); &#125; ... &#125; ... &#125; MyAccountAuthenticator pass this response to ShareMyAccountActivity by intent 123456789101112131415161718class MyAccountAuthenticator extends AbstractAccountAuthenticator&#123; @Override public Bundle getAuthToken(final AccountAuthenticatorResponse response, final Account account, final String authTokenType, final Bundle options) &#123; ... final Intent intent = ShareMyAccountActivity .getShareMyAccountActivity(context); ... intent.putExtra(AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response); final Bundle bundle = new Bundle(); bundle.putParcelable(AccountManager.KEY_INTENT, intent); return bundle; ... &#125;&#125; ShareMyAccountActivity after user confirm give back result 123456789101112public class ShareMyAccountActivityInteractorImpl implements ShareMyAccountActivityContract.Interactor &#123;... @Override public void shareAccess(AccountAuthenticatorResponse accountAuthenticatorResponse, String userName, String accountType, String refreshToken) &#123; ... accountAuthenticatorResponse.onResult(result); ... &#125;&#125; ConclusionIAccountAuthenticatorResponse is used in two parts. As Session : implement and instantiate and bind in Service, work like Binder for Bound Service once service pass it to authenticator by parameter, it will be encapsulated by AccountAuthenticatorResponse As AccountAuthenticatorResponse : it can be passed to activity by intent. If its methodes are called, the IAccountAuthenticatorResponse’s callback fonctions also works. If we take example by its second usage, even without service, we can pass our custom callback to activity. reference: https://developer.android.com/guide/components/aidl#PassingObjects","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiaotong1996.github.io/tags/Android/"}]},{"title":"Android Dagger总结","slug":"Android-Dagger总结","date":"2020-09-23T12:47:39.000Z","updated":"2020-09-23T12:50:17.436Z","comments":true,"path":"2020/09/23/Android-Dagger总结/","link":"","permalink":"https://xiaotong1996.github.io/2020/09/23/Android-Dagger总结/","excerpt":"","text":"Daggerhttps://medium.com/@harivigneshjayapalan/dagger-2-for-android-beginners-dagger-2-part-i-f2de5564ab25 Dependency injection no class should instantiate another class but should get the instances from a configuration class. Dagger@Injectthe@Inject annotation will tell the Dagger what all the dependencies needed to be transferred to the dependant. @ComponentThis annotation is used to build the interface which wires everything together. @Component, in general, is a something like a bridge between @Module(Which we’ll be seeing later) and @Inject. Dagger2 will implement functions we defined in interface with Component annotation according to injection associated with this function. Dagger2 use builder pattern to do it. It can add module attribute to indicate this component contains which modules. *Once we use module attribute, we can’t use DagggerXXXComponnet.create() cause we need to pass module dependency to dagger. So it becomes DagggerXXXComponnet.builder().xXXmodule(new XXXModule(…)).build() @Modulemark modules/classes which can provide dependencies to other classes @Providesused in @module marks the methods which provide dependencies. @Scope@Scope annotation tells dagger to create single instance. It will make the dependency work as singleton. To use it, we need first create a new interface(actually a custom annotation) use @interface to define @Retention is used to describe this custom annotation, limit its usage How to use it? create a new interface(actually a custom annotation) use @interface to define add our custom annotation to component add it to every method we need as singleton Different contextwe use ApplicationContext and Activity context, if we offer 2 context at same time, there is a problem. we need @Named annotation to indicate Dagger choose the correct context for dependency. add @Named() before context construction we add @Named() too before where we use these contexts Another way @Qualifier annotation define a custom annotation with @Qualifier add our custom annotation before context construction just like @Named add this before where we use like @Named Considering life-cycleThe best practice here is, when you’re injecting dependencies into clients who have different life-cycle from where dependencies are coming, it’s better to create a separate module and component for them. Dependency GraphThe best practice of using a component is to expose only the top level dependency and keep other inner dependency under the hood. top level dependencies are those who are not wanted by anyone. use inject define which dependencies we need to inject to its dependent. ex. if class A needs class B, which means A depends on B(B is A’s dependency), we need to use constructor injection. use inject to indicate these dependencies are used in which part in its dependent class. (To engage) use interface and component annotation to define a upper level provider which associate generated code and the dependencies. In this interface, we define some get function for dependent objects. *if we just define function for dependent objects, inject still doesn’t work, we need define corresponding functions for dependencies. click rebuilding, Dagger2 generate DagggerXXXComponnet class which help us inject dependent objects automatically. When we want to use the dependent object, we need first initialize a DagggerXXXComponnet class using create() function, then with the get function we defined in interface(generally it is inject function), we can get dependent instance. draw a Dependency graph, find top level dependencies in it create component and expose these top level dependencies separate different functions in different modules, create modules and add provides annotation for functions we need between different modules, there are also some dependent relations. So if a module needs another, we need to include it in parameters. Do it as @Module(includes = XXXModule.class) . Now we linked all modules we also need to tell component which dependencies it need, using modules attribute.","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiaotong1996.github.io/tags/Android/"}]},{"title":"Android Binder总结","slug":"Android-Binder总结","date":"2020-09-23T12:46:38.000Z","updated":"2020-09-23T12:50:18.314Z","comments":true,"path":"2020/09/23/Android-Binder总结/","link":"","permalink":"https://xiaotong1996.github.io/2020/09/23/Android-Binder总结/","excerpt":"","text":"BinderIntroductionwhat is it[1]Binder is an Android-specific interprocess communication mechanism, and remote method invocation system. It is one of the kernel modules of Android. [2] IBinder is the base interface for a remotable object, the core part of a lightweight RPC (remote procedure call) mechanism designed for high performance when performing in-process and cross-process calls. Shortly, Android offer an unique IPC mechanism which is Binder, Ibinder is the interface describes the abstract protocol for interacting with a remotable object. Ibinder organization[3] The following figure shows the Java layer of the Binder framework which contains main classes and their dependencies Ibinder and Parcelable[4] Parcel is a container for a message (data and object references) that can be sent through an IBinder. [5] Parcelable is the Interface for classes whose instances can be written to and restored from a Parcel. That means any class implements Parcelable can be passed through Ibinder, for example Intent. Usability patternsImplement IBinder allows you to perform in-process and cross-process calls. Ibinder and inter processThe most flexible way to implement IBinder is using AIDL (Android Interface Definition Language). AIDL generates code that takes care of writing the values into the parcels (marshalling) , sending them via Binder IPC, receiving them, reading the values (unmarshalling) and calling the methods of service and writing and sending the result back. It is widely used in Android SDK, but it should be used carefully. [6] Using AIDL is necessary only if you allow clients from different applications to access your service for IPC and want to handle multithreading in your service. Here is an example how to use AIDL pass callback to activity define an AIDL file 1234interface ICallback &#123; void onSuccess(in Account account); void onError(int errorCode, String errorMessage);&#125; \\2. create a custom object class that supports the Parcelable which will be used for communication Make your class implement the Parcelable interface. Implement writeToParcel, which takes the current state of the object and writes it to a Parcel. Add a static field called CREATOR to your class which is an object implementing the Parcelable.Creator interface. 1234567891011121314151617181920212223242526272829303132333435public class CallBack implements Parcelable &#123; public static final Creator&lt;CallBack&gt; CREATOR = new Creator&lt;CallBack&gt;() &#123; @Override public CallBack createFromParcel(Parcel in) &#123; return new CallBack(in); &#125; @Override public CallBack[] newArray(int size) &#123; return new CallBack[size]; &#125; &#125;; private ICallBack mCallBack; public CallBack(Parcel parcel) &#123; mCallBack = ICallBack.Stub.asInterface(parcel.readStrongBinder()); &#125; public void onSucess(Account account) &#123; mCallBack.onSuccess(account); &#125; public void onError(int errorCode, String errorMessage) &#123; mCallBack.onError(errorCode, errorMessage); &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeStrongBinder(mMyAccountRequestResponse.asBinder()); &#125; ...&#125; \\3. start activity and pass this callback through intent 123456789Callback callback = new CallBack(new ICallBack.Stub()&#123; @Override public void onSuccess(Account account)&#123; ... &#125; ...&#125;);intent.putExtra(CALL_BACK, callback);startActivity(intent); Ibinder inside of serviceUsing Bound Service is the most common situation you need to implement Ibinder. [7] Bound Service allows components (such as activities) to bind to the service, send requests, receive responses, and perform interprocess communication (IPC). To provide binding for a service, you must implement the onBind() callback method. This method returns an IBinder object that defines the programming interface that clients can use to interact with the service. According to different situations, you can choose different ways to implement this interface. If your service is private to your own application and runs in the same process as the client (which is common), you should create your interface by extending the Binder class and returning an instance of it from onBind(). If you need your interface to work across different processes, you can create an interface for the service with a Messenger. (which is based on AIDL) If you want your service to handle multiple requests simultaneously, then you can use AIDL directly. In this case, your service must be thread-safe and capable of multi-threading. Here is an example how to use bound service and extend binder to pass callback to activity create a custom service and define a binder which helps you get its instance 123456789101112131415161718192021222324252627public class CustomService extends Service &#123; @NonNull private final IBinder binder = new LocalBinder(); @NonNull private Callback callback; @Override public IBinder onBind(Intent intent) &#123; return binder; &#125; void setCallback(Callback callback)&#123; this.callback=callback; &#125; class LocalBinder extends Binder &#123; CustomService getService() &#123; return CustomService.this; &#125; Callback getCallback()&#123; return this.callback; &#125; &#125;&#125; \\2. implemen ServiceConnection and the onServiceConnected() callback. 123456789101112private ServiceConnection connection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName className, IBinder service) &#123; CustomService.LocalBinder binder = (CustomService.LocalBinder) service; final CustomService mService = binder.getService(); if (mService != null) &#123; mService.setCallback(callback); &#125; &#125; &#125;; \\3. bind this service in your client (activity or ApplicationContext etc) 12final Intent intent = new Intent(context, CustomService.class); context.bindService(intent, connection, Context.BIND_AUTO_CREATE); \\4. you can use the same way to bind another client to this service and pass callback to this new client. ResultReceiver Ibinder as simplifiedIf you just want to receive a callback result you can use ResultReceiver. [8] ResultReceiver is a generic interface for receiving a callback result from someone. Use this by creating a subclass and implement onReceiveResult(int, Bundle), which you can then pass to others and send through IPC, and receive results they supply with send(int, Bundle). It is also implemented by wrapping around Binder Here is an example how to use ResultReceiver to receive a callback result, no need to pass callback to activity implement a ResultReceiver and its onReceiveResult callback and pass it by intent 1234567891011121314151617intent.putExtra(RESULT_RECEIVER, new ResultReceiver(null) &#123; @Override protected void onReceiveResult(final int resultCode, final Bundle resultData) &#123; super.onReceiveResult(resultCode, resultData); if (resultCode == RESULTOK) &#123; Account account = resultData.getParcelable(REQUESTEDACCOUNT); if (account != null) &#123; listener.onSuccess(account); &#125; else &#123; listener.onFailure(); &#125; &#125; else &#123; listener.onFailure(); &#125; &#125; &#125;); context.startActivity(intent); \\2. in activity get this resultReceiver and call its send method 12345resultReceiver = intent.getParcelableExtra(RESULT_RECEIVER);...Bundle bundle = new Bundle();bundle.putParcelable(REQUESTEDACCOUNT, account);resultReceiver.send(RESULTOK, bundle); ConclusionBinder is Android IPC mechanism, it has a low level implementation, work as an important module in Android. Android provides IBinder interface and Binder class as high level abstraction. If you want to perform custom in-process call, you just need to implement IBinder interface. If you want to define custom programming interface to realize your own IPC logic, you need to implement IBinder interface or extend Binder class and work with service. For some simple situations, like receive a callback result, you can choose resultReceiver class which has already wrapped around a Binder. Messenger(Ibinder) as callback channelYou can use Messenger with service like AIDL. Little difference is you need to implement a handler to handle message callback server side 1234567891011121314151617181920212223242526272829303132public class MessengerService extends Service &#123; static final int MSG_USE_ACCOUNT = 1; static class IncomingHandler extends Handler &#123; private Context applicationContext; private Callback callback; IncomingHandler(Context context, Callback callback) &#123; applicationContext = context.getApplicationContext(); this.callback = callback; &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_USE_ACCOUNT: callback.success((Account)msg.obg); break; default: super.handleMessage(msg); &#125; &#125; &#125; Messenger mMessenger; @Override public IBinder onBind(Intent intent) &#123; mMessenger = new Messenger(new IncomingHandler(this,callback)); return mMessenger.getBinder(); &#125;&#125; client side Since messenger impements Parcelable and also provides implementation for Ibinder, you can also use it similar to ResultReceiver without service. References[1] https://elinux.org/Android_Binder [2] https://developer.android.com/reference/android/os/IBinder [3] https://www.nds.ruhr-uni-bochum.de/media/attachments/files/2012/03/binder.pdf [4] https://developer.android.com/reference/android/os/Parcel [5] https://developer.android.com/reference/android/os/Parcelable [6] https://developer.android.com/guide/components/aidl [7] https://developer.android.com/guide/components/bound-services [8] https://developer.android.com/reference/android/os/ResultReceiver http://gityuan.com/2015/11/28/binder-summary/ https://www.jianshu.com/p/2e6936e2de3d","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiaotong1996.github.io/tags/Android/"}]},{"title":"Git 学习笔记","slug":"Git-学习笔记","date":"2020-09-23T12:44:37.000Z","updated":"2020-09-23T12:45:23.712Z","comments":true,"path":"2020/09/23/Git-学习笔记/","link":"","permalink":"https://xiaotong1996.github.io/2020/09/23/Git-学习笔记/","excerpt":"","text":"Githttps://learngitbranching.js.org/?locale=zh_CN 学习笔记 git commitstore a version 现在你可以把提交记录看作是项目的快照 git branch它们只是简单地指向某个提交纪录 —— 仅此而已 现在只要记住使用分支其实就相当于在说：“我想基于这个提交以及它所有的父提交进行新的工作。” git merge在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。” git rebaseRebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。 HEAD我们首先看一下 “HEAD”。 HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。 HEAD 总是指向当前分支上最近一次提交记录 分离 HEADgit checkout C1 相对引用 使用 ^ 向上移动 1 个提交记录 使用 ~ 向上移动多个提交记录，如 ~3 git checkout master^ git checkout HEAD~4 我使用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。例如: 1git branch -f master HEAD~3 上面的命令会将 master 分支强制指向 HEAD 的第 3 级父提交。 相对引用为我们提供了一种简洁的引用提交记录 C1 的方式， 而 -f 则容许我们将分支强制移动到那个位置。 git resetgit reset 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。 git reset HEAD~1 Git Revert虽然在你的本地分支中使用 git reset 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！ 为了撤销更改并分享给别人，我们需要使用 git revert git revert HEAD Git Cherry-pick本系列的第一个命令是 git cherry-pick, 命令形式为: git cherry-pick &lt;提交号&gt;... 如果你想将一些提交复制到当前所在的位置（HEAD）下面的话, Cherry-pick 是最直接的方式了。 交互式的 rebase交互式 rebase 指的是使用带参数 --interactive 的 rebase 命令, 简写为 -i 如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。 git rebase -i HEAD~4 只提取一个提交记录 git rebase -i git cherry-pick 提交的技巧 #1 #2你之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。 此时你想对的某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 newImage 中图片的分辨率，尽管那个提交记录并不是最新的了。 我们可以通过下面的方法来克服困难： 先用 git rebase -i 将提交重新排序，然后把我们想要修改的提交记录挪到最前 然后用 commit --amend 来进行一些小修改 接着再用 git rebase -i 来将他们调回原来的顺序 最后我们把 master 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！ git commit amend 当我们想要对上一次的提交进行修改时，我们可以使用git commit –amend命令。git commit –amend既可以对上次提交的内容进行修改，也可以修改提交说明。 git使用amend选项提供了最后一次commit的反悔。但是对于历史提交呢，就必须使用rebase了。 ​ git rebase -i HEAD~3 ​ 表示要修改当前版本的倒数第三次状态。 ​ 这个命令出来之后，会出来三行东东： ​ pick:*** ​ pick:*** ​ pick:*** ​ 如果你要修改哪个，就把那行的pick改成edit，然后退出。 ​ 这时通过git log你可以发现，git的最后一次提交已经变成你选的那个了，这时再使用： ​ git commit –amend ​ 来对commit进行修改。 ​ 修改完了之后，要回来对不对？ ​ 使用git rebase –continue ​ OK，一切都搞定了。 Git TagsGit 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。 git tag v1 C1 我们将这个标签命名为 v1，并且明确地让它指向提交记录 C1，如果你不指定提交记录，Git 会用 HEAD 所指向的位置。 123git tag v0 c1git tag v1 c2git checkout c2 Git Describe由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签），它就是 git describe！ Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 git bisect（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。 git describe 的语法是： 1git describe ref ref 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）。 它输出的结果是这样的： 1&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt; tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。 当 ref 提交记录上有某个标签时，则只输出标签名称 多分支 rebase1234git rebase master bugFixgit rebase bugFix sidegit rebase side anothergit branch -f master another git rebase master bugFix get all commits bugFix indique and put them under master git branch -f master another move branch master to where another is 选择父提交记录操作符 ^ 与 ~ 符一样，后面也可以跟一个数字。 但是该操作符后面的数字与 ~ 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。 Git 默认选择合并提交的“第一个”父提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。 远程仓库// TODO","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://xiaotong1996.github.io/tags/Git/"}]},{"title":"Blender+Unity3D","slug":"Blender-Unity3D","date":"2019-11-06T21:56:54.000Z","updated":"2019-11-06T21:57:52.045Z","comments":true,"path":"2019/11/06/Blender-Unity3D/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/Blender-Unity3D/","excerpt":"","text":"Blender+Unity3D 用blender建模 将模型以fbx格式导入https://www.mixamo.com网站（用chrome浏览器，firefox有问题） 选择想要的动作（pack选包），下载 导入到unity 将模型拖入场景 在model属性选择select，找到原始模型 在rig的animation type中选择humanoid人形骨骼 点选configue调整avatar 为animator建造动画控制器 将动画拖入动画控制器 每个动画也要转化成humanoid人形骨骼，但不需要再创建avatar，选择已经转好的avatar 通过修改动画中Animation勾选属性looptime可实现动画重复移动","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://xiaotong1996.github.io/tags/Unity/"},{"name":"Blender","slug":"Blender","permalink":"https://xiaotong1996.github.io/tags/Blender/"}]},{"title":"C++刷题实战（Dictionaries and Hashmaps)","slug":"C-刷题实战（Dictionaries-and-Hashmaps)","date":"2019-11-06T21:55:15.000Z","updated":"2019-11-06T21:55:15.577Z","comments":true,"path":"2019/11/06/C-刷题实战（Dictionaries-and-Hashmaps)/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/C-刷题实战（Dictionaries-and-Hashmaps)/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"C++刷题实战（Dictionaries and Hashmaps)","slug":"C-刷题实战（Dictionaries-and-Hashmaps","date":"2019-11-06T21:55:15.000Z","updated":"2019-11-06T21:56:04.053Z","comments":true,"path":"2019/11/06/C-刷题实战（Dictionaries-and-Hashmaps/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/C-刷题实战（Dictionaries-and-Hashmaps/","excerpt":"","text":"C++刷题实战（Dictionaries and Hashmaps)Hash Tables: Ransom Note思路1：剔除note中重复元素，查找note和magazine中每个元素数量，比较 部分测试超时 1234567891011121314151617void checkMagazine(vector&lt;string&gt; magazine, vector&lt;string&gt; note) &#123; //set&lt;string&gt; myM; set&lt;string&gt; myN; for(const auto&amp; n:note)&#123; myN.insert(n); &#125; for(const auto&amp; n:myN)&#123; auto resM=count(begin(magazine),end(magazine),n); auto resN=count(begin(note),end(note),n); if(resN&gt;resM)&#123; cout &lt;&lt;\"No\"&lt;&lt;endl; return; &#125; &#125; cout &lt;&lt;\"Yes\"&lt;&lt;endl;&#125; 思路2：用map存储magazine，遍历note元素，找到map中的对应值 12345678910111213141516171819202122232425// Complete the checkMagazine function below.void checkMagazine(vector&lt;string&gt; magazine, vector&lt;string&gt; note) &#123; unordered_map&lt;string,int&gt; mapM; for(const auto&amp; m:magazine)&#123; if(mapM.find(m)==mapM.end())&#123; mapM.insert(pair&lt;string,int&gt;(m,1)); &#125;else&#123; mapM[m]++; &#125; &#125; for(const auto&amp; n:note)&#123; auto res=mapM.find(n); if(res==mapM.end())&#123; cout &lt;&lt;\"No\"&lt;&lt;endl; return; &#125;else if(res-&gt;second==0)&#123; cout &lt;&lt;\"No\"&lt;&lt;endl; return; &#125; mapM[n]--; &#125; cout &lt;&lt;\"Yes\"&lt;&lt;endl;&#125; 构建计数map 12345678unordered_map&lt;string,int&gt; mapM;for(const auto&amp; m:magazine)&#123; if(mapM.find(m)==mapM.end())&#123; mapM.insert(pair&lt;string,int&gt;(m,1)); &#125;else&#123; mapM[m]++; &#125;&#125; Two Strings思路：若s1和s2同时包含从a到z任意一个字符则有公共子串，否则没有 12345678string twoStrings(string s1, string s2) &#123;for(auto c : \"abcdefghijklmnopqrstuvwxyz\")&#123; if(s1.find_first_of(c)!=std::string::npos&amp;&amp;s2.find_first_of(c)!=std::string::npos)&#123; return \"YES\"; &#125;&#125;return \"NO\";&#125; s1.find_first_of(c)!=std::string::npos Sherlock and Anagrams思路：找出包含相同元素的字串数量 12345678910111213141516171819202122int sherlockAndAnagrams(string s) &#123; int ret = 0; size_t len = s.length(); unordered_map&lt;string, int&gt; rec; for (size_t ilen = 1; ilen &lt; len; ilen++) &#123;//ilen用来递增每次切分的字串长度 for (size_t i = 0; i &lt;= len - ilen; i++) &#123;//i用来递增每次切分字串的起始位置 string curr = s.substr(i, ilen); std::sort(curr.begin(), curr.end());//通过排序使得乱序的字串一致 rec[curr]++;//将相同的字串存入字典 &#125; // for (auto &amp;r : rec) if (r.second &gt; 1) ret += r.second * (r.second - 1) / 2;//遍历字典增加记录 rec.clear(); &#125; return ret;&#125; string curr = s.substr(i, ilen); Count Triplets找等比数列个数 思路：一次遍历：找到前三个构成等比数列的元素（a1,a,2,a3)和他们重复次数(c1,c2,c3)（因为已经排序，所以顺序找下去就行），这三个元素构成等比数列的个数=c1c2c3。之后，每次保留a2，a3和c2，c3作为前两个元素（a1，a2），找新的下一个构成等比数列的元素（新的a3），和它的重复次数（新的c3）。直到a3是最后一个元素。或a3不构成等比数列，则把a3设为a1重新开始。 思路2：也是一次遍历，先把arrA存入hashmap，key为arrA的值，value是重复次数。这样只需要遍历遍map，通过判断key为m mXr 和 mXrXr的value是否存在就可以确保等比数列的构成。（有错） 12345678910111213141516171819202122232425long countTriplets(vector&lt;long&gt; arr, long r) &#123; long count=0; size_t len=arr.size(); if(r==1)&#123; return len*(len-1)*(len-2)/3/2; &#125; unordered_map&lt;long,long&gt; mapA; for(const auto&amp; a:arr)&#123; if(mapA.find(a)==mapA.end())&#123; mapA.insert(pair&lt;long,long&gt;(a,1)); &#125;else&#123; mapA[a]++; &#125; &#125; auto m = mapA.begin(); while(m!=mapA.end())&#123; if(mapA.count(m-&gt;first*r)!=0&amp;&amp;mapA.count(m-&gt;first*r*r)!=0)&#123; count+=mapA[m-&gt;first]*mapA[m-&gt;first*r]*mapA[m-&gt;first*r*r]; &#125; m++; &#125; cout &lt;&lt; count &lt;&lt;endl; return count;&#125; 思路3： 按照作者的意思，作者进行个对arr的遍历，建立两个字典，假设三元组为(A，B，C)，两个字典分别是指对于B来说A已经存在了，以及对于C来说（A，B）的组合已经准备好了。每个字典里面放的并不是实值，而是对于未来三元组的一个可能性的预测，在遍历每个A的同时让B与C的线性空间不断减小，是一个非常有意思的解决思路。 123456789101112long countTriplets(vector&lt;long&gt; arr, long r) &#123; long res=0; unordered_map&lt;long,long&gt; mapA,mapB; for(const auto&amp; a:arr)&#123; if(mapB.count(a)) res+=mapB[a]; if(mapA.count(a)) mapB[a*r]+=mapA[a]; mapA[a*r]++; &#125; return res;&#125; Frequency Queries12345678910111213141516171819202122232425262728293031323334353637vector&lt;int&gt; freqQuery(vector&lt;vector&lt;int&gt;&gt; queries) &#123; int q; int type; int current_count; vector&lt;int&gt; query; vector&lt;int&gt; query_results; unordered_map&lt;long, int&gt; count_map; unordered_map&lt;int, long&gt; frequency_map; q = queries.size(); for(int i =0 ; i &lt; q ;i++)&#123; query = queries[ i ]; type = query[0]; switch(type)&#123; case 1: frequency_map[count_map[ query[1] ]]--; count_map[ query[1] ]++; frequency_map[count_map[ query[1] ]]++; break; case 2: current_count = count_map[ query[1] ]; if(current_count &gt; 0)&#123; frequency_map[current_count]--; count_map[ query[1] ]--; frequency_map[count_map[ query[1] ]]++; &#125; break; case 3: query_results.push_back(( frequency_map[query[1]] &gt; 0 )? 1:0); break; default: break; &#125; &#125; return query_results;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"},{"name":"HackerRank","slug":"HackerRank","permalink":"https://xiaotong1996.github.io/tags/HackerRank/"}]},{"title":"C++刷题实战（Array)","slug":"C-刷题实战（Array)","date":"2019-11-06T21:54:19.000Z","updated":"2019-11-06T21:54:58.967Z","comments":true,"path":"2019/11/06/C-刷题实战（Array)/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/C-刷题实战（Array)/","excerpt":"","text":"C++刷题实战（Array)2D Array - DS思路：不断求和比较更新最大值 123456789101112131415161718192021int hourglassSum(vector&lt;vector&lt;int&gt;&gt; arr) &#123; int sumMax=arr[0][0]+arr[0][1]+arr[0][2] +arr[1][1] +arr[2][0]+arr[2][1]+arr[2][2];; int lNum=arr.size(); int vNum=arr[0].size(); for(int i=0;i&lt;lNum-2;++i)&#123; for(int j=0;j&lt;vNum-2;++j)&#123; int tem=arr[i][j]+arr[i][j+1]+arr[i][j+2] +arr[i+1][j+1] +arr[i+2][j]+arr[i+2][j+1]+arr[i+2][j+2]; if(tem&gt;sumMax)&#123; sumMax=tem; &#125; &#125; &#125; return sumMax;&#125; vector operator[] Arrays: Left Rotation思路：先计算出实际偏移值，因为左移5次是一个循环，然后根据偏移值构建新的int数组 1234567891011121314vector&lt;int&gt; rotLeft(vector&lt;int&gt; a, int d) &#123; int aSize=a.size(); int usefulRotationTime=d%aSize; vector&lt;int&gt; b(aSize,0); for(int i=0;i&lt;aSize;i++)&#123; if(i-usefulRotationTime&lt;0)&#123; b[i-usefulRotationTime+aSize]=a[i]; &#125;else&#123; b[i-usefulRotationTime]=a[i]; &#125; &#125; return b;&#125; New Year Chaos思路：只需要计算本来应该在前面但跑到后面的个数。 1234567891011121314151617181920212223242526272829void minimumBribes(vector&lt;int&gt; q) &#123; int n = A.size(); int cnt = 0; for(int i = n - 1; i &gt;= 0; i--) &#123; if(A[i] != (i + 1)) &#123; if(((i - 1) &gt;= 0) &amp;&amp; A[i - 1] == (i + 1)) &#123; cnt++; swap(A[i], A[i-1]); &#125; else if(((i - 2) &gt;= 0) &amp;&amp; A[i - 2] == (i + 1)) &#123; cnt += 2; A[i - 2] = A[i - 1]; A[i - 1] = A[i]; A[i] = i + 1; &#125; else &#123; printf(&quot;Too chaotic\\n&quot;); return; &#125; &#125; &#125; printf(&quot;%d\\n&quot;,cnt); return;&#125; Minimum Swaps 2思路1：从第一位开始：如果该位不是他本身（不在正确的位置上）就找到他本身并交换，以此类推。有时候会超时 1234567891011121314151617181920212223void swap(vector&lt;int&gt;&amp; arr,int x,int y)&#123; int tem=arr[x]; arr[x]=arr[y]; arr[y]=tem;&#125;// Complete the minimumSwaps function below.int minimumSwaps(vector&lt;int&gt; arr) &#123; int count =0; for(int i=0;i&lt;arr.size();++i)&#123; if(arr[i]!=i+1)&#123; for(int j=i;j&lt;arr.size();++j)&#123; if(arr[j]==i+1)&#123; swap(arr,i,j); count++; break; &#125; &#125; &#125; &#125; return count;&#125; 思路2：将问题图形化，利用闭环，寻找闭环节点数 https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364int minSwaps(int arr[], int n) &#123; // Create an array of pairs where first // element is array element and second element // is position of first element pair&lt;int, int&gt; arrPos[n]; for (int i = 0; i &lt; n; i++) &#123; arrPos[i].first = arr[i]; arrPos[i].second = i; &#125; // Sort the array by array element values to // get right position of every element as second // element of pair. sort(arrPos, arrPos + n); // To keep track of visited elements. Initialize // all elements as not visited or false. vector&lt;bool&gt; vis(n, false); // Initialize result int ans = 0; // Traverse array elements for (int i = 0; i &lt; n; i++) &#123; // already swapped and corrected or // already present at correct pos if (vis[i] || arrPos[i].second == i) continue; // find out the number of node in // this cycle and add in ans int cycle_size = 0; int j = i; while (!vis[j]) &#123; vis[j] = 1; // move to next node j = arrPos[j].second; cycle_size++; &#125; // Update answer by adding current cycle. if (cycle_size &gt; 0) &#123; ans += (cycle_size - 1); &#125; &#125; // Return result return ans; &#125; // Driver program to test the above function int main() &#123; int arr[] = &#123;1, 5, 4, 3, 2&#125;; int n = (sizeof(arr) / sizeof(int)); cout &lt;&lt; minSwaps(arr, n); return 0; &#125; Array Manipulation硬算：超时 1234567891011long arrayManipulation(int n, vector&lt;vector&lt;int&gt;&gt; queries) &#123; vector&lt;long&gt; indexs(n,0); for(auto&amp; q : queries)&#123; for(int i=q[0]-1;i&lt;=q[1]-1;++i)&#123; indexs[i]=indexs[i]+q[2]; &#125; &#125; long it = *max_element(std::begin(indexs), std::end(indexs)); return it;&#125; 用差分数组： 对于序列a{}，取a[i]-a[i-1]为其差分数组b[i]的值，可以发现，a[i]=∑bj（1≤j≤i） https://www.cnblogs.com/COLIN-LIGHTNING/p/8436624.html 1.定义： 对于已知有n个元素的离线数列d，我们可以建立记录它每项与前一项差值的差分数组f：显然，f[1]=d[1]-0=d[1];对于整数i∈[2,n]，我们让f[i]=d[i]-d[i-1]。 2.简单性质： (1)计算数列各项的值：观察d[2]=f[1]+f[2]=d[1]+d[2]-d[1]=d[2]可知，数列第i项的值是可以用差分数组的前i项的和计算的，即d[i]=f[i]的前缀和。 (2)计算数列每一项的前缀和：第i项的前缀和即为数列前i项的和，那么推导可知 即可用差分数组求出数列前缀和； 3.用途： (1)快速处理区间加减操作： 假如现在对数列中区间[L,R]上的数加上x，我们通过性质(1)知道，第一个受影响的差分数组中的元素为f[L],即令f[L]+=x，那么后面数列元素在计算过程中都会加上x；最后一个受影响的差分数组中的元素为f[R],所以令f[R+1]-=x，即可保证不会影响到R以后数列元素的计算。这样我们不必对区间内每一个数进行处理，只需处理两个差分后的数即可； (2)询问区间和问题： 由性质(2)我们可以计算出数列各项的前缀和数组sum各项的值；那么显然，区间[L,R]的和即为ans=sum[R]-sum[L-1]; 1234567891011121314151617long arrayManipulation(int n, vector&lt;vector&lt;int&gt;&gt; queries) &#123; vector&lt;long&gt; cf(n+1,0);//构建下标从1到n+1的N长的差分数组 for(auto&amp; q : queries)&#123; cf[q[0]]+=q[2];//根据差分数组性质 if(q[1]+1&lt;=n) cf[q[1]+1]-=q[2]; &#125; long x=0; long max=0; for(int i=1;i&lt;=n;i++)&#123; x+=cf[i];//根据差分数组性质每加一位就是取最终list中后一位的值，记录最大值 if(max&lt;x) max=x; &#125; return max;&#125; 若将(x，y)区间整体加val，我们就可以对差分数组的b[x]加val，b[y+1]减val。 差分数组","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"},{"name":"HackerRank","slug":"HackerRank","permalink":"https://xiaotong1996.github.io/tags/HackerRank/"}]},{"title":"C++刷题实战（Warm UP）","slug":"C-刷题实战（Warm-UP）","date":"2019-11-06T21:53:19.000Z","updated":"2019-11-06T21:54:47.185Z","comments":true,"path":"2019/11/06/C-刷题实战（Warm-UP）/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/C-刷题实战（Warm-UP）/","excerpt":"","text":"C++刷题实战（Warm UP）Sock Merchant思路：把匹配的袜子挑出来放到新的vector中，每次配对袜子避开那些已经匹配了的 其他思路：用不可重复的容器如set，不断尝试将新的袜子放入若以重复表示匹配 123456789101112131415161718int sockMerchant(int n, vector&lt;int&gt; ar) &#123; vector&lt;int&gt; selected; int count=0; for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(find(selected.begin(),selected.end(),j)==selected.end())&amp;&amp; !(find(selected.begin(),selected.end(),i)!=selected.end()) &amp;&amp;ar[i]==ar[j])&#123; count++; selected.push_back(j); break; &#125; &#125; selected.push_back(i); &#125; return count;&#125; push_back find(selected.begin(),selected.end(),j)!=selected.end()用来找寻元素。这个表示找到了。 Counting Valleys思路：用一个int表示之前状态（在山上，水平面，峡谷里），一个int表示当前状态，只有从山上或水平面，下到峡谷才经过一个峡谷 123456789101112131415161718192021222324int countingValleys(int n, string s) &#123; int state=0; int statePrevious; int valley=0; for(int i=0;i&lt;n;i++)&#123; if(state==0)&#123; statePrevious=0; &#125;else if(state&gt;0)&#123; statePrevious=1; &#125;else&#123; statePrevious=-1; &#125; if(s[i]==&apos;U&apos;)&#123; state++; &#125;else if(s[i]==&apos;D&apos;)&#123; state--; &#125; if(statePrevious&gt;=0&amp;&amp;state&lt;0)&#123; valley++; &#125; &#125; return valley;&#125; Jumping on the Clouds思路：只要向后两个是能站的云就站上去，否则就只向前一步，注意：需要判断结束条件 12345678910111213141516171819int jumpingOnClouds(vector&lt;int&gt; c) &#123; int steps=0; auto player=c.begin(); while(player!=c.end())&#123; if(next(player,2)==--c.end()||next(player,1)==--c.end()) &#123; steps++; break; &#125; if(*next(player,2)==1)&#123; player=next(player,1); &#125;else&#123; player=next(player,2); &#125; steps++; &#125; return steps;&#125; iterator的end指向的是最后一个元素之后的位置，所以为了获得最后一个元素要–操作 iterator是指针，要获得原object要*操作取消引用 关于next，advance的区别：next是advance带返回值的版本 Repeated String1234567891011121314151617long repeatedString(string s, long n) &#123; int length=s.length(); int aNum=0; for(int i=0;i&lt;length;++i)&#123; if(s[i]==&apos;a&apos;)&#123; aNum++; &#125; &#125; long repeteTimes=n/length*aNum; long leftLetters=n%length; for(long i=0;i&lt;leftLetters;++i)&#123; if(s[i]==&apos;a&apos;)&#123; repeteTimes++; &#125; &#125; return repeteTimes;&#125; 思路：a在s中出现频率*s重复次数+最后用于补全的句子中a重复次数，s重复次数=n/s长度。注意：用long 获取字符串长度用length()","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"},{"name":"HackerRank","slug":"HackerRank","permalink":"https://xiaotong1996.github.io/tags/HackerRank/"}]},{"title":"C++学习与总结-高级篇","slug":"C-学习与总结-高级篇","date":"2019-11-06T21:52:02.000Z","updated":"2019-11-06T21:52:21.515Z","comments":true,"path":"2019/11/06/C-学习与总结-高级篇/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/C-学习与总结-高级篇/","excerpt":"","text":"C++学习与总结-高级篇小结： 文件读写和文件位置定位 try、catch、throw 定义新的异常，继承exception 栈：在函数内部声明的所有变量都将占用栈内存。 堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。 模板 预处理器和宏 信号处理 多线程 STL C++ 文件和流 和 ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。 文件操作：打开open，关闭close，写入 &lt;&lt; ，读取 >&gt; 文件位置指针 istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（”seek get”）和关于 ostream 的 seekp（”seek put”）。 seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。 文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。 C++ 异常处理 三个关键字：try、catch、throw 定义新的异常 您可以通过继承和重载 exception 类来定义新的异常。 C++ 动态内存C++ 程序中的内存分为两个部分： 栈：在函数内部声明的所有变量都将占用栈内存。 堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。 在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 new 运算符。 如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。 malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。 C++ 命名空间 在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。 因此，引入了命名空间这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。 C++ 模板模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。 模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。 C++ 预处理器预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。 所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。 我们已经看到，之前所有的实例中都有 #include 指令。这个宏用于把头文件包含到源文件中。 #define 预处理指令用于创建符号常量。该符号常量通常称为宏， 您可以使用 #define 来定义一个带有参数的宏 条件编译, 有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。 123#ifdef NULL #define NULL 0#endif C++ 中的预定义宏: __LINE__ 这会在程序编译时包含当前行号。 __FILE__ 这会在程序编译时包含当前文件名。 __DATE__ 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 __TIME__ 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 # 和 ## 运算符 # 字符串化的意思，出现在宏定义中的#是把跟在后面的参数转换成一个字符串。 当用作字符串化操作时，# 的主要作用是将宏参数不经扩展地转换成字符串常量。 宏定义参数的左右两边的空格会被忽略，参数的各个 Token 之间的多个空格会被转换成一个空格。 宏定义参数中含有需要特殊含义字符如”或\\时，它们前面会自动被加上转义字符 \\。 ## 连接符号，把参数连在一起。 将多个 Token 连接成一个 Token。要点： 它不能是宏定义中的第一个或最后一个 Token。 前后的空格可有可无。 C++ 信号处理信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。 有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 中。 signal() 函数C++ 信号处理库提供了 signal 函数，用来捕获突发事件。以下是 signal() 函数的语法： 1void (*signal (int sig, void (*func)(int)))(int); 您可以使用函数 raise() 生成信号，该函数带有一个整数信号编号作为参数，语法如下： 1int raise (signal sig); Sleep 函数 功能：执行挂起一段时间，也就是等待一段时间在继续执行 用法：Sleep(时间) 注意： （1）Linux 用 #include 和 sleep()，Windos 用 #include 和 Sleep()。 （2）Sleep括号里的时间，在windows下是已毫秒为单位，而LInux是已秒为单位。 C++ 多线程多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：基于进程和基于线程。 基于进程的多任务处理是程序的并发执行。 基于线程的多任务处理是同一程序的片段的并发执行。 c++ 11 之后有了标准的线程库： #include C++ Web 编程 公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。 C++ STL 教程C++ 标准模板库的核心包括以下三个组件： 组件 描述 例子 容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 vector，string，list，set（任意两元素不相等），map,stack,queue,deque(双端队列，动态数组) 算法（Algorithms） 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 迭代器（iterators） 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 标准模板库包含了序列容器（sequence containers）与关系容器（associative containers）。 数据容器 描述 序列容器 - 有序集 vector) 动态数组，兼容C语言数组。vector可以如同数组一样的访问方式，例如使用下标（operator[]）运算符，并记得自己的长度信息（size），您也可以使用对象的方式来访问vector（push_back、pop_back）。使用vector可以轻易地定义多维可调整型数组（std::vector&lt;std::vector&lt;…&gt; &gt;）。要使用vector，必须含入vector头文件。vector可在O(1)内完成在末尾插入 / 移除元素，但在vector中间或开头插入/移除元素，则需要消耗O(n)时间。 list) list容器是一个有序（Ordered）的数据结构（循序容器），每个元素中存储着上一个元素和下一个元素的地址（指针），因此是一个双向链接的链表。与vector相比，其元素的访问速度较慢，而在已知元素位置的情况下，插入和删除速度较快。STL容器中唯一支持事务语义。 forward_list （单向链表） list的单链表版，去掉了一些操作。 deque （双端队列） 可看做为能在常量时间内完成向开头或结尾插入或删除元素的vector，但是修改之后，其迭代器的有效性就无法得到保障。 array 只能在初始化时指定大小的数组，可视为内置数组的封装。 关联容器 - 无序集 set 不重复元素的集合。 multiset 跟set具有相同功能，但允许重复的元素。 map&amp;action=edit&amp;redlink=1) 关联数组，每个元素含有两个数据项，map将一个数据项映射到另一个数据项中。 multimap 跟map具有相同功能，但允许重复的键值。 unordered_set unordered_multiset unordered_map unordered_multimap 分别类似于集合、多重集合、映射、多重映射，但使用哈希表实现。它的键（Keys）没有排序（operator&lt;），相反必须存在一个从键类型到size_t的哈希函数、且要求键之间可以判等（operator==）。自C++11起进入语言标准。 其他类型的容器 bitset 存储系列位类似的固定大小的布尔向量。实现按位运算，没有迭代器，不是序列。可视为std::array&lt;bool, N&gt;。若需要改变序列长度，可用std::vector。 valarray 数值类型的std::vector。牺牲泛型能力而专为数值计算做了优化，例如在数组上的sin操作可对数组内所有数值取正弦。有些实现会对std::valarray应用向量指令等优化手段。 一个观点是里面全是数值类型的valarray才是数学意义上的向量，而可以泛型的vector更该叫array——编程语言中的数组。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"C++学习与总结-1114篇","slug":"C-学习与总结-1114篇","date":"2019-11-06T21:50:26.000Z","updated":"2019-11-06T21:51:32.429Z","comments":true,"path":"2019/11/06/C-学习与总结-1114篇/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/C-学习与总结-1114篇/","excerpt":"","text":"C++学习与总结-11/14篇小结： 使用nullptr而不是NULL 巧用auto for(auto &amp;x : array) {**std::cout &lt;&lt; x &lt;&lt; std::endl;** } 使用 {} 进行初始化 模板可用using改名，可添加默认参数，可变长 构造函数可以委托和继承 关键字 override 和 final用于控制重载 default和delete用于控制编译器生成默认构造函数 enum class 使用lambda表达式和捕获列表 用std::function包装函数，将函数和函数指针作为对象处理 std::move 总会接受到一个左值，从而转发调用了reference(int&amp;&amp;) 输出右值引用。 std::array std::shared_ptr/std::unique_ptr/std::weak_ptr std::regex 和 noexcept 修饰符 字面量R nullptr 与 constexpr 当需要使用 NULL 时候，请养成直接使用 nullptr 的习惯。 constexpr常量表达式 让用户显式的声明函数或对象构造函数在编译器会成为常数 从 C++ 14 开始，constexptr 函数可以在内部使用局部变量、循环和分支等简单语句 类型推导 C++ 11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。 使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器 1for(auto itr = vec.cbegin(); itr != vec.cend(); ++itr); 注意：auto 不能用于函数传参， auto 还不能用于推导数组类型： decltype 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。 和sizeof相似： 有时候，我们可能需要计算某个表达式的类型，例如： 123auto x = 1;auto y = 2;decltype(x+y) z; // z 是一个 int 型的 从 C++ 14 开始是可以直接让普通函数具备返回值推导 1234template&lt;typename T, typename U&gt;auto add(T x, U y) &#123; return x+y;&#125; 区间迭代1234int array[] = &#123;1,2,3,4,5&#125;;for(auto &amp;x : array) &#123; std::cout &lt;&lt; x &lt;&lt; std::endl;&#125; 初始化列表 使用 {} 进行初始化 C++11 首先把初始化列表的概念绑定到了类型上，并将其称之为 std::initializer_list，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如： 123456789#include &lt;initializer_list&gt;class Magic &#123;public: Magic(std::initializer_list&lt;int&gt; list) &#123;&#125;&#125;;Magic magic = &#123;1,2,3,4,5&#125;;std::vector&lt;int&gt; v = &#123;1, 2, 3, 4&#125;; 初始化列表除了用在对象构造上，还能将其作为普通函数的形参，例如： 12345void func(std::initializer_list&lt;int&gt; list) &#123; return;&#125;func(&#123;1,2,3&#125;); 模板增强外部模板1extern template class std::vector&lt;double&gt;; // 不在该编译文件中实例化模板 类型别名模板1using process = int(*)(void *); // 定义了一个返回类型为 int，参数为 void* 的函数指针类型，名字叫做 process 默认模板参数1234template&lt;typename T = int, typename U = int&gt;auto add(T x, U y) -&gt; decltype(x+y) &#123; return x+y;&#125; 变长参数模板1template&lt;typename... Ts&gt; class Magic; 可以使用 sizeof... 来计算参数的个数 对参数进行解包 : 递归模板函数 1234567891011121314#include &lt;iostream&gt;template&lt;typename T&gt;void printf(T value) &#123; std::cout &lt;&lt; value &lt;&lt; std::endl;&#125;template&lt;typename T, typename... Args&gt;void printf(T value, Args... args) &#123; std::cout &lt;&lt; value &lt;&lt; std::endl; printf(args...);&#125;int main() &#123; printf(1, 2, &quot;123&quot;, 1.1); return 0;&#125; 初始化列表展开 1234567891011template&lt;typename T, typename... Args&gt;auto print(T value, Args... args) &#123; std::cout &lt;&lt; value &lt;&lt; std::endl; return std::initializer_list&lt;T&gt;&#123;([&amp;] &#123; std::cout &lt;&lt; args &lt;&lt; std::endl; &#125;(), value)...&#125;;&#125;int main() &#123; print(1, 2.1, &quot;123&quot;); return 0;&#125; 面向对象增强委托构造 C++ 11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的： 1234567891011121314151617class Base &#123;public: int value1; int value2; Base() &#123; value1 = 1; &#125; Base(int value) : Base() &#123; // 委托 Base() 构造函数 value2 = 2; &#125;&#125;;int main() &#123; Base b(2); std::cout &lt;&lt; b.value1 &lt;&lt; std::endl; std::cout &lt;&lt; b.value2 &lt;&lt; std::endl;&#125; 继承构造在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++ 11 利用关键字 using 引入了继承构造函数的概念： 1234567891011121314151617181920class Base &#123;public: int value1; int value2; Base() &#123; value1 = 1; &#125; Base(int value) : Base() &#123; // 委托 Base() 构造函数 value2 = 2; &#125;&#125;;class Subclass : public Base &#123;public: using Base::Base; // 继承构造&#125;;int main() &#123; Subclass s(3); std::cout &lt;&lt; s.value1 &lt;&lt; std::endl; std::cout &lt;&lt; s.value2 &lt;&lt; std::endl;&#125; 显式虚函数重载 C++ 11 引入了 override 和 final 这两个关键字来防止上述情形的发生。 当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译。 final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。 显式禁用默认函数 允许显式的声明采用或拒绝编译器自带的函数。 123456class Magic &#123;public: Magic() = default; // 显式声明使用编译器生成的构造 Magic&amp; operator=(const Magic&amp;) = delete; // 显式声明拒绝编译器生成构造 Magic(int magic_number);&#125; 强类型枚举C++ 11 引入了枚举类（enumaration class），并使用 enum class 的语法进行声明： 123456enum class new_enum : unsigned int &#123; value1, value2, value3 = 100, value4 = 100&#125;; 在这个语法中，枚举类型后面使用了冒号及类型关键字来指定枚举中枚举值的类型，这使得我们能够为枚举赋值（未指定时将默认使用 int）。 而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 &lt;&lt; 这个算符来进行输出，可以收藏下面这个代码段： 123456#include &lt;iostream&gt;template&lt;typename T&gt;std::ostream&amp; operator&lt;&lt;(typename std::enable_if&lt;std::is_enum&lt;T&gt;::value, std::ostream&gt;::type&amp; stream, const T&amp; e)&#123; return stream &lt;&lt; static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(e);&#125; 这时，下面的代码将能够被编译： 1std::cout &lt;&lt; new_enum::value3 &lt;&lt; std::endl Lambda表达式Lambda 表达式的基本语法如下： 1234[捕获列表](参数列表) mutable(可选) 异常属性 -&gt; 返回类型 &#123; // 函数体&#125;[ caputrue ] ( params ) opt -&gt; ret &#123; body; &#125;; 所谓捕获列表，其实可以理解为参数的一种类型，lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的，这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种： 1. 值捕获 2. 引用捕获 3. 隐式捕获 总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是： [] 空捕获列表 [name1, name2, ...] 捕获一系列变量 [&amp;] 引用捕获, 让编译器自行推导捕获列表 [=] 值捕获, 让编译器执行推导应用列表 表达式捕获（C++ 14） 泛型 Lambda (C++ 14) auto 关键字来产生意义上的泛型： 函数对象包装器C++11 std::function 是一种通用、多态的函数封装，它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作，它也是对 C++中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的），换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。例如： 123456789101112131415161718#include &lt;functional&gt;#include &lt;iostream&gt;int foo(int para) &#123; return para;&#125;int main() &#123; // std::function 包装了一个返回值为 int, 参数为 int 的函数 std::function&lt;int(int)&gt; func = foo; int important = 10; std::function&lt;int(int)&gt; func2 = [&amp;](int value) -&gt; int &#123; return 1+value+important; &#125;; std::cout &lt;&lt; func(10) &lt;&lt; std::endl; std::cout &lt;&lt; func2(10) &lt;&lt; std::endl;&#125; 而 std::bind 则是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用 右值引用 传统的 C++ 没有区分『移动』和『拷贝』的概念，造成了大量的数据移动，浪费时间和空间。右值引用的出现恰好就解决了这两个概念的混淆问题 无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发，所以 std::move 总会接受到一个左值，从而转发调用了reference(int&amp;&amp;) 输出右值引用。 新增容器std::array使用 std::array 保存在栈内存中，相比堆内存中的 std::vector，我们就能够灵活的访问这里面的元素，从而获得更高的性能；同时正式由于其堆内存存储的特性，有些时候我们还需要自己负责释放这些资源。 而第二个问题就更加简单，使用std::array能够让代码变得更加现代，且封装了一些操作函数，同时还能够友好的使用标准库中的容器算法等等，比如 std::sort。 std::array 会在编译时创建一个固定大小的数组，std::array 不能够被隐式的转换成指针，使用 std::array 很简单，只需指定其类型和大小即可： 1std::array&lt;int, 4&gt; arr= &#123;1,2,3,4&#125;; std::forward_list std::forward_list 使用单向链表进行实现 C++11 引入了两组无序容器：std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。 元组 std::tuple关于元组的使用有三个核心的函数： std::make_tuple: 构造元组 std::get: 获得元组某个位置的值 std::tie: 元组拆包 智能指针和引用计数 std::shared_ptr/std::unique_ptr/std::weak_ptr，使用它们需要包含头文件memory。 std::make_shared 就能够用来消除显示的使用 new，所以std::make_shared 会分配创建传入参数中的对象，并返回这个对象类型的std::shared_ptr指针。例如： 1auto pointer = std::make_shared&lt;int&gt;(10); std::shared_ptr 可以通过 get() 方法来获取原始指针，通过 reset() 来减少一个引用计数，并通过get_count()来查看一个对象的引用计数。 std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证了代码的安全： 是，我们可以利用 std::move 将其转移给其他的 unique_ptr std::weak_ptr是一种弱引用（相比较而言 std::shared_ptr 就是一种强引用）。弱引用不会引起引用计数增加 std::weak_ptr 没有 * 运算符和 -&gt; 运算符，所以不能够对资源进行操作，它的唯一作用就是用于检查 std::shared_ptr 是否存在，expired() 方法在资源未被释放时，会返回 true，否则返回 false。 正则表达式 C++11 提供的正则表达式库操作 std::string 对象，模式 std::regex (本质是 std::basic_regex)进行初始化，通过 std::regex_match 进行匹配，从而产生 std::smatch （本质是 std::match_results 对象）。 线程支持 std::thread 用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含头文件，它提供了很多基本的线程操作，例如get_id()来获取所创建线程的线程 ID，例如使用 join() 来加入一个线程 等等 C++11 引入了 mutex 相关的类，其所有相关的函数都放在mutex 头文件中。 std::mutex 是 C++11 中最基本的 mutex 类，通过实例化 std::mutex 可以创建互斥量，而通过其成员函数 lock() 可以仅此能上锁，unlock() 可以进行解锁。但是在在实际编写代码的过程中，最好不去直接调用成员函数，因为调用成员函数就需要在每个临界区的出口处调用 unlock()，当然，还包括异常。这时候 C++11 还为互斥量提供了一个 RAII 语法的模板类std::lock_gurad。RAII 在不失代码简洁性的同时，很好的保证了代码的异常安全性。 在 RAII 用法下，对于临界区的互斥量的创建只需要在作用域的开始部分，例如： 123456789void some_operation(const std::string &amp;message) &#123; static std::mutex mutex; std::lock_guard&lt;std::mutex&gt; lock(mutex); // ...操作 // 当离开这个作用域的时候，互斥锁会被析构，同时unlock互斥锁 // 因此这个函数内部的可以认为是临界区&#125; 在并发编程中，推荐使用 std::unique_lock。例如： 1234567891011121314151617#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;std::mutex mtx;void block_area() &#123; std::unique_lock&lt;std::mutex&gt; lock(mtx); //...临界区&#125;int main() &#123; std::thread thd1(block_area); thd1.join(); return 0;&#125; std::future 则是提供了一个访问异步操作结果的途径 std::packaged_task 可以用来封装任何可以调用的目标，从而用于实现异步的调用 std::condition_variable 是为了解决死锁而生的。当互斥操作不够用而引入的。 其他 long long int 类型至少具备 64 位的比特数。 C++11 将异常的声明简化为以下两种情况： 函数可能抛出任何异常 函数不能抛出任何异常 并使用 noexcept 对这两种行为进行限制，例如： 12void may_throw(); // 可能抛出异常void no_throw() noexcept; // 不可能抛出异常 使用 noexcept 修饰过的函数如果抛出异常，编译器会使用 std::terminate() 来立即终止程序运行。 noexcept 还能用作操作符，用于操作一个表达式，当表达式无异常时，返回 true，否则返回 false。 C++11 提供了原始字符串字面量的写法，可以在一个字符串前方使用 R 来修饰这个字符串，同时，将原始字符串使用括号包裹，例如： 1std::string str = R&quot;(C:\\\\What\\\\The\\\\Fxxk)&quot;; C++11 引进了自定义字面量的能力，通过重载双引号后缀运算符实现：","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"C++学习与总结-基础篇","slug":"C-学习与总结-基础篇","date":"2019-11-06T21:47:01.000Z","updated":"2019-11-06T21:51:13.084Z","comments":true,"path":"2019/11/06/C-学习与总结-基础篇/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/C-学习与总结-基础篇/","excerpt":"","text":"C++学习与总结-基础篇小结： 用#if 0code#endif 测试 typedef重命名类型 常量：const 和 #define 引用 clog 拷贝构造函数 函数重载和运算符重载 virtual虚函数，动态链接，数据封装，多态 纯虚函数，接口，抽象类 C++11/14 以前的重要特性： C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。 四大特性： 封装 抽象 继承 多态 关于注释我们还可以使用 #if 0 … #endif 来实现注释，且可以实现嵌套，格式为： 123#if 0 code#endif 你可以把 #if 0 改成 #if 1 来执行 code 的代码。 这种形式对程序调试也可以帮助，测试时使用 #if 1 来执行测试代码，发布后使用 #if 0 来屏蔽测试代码。 #if 后可以是任意的条件语句。 下面的代码如果 condition 条件为 true 执行 code1 ，否则执行 code2。 12345#if condition code1#else code2#endif 关于数据类型char 一个字节 int 四个字节 float 四个字节 使用 typedef 为一个已有的类型取一个新的名字 关于变量类型C++ 中有两种类型的表达式： 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。 关于常量在 C++ 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 使用 const 关键字。 关于存储类 存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。 关于运算符 sizeof 返回变量的大小 Condition ? X : Y 如果 Condition 为真 ? 则值为 X : 否则值为 Y。 &amp; 返回变量的地址 * 指向一个变量 关于函数向函数传递参数的传值调用方法，把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 向函数传递参数的指针调用方法，把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 向函数传递参数的引用调用方法，把引用的地址复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。 关于引用 引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 关于标准输入输出标准日志流（clog） 预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。 关于类和对象使用初始化列表来初始化字段 C::C( double a, double b, double c): X(a), Y(b), Z(c) 拷贝构造函数必须定义拷贝构造函数的情况： 只包含类类型成员或内置类型（但不是指针类型）成员的类，无须显式地定义拷贝构造函数也可以拷贝；有的类有一个数据成员是指针，或者是有成员表示在构造函数中分配的其他资源，这两种情况下都必须定义拷贝构造函数。 什么情况使用拷贝构造函数： 类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数： （1）一个对象以值传递的方式传入函数体 （2）一个对象以值传递的方式从函数返回 （3）一个对象需要通过另外一个对象进行初始化。 友元函数类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。 因为友元函数没有this指针，则参数要有三种情况： 要访问非static成员时，需要对象做参数； 要访问static成员或全局变量时，则不需要对象做参数； 如果做参数的对象是全局对象，则不需要对象做参数. 可以直接调用友元函数，不需要通过对象或指针 关于继承多继承(环状继承),A-&gt;D, B-&gt;D, C-&gt;(A，B)，例如： 1234class D&#123;......&#125;;class B: public D&#123;......&#125;;class A: public D&#123;......&#125;;class C: public B, public A&#123;.....&#125;; 这个继承会使D创建两个对象,要解决上面问题就要用虚拟继承格式 格式：class 类名: virtual 继承方式 父类名 1234class D&#123;......&#125;;class B: virtual public D&#123;......&#125;;class A: virtual public D&#123;......&#125;;class C: public B, public A&#123;.....&#125;; 虚继承–（在创建对象的时候会创建一个虚表）在创建父类对象的时候 12A:virtual public DB:virtual public D 关于重载C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 1Box operator+(const Box&amp;); 关于多态虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。 我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。 不添加virtual就是静态多态，或静态链接。 您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。 12// pure virtual functionvirtual int area() = 0; 关于数据抽象用类定义抽象数据类型（ADT） 设计策略 抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。 在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可。 关于数据封装 C++ 通过创建类来支持封装和数据隐藏（public、protected、private） C++中, 虚函数可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关。 关于接口 C++ 接口是使用抽象类来实现的， 如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的， 如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的 设计策略 面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。 外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。 这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"OpenGL（glut） 开发跳一跳实战","slug":"OpenGL（glut）-开发跳一跳实战","date":"2019-11-06T21:45:12.000Z","updated":"2019-11-06T21:51:37.880Z","comments":true,"path":"2019/11/06/OpenGL（glut）-开发跳一跳实战/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/OpenGL（glut）-开发跳一跳实战/","excerpt":"","text":"OpenGL（glut） 开发跳一跳实战1. 找到素材因为老师给的glut库只支持特定格式的3D模型，本来想用blender建模导入，尝试不行。所以就先在网上先找到（.off) 的棋子模型 2. 实现棋子的显示 声明模型 1Model3D *chess_piece_model = NULL; // main character model: chess piece 创建模型实例并加载资源 12chess_piece_model = new Model3D();chess_piece_model-&gt;load_3d_model(&quot;resources/chess_piece.off&quot;); 绘制模型 棋子颜色为黑色纯色，也可使用texture 12345678910111213141516171819202122void display_chess_piece_model()&#123; glPushMatrix(); glTranslatef(0, 14, 0); // pour le positioner sur le terrain glScalef(10, 10, 10); glBegin(GL_TRIANGLES); for (int i = 0; i &lt; chess_piece_model-&gt;nb_triangles; i++) &#123; glColor3f(0.0f, 0.0f, 0.0f); glVertex3f(chess_piece_model-&gt;points[chess_piece_model-&gt;faces[i].a].x, chess_piece_model-&gt;points[chess_piece_model-&gt;faces[i].a].y, chess_piece_model-&gt;points[chess_piece_model-&gt;faces[i].a].z); glVertex3f(chess_piece_model-&gt;points[chess_piece_model-&gt;faces[i].b].x, chess_piece_model-&gt;points[chess_piece_model-&gt;faces[i].b].y, chess_piece_model-&gt;points[chess_piece_model-&gt;faces[i].b].z); glVertex3f(chess_piece_model-&gt;points[chess_piece_model-&gt;faces[i].c].x, chess_piece_model-&gt;points[chess_piece_model-&gt;faces[i].c].y, chess_piece_model-&gt;points[chess_piece_model-&gt;faces[i].c].z); &#125; glEnd(); glPopMatrix();&#125; 3. 实现平台的显示平台是基于立方体做transform得到的。所以要先实现立方体的绘制。 绘制立方体，参见这篇文章 https://www.cnblogs.com/icmzn/p/5049768.html 用一个二维数组vertex_list记录立方体点位置 12345678910static const GLfloat vertex_list[][3] = &#123; -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f,&#125;; 用另一个二维数组记录面和点的绘制顺序 12345678static const GLint index_list[][4] = &#123; 0, 2, 3, 1, 4, 6, 2, 0, 4, 0, 1, 5, 4, 6, 7, 5, 5, 7, 3, 1, 6, 2, 3, 7,&#125;; 因为为了方便在平台不同面显示不同内容（方便打广告XD），把顶面和其他面的显示分开实现。 用了两个texture。一个是箭头放在顶面用来实现类似劲舞团的功能，另一个是纯色图片用于装饰其他面 以下是显示顶面的代码 123456789101112131415161718192021222324252627282930313233343536373839404142void display_cube_face() &#123; glBindTexture(GL_TEXTURE_2D, texture_arrow-&gt;OpenGL_ID[0]); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE); if (texture_arrow-&gt;isRGBA) gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA8, texture_arrow-&gt;img_color-&gt;lenx, texture_arrow-&gt;img_color-&gt;leny, GL_RGBA, GL_UNSIGNED_BYTE, texture_arrow-&gt;img_all); else gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGB8, texture_arrow-&gt;img_color-&gt;lenx, texture_arrow-&gt;img_color-&gt;leny, GL_RGB, GL_UNSIGNED_BYTE, texture_arrow-&gt;img_color-&gt;data); glEnable(GL_TEXTURE_2D); glPolygonMode(GL_FRONT, GL_FILL); glPolygonMode(GL_BACK, GL_FILL); glBegin(GL_QUADS); for (int j = 0; j &lt; 4; ++j) &#123; switch (j) &#123; case 0: glTexCoord2f(0, 0); break; case 1: glTexCoord2f(0, 1); break; case 2: glTexCoord2f(1, 1); case 3: glTexCoord2f(1, 0); break; &#125; glVertex3fv(vertex_list[index_list[5][j]]); &#125; glEnd(); glPolygonMode(GL_FRONT, GL_FILL); // front of a face is filled glPolygonMode(GL_BACK, GL_LINE); glDisable(GL_ALPHA_TEST); glDisable(GL_TEXTURE_2D);&#125; 实现棋子移动获取收入修改棋子位置 123456789101112if (inp-&gt;keys[KEY_CODE_W]) &#123; chess_posZ += chees_move_speed; &#125; if (inp-&gt;keys[KEY_CODE_S]) &#123; chess_posZ -= chees_move_speed; &#125; if (inp-&gt;keys[KEY_CODE_A]) &#123; chess_posX += chees_move_speed; &#125; if (inp-&gt;keys[KEY_CODE_D]) &#123; chess_posX -= chees_move_speed; &#125; 实现棋子跳跃通过两个bool变量，jump和falldown来检测棋子跳起下落状态 1234567891011121314151617181920if (jump) &#123; if (tim-&gt;global_timer_25_Hz) &#123; if (!falldown) &#123; chess_posY += 0.6f; &#125; else &#123; chess_posY -= 0.7f; &#125; if (chess_posY &gt; 20) falldown = true; if (chess_posY &lt; 5) &#123; chess_posY = 5; jump = false; falldown = false; //debug(&quot;end jump&quot;); &#125; &#125; &#125; 实现类似劲舞团的输入响应用一个二维数组记录每次正确输入后，棋子的新位置，即每个棋盘所在位置。 123456static const int chess_routes[][2] = &#123; 0,20, 25,20, 50,20, 50,35,&#125;; 用另一个二维数组记录，正确输入的键盘值序列。 123456static const int required_inputs[] = &#123; KEY_CODE_2, KEY_CODE_8, KEY_CODE_6, KEY_CODE_4,&#125;; 每一次按方向键，检测是否输入正确，并处理 12345678if (inp-&gt;keys[KEY_CODE_UP]) &#123; if (required_inputs[chess_current_index] == KEY_CODE_8) &#123; chess_posX = chess_routes[chess_current_index][0]; chess_posZ = chess_routes[chess_current_index][1]; chess_current_index++; //debug(&quot;%d\\n&quot;, chess_current_index); &#125;&#125; 待解决问题主要问题是我把相机视角设置为45度俯视。跟随棋子移动有问题。如果能正确锁定棋子，可以让平台随机生成，每到一个新的平台就自动生成下个平台，并确保显示正确。现在因为视角追随问题，还不能实现。 第二个问题是键盘输入。如果要实现跳一跳，要知道按了多久的空格键。有待解决。","categories":[],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"https://xiaotong1996.github.io/tags/OpenGL/"}]},{"title":"ORB-SLAM学习","slug":"ORB-SLAM学习","date":"2019-11-06T21:43:53.000Z","updated":"2019-11-06T21:44:23.865Z","comments":true,"path":"2019/11/06/ORB-SLAM学习/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/ORB-SLAM学习/","excerpt":"","text":"ORB-SLAM编译环境win10+CMake+Visual Studio2017 使用vcpkg下载Eigen3，OpenCV，Pangolin包 下载ORB-SLAM.zip，解压，并用cmake编译 运行ORB-SLAM 下载数据集 在windows命令行执行.\\mono_euroc 摄像机校准每个摄像机有一下投影参数： longueurs focales焦距（fx，fy）（单位：像素pixels） centre optique (cx,cy) paramètres de distorsions radiale 辐射失真参数（k1,k2,[k3]) paramètres de distorsions tangentielle 切向失真参数（p1,p2) 用于校准照相机 校准需要比较已知3D点坐标（(les points de la mire : le damier qui vous est fourni，视点，棋盘坐标）和一系列由此棋盘得到的照片上对应的点 步骤： 解压缩OpenCV_Calibration文件夹，cmake编译 使用棋盘来校准，此棋盘格的横向包含8个内部角（双曲线点），纵向包含6个角（如果需要，反之亦然）。 每个棋盘格盒宽30毫米。 运行calibration程序，不加任何参数，来获得参考文件/用help（）也行 然后，使用计划要在工作空间中散布的至少10张照片来校准相机。 在“良好”校准期间，您的重新投影误差应小于0.5像素。 如果不是这种情况，请重复校准。 通过calibration程序，您可以将相机矩阵（包含相机的固有参数（以像素为单位的焦距（fx，fy）和主要点（cx，cy））保存为.yml或.yaml类型的文件。 问答： 为什么对同样的数据执行ORB-SLAM从来不会得到同样的结果？ 随机数和多线程 KeyFrames的作用是什么？包含了什么？ Camera parameters Tiw:Camera extrinsics(Pose) [Camera intrinsics] Featurepoints (2D points + descriptors ) 是否与Mappoint相关联（3D点） Bag of Wordsdes features 用于在失去跟踪器的情况下进行重定位和闭环 关键帧Ki (Key Frame) 存贮下列信息：1， 相机的位姿 Tiw， 这是一个刚体转换， 用于转换世界坐标系中的点到相机坐标系。2， 相机的内参， 包括焦距(focal length) 和主点 (principal point)3， 帧中提取的ORB特征， 与一个地图点关联或者不关联， 如果畸变模型提供的话， 这个地图点的坐标是经过矫正没有畸变的。 ORB-SLAM的地图包含KeyFrames和MapPoints。解释在什么条件下： 一个新的KeyFrame会被创建 Spawn new Keyframe if: More than 20 frames have passed and local mapping is idle and current frames tracks at least 50 points and current frame tracks less than 90% point of kref 当超过20帧已经通过且local mapping是闲置状态且当前帧已经追踪到至少50个点且当前帧追踪少于kref中90%的点，则产生新的关键帧 一个KeyFrame会被销毁 Local Keyframes culling 关键帧删减 Discard keyframes in Kc whose 90% points are seen in 3 other keyframes 丢弃掉在其他三个关键帧中90%的点都可见的关键帧 一个新的MapPoint会被创建 New map points creation 生成新的map points Triangulate Ki matched ORBs from connected Keyframes (Kc) in visibility graph 从可见图中相连的关键帧中对应上ORB的点做三角化处理 Match ki unmatched ORBs in kc with epipolar constraint and triangulate them 一个MapPoint会被删除 Recent map points culling 最近map points删减 ~ Prune map points not visible in more than 3 connected keyframes in visibility graph 删除可见图中3个以上相连的关键帧中不可见的map points 此外，KeyFrames和MapPoints是否真的被销毁？ ORB-SLAM的Essential Graph（关键图）是什么？它的作用是什么？ Essential Graph：基于位置优化的实时闭环控制。它通过生成树构建，生成树由系统、闭环控制链接和视图内容关联强边缘进行维护。 Essential Graph 生成树“按权重链接“可见性图”的节点（nb映射公共点） 和与基本图的关键帧相关的词袋。 什么时候，是出于什么原因以及在哪些数据上进行ORB-SLAM中的光束调整les ajustements de faisceaux？ Bundle Adjustment（BA）：光束平差法，就是利用非线性最小二乘法来求取相机位姿，三维点坐标。在仅给定相机内部矩阵的条件下，对四周物体进行高精度重建。 Bundle Adjustment 可以将所观测的图像位置和预测的图像位置点进行最小 error 的映射（匹配），由很多非线性函数的平方和表示（error）。因此，最小化 error 由非线性最小二乘法实现。 在闭环过程中，由于哪种算法确定了当前镜头的姿势，我们确定了哪个KeyFrame最接近摄像机所看到的姿势。 Essential graph optimization 基本图优化 Pose graph optimization on the Essential graph to distribute the loop closing error along the graph 对基本图进行位姿图优化，使闭环误差沿图分布 相关文章 什么是ORB？https://www.jianshu.com/p/420f8211d1cb ORB是怎么工作的？https://www.jianshu.com/p/9ee6b2145eaa ORB-SLAM中的ORB特征 https://zhuanlan.zhihu.com/p/61738607 Bag-of-words：词袋算法 ，它是主要用来判断同一个地点是不是被重新访问过，它的算式在实现的原理上可以认为是对每一帧或者叫每一幅图用了很多单词来进行描述。 在实际应用中在这个词袋中使用的单词量会非常大，并且这些词在现实中并没有一个非常明确的物理含义；词袋方案现在主流所采取的方案之一，它做得最好的一方案叫 DBOW2，也是一个开源的方案。 Bundle Adjustment（BA）：光束平差法，就是利用非线性最小二乘法来求取相机位姿，三维点坐标。在仅给定相机内部矩阵的条件下，对四周物体进行高精度重建。 Bundle Adjustment 可以将所观测的图像位置和预测的图像位置点进行最小 error 的映射（匹配），由很多非线性函数的平方和表示（error）。因此，最小化 error 由非线性最小二乘法实现。 Essential Graph：基于位置优化的实时闭环控制。它通过生成树构建，生成树由系统、闭环控制链接和视图内容关联强边缘进行维护。 关于SLAM学习 https://github.com/GeekLiB/Lee-SLAM-source 重要概念：https://blog.csdn.net/fang_liu_yang/article/details/53488765 原文翻译1：https://blog.csdn.net/u011344545/article/details/78836717#commentBox 原文翻译2：https://blog.csdn.net/u012525173/article/details/70332125 项目源码：https://github.com/raulmur/ORB_SLAM ORB_SLAM PATH_TO_VOCABULARY：是一种树型数据结构模型，ORB-SLAM里面主要用来做回访(loop-closure)检 测，对于不同数据集严格来说需要离线单独处理生成，但一般成像条件都差不多所以对于不同图像数据集可以使用相同的词汇数据文件（相当于一个数据库文件，方 便快速保存和查询视觉特征信息）。虽然是TXT文件，打开就是许多数字而已。 http://blog.leanote.com/post/gaunthan/ORB-SLAM-A-Versatile-and-Accurate-Monocular-SLAM-System-2 https://blog.csdn.net/fuxingyin/article/details/53511439","categories":[],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://xiaotong1996.github.io/tags/计算机图形学/"},{"name":"SLAM","slug":"SLAM","permalink":"https://xiaotong1996.github.io/tags/SLAM/"}]},{"title":"ORB-SLAM学习","slug":"ORB-SLAM学学习","date":"2019-11-06T21:43:53.000Z","updated":"2019-11-06T22:01:30.748Z","comments":true,"path":"2019/11/06/ORB-SLAM学学习/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/ORB-SLAM学学习/","excerpt":"","text":"ORB-SLAM编译环境win10+CMake+Visual Studio2017 使用vcpkg下载Eigen3，OpenCV，Pangolin包 下载ORB-SLAM.zip，解压，并用cmake编译 运行ORB-SLAM 下载数据集 在windows命令行执行.\\mono_euroc 摄像机校准每个摄像机有一下投影参数： longueurs focales焦距（fx，fy）（单位：像素pixels） centre optique (cx,cy) paramètres de distorsions radiale 辐射失真参数（k1,k2,[k3]) paramètres de distorsions tangentielle 切向失真参数（p1,p2) 用于校准照相机 校准需要比较已知3D点坐标（(les points de la mire : le damier qui vous est fourni，视点，棋盘坐标）和一系列由此棋盘得到的照片上对应的点 步骤： 解压缩OpenCV_Calibration文件夹，cmake编译 使用棋盘来校准，此棋盘格的横向包含8个内部角（双曲线点），纵向包含6个角（如果需要，反之亦然）。 每个棋盘格盒宽30毫米。 运行calibration程序，不加任何参数，来获得参考文件/用help（）也行 然后，使用计划要在工作空间中散布的至少10张照片来校准相机。 在“良好”校准期间，您的重新投影误差应小于0.5像素。 如果不是这种情况，请重复校准。 通过calibration程序，您可以将相机矩阵（包含相机的固有参数（以像素为单位的焦距（fx，fy）和主要点（cx，cy））保存为.yml或.yaml类型的文件。 问答： 为什么对同样的数据执行ORB-SLAM从来不会得到同样的结果？ 随机数和多线程 KeyFrames的作用是什么？包含了什么？ Camera parameters Tiw:Camera extrinsics(Pose) [Camera intrinsics] Featurepoints (2D points + descriptors ) 是否与Mappoint相关联（3D点） Bag of Wordsdes features 用于在失去跟踪器的情况下进行重定位和闭环 关键帧Ki (Key Frame) 存贮下列信息：1， 相机的位姿 Tiw， 这是一个刚体转换， 用于转换世界坐标系中的点到相机坐标系。2， 相机的内参， 包括焦距(focal length) 和主点 (principal point)3， 帧中提取的ORB特征， 与一个地图点关联或者不关联， 如果畸变模型提供的话， 这个地图点的坐标是经过矫正没有畸变的。 ORB-SLAM的地图包含KeyFrames和MapPoints。解释在什么条件下： 一个新的KeyFrame会被创建 Spawn new Keyframe if: More than 20 frames have passed and local mapping is idle and current frames tracks at least 50 points and current frame tracks less than 90% point of kref 当超过20帧已经通过且local mapping是闲置状态且当前帧已经追踪到至少50个点且当前帧追踪少于kref中90%的点，则产生新的关键帧 一个KeyFrame会被销毁 Local Keyframes culling 关键帧删减 Discard keyframes in Kc whose 90% points are seen in 3 other keyframes 丢弃掉在其他三个关键帧中90%的点都可见的关键帧 一个新的MapPoint会被创建 New map points creation 生成新的map points Triangulate Ki matched ORBs from connected Keyframes (Kc) in visibility graph 从可见图中相连的关键帧中对应上ORB的点做三角化处理 Match ki unmatched ORBs in kc with epipolar constraint and triangulate them 一个MapPoint会被删除 Recent map points culling 最近map points删减 ~ Prune map points not visible in more than 3 connected keyframes in visibility graph 删除可见图中3个以上相连的关键帧中不可见的map points 此外，KeyFrames和MapPoints是否真的被销毁？ ORB-SLAM的Essential Graph（关键图）是什么？它的作用是什么？ Essential Graph：基于位置优化的实时闭环控制。它通过生成树构建，生成树由系统、闭环控制链接和视图内容关联强边缘进行维护。 Essential Graph 生成树“按权重链接“可见性图”的节点（nb映射公共点） 和与基本图的关键帧相关的词袋。 什么时候，是出于什么原因以及在哪些数据上进行ORB-SLAM中的光束调整les ajustements de faisceaux？ Bundle Adjustment（BA）：光束平差法，就是利用非线性最小二乘法来求取相机位姿，三维点坐标。在仅给定相机内部矩阵的条件下，对四周物体进行高精度重建。 Bundle Adjustment 可以将所观测的图像位置和预测的图像位置点进行最小 error 的映射（匹配），由很多非线性函数的平方和表示（error）。因此，最小化 error 由非线性最小二乘法实现。 在闭环过程中，由于哪种算法确定了当前镜头的姿势，我们确定了哪个KeyFrame最接近摄像机所看到的姿势。 Essential graph optimization 基本图优化 Pose graph optimization on the Essential graph to distribute the loop closing error along the graph 对基本图进行位姿图优化，使闭环误差沿图分布 相关文章 什么是ORB？https://www.jianshu.com/p/420f8211d1cb ORB是怎么工作的？https://www.jianshu.com/p/9ee6b2145eaa ORB-SLAM中的ORB特征 https://zhuanlan.zhihu.com/p/61738607 Bag-of-words：词袋算法 ，它是主要用来判断同一个地点是不是被重新访问过，它的算式在实现的原理上可以认为是对每一帧或者叫每一幅图用了很多单词来进行描述。 在实际应用中在这个词袋中使用的单词量会非常大，并且这些词在现实中并没有一个非常明确的物理含义；词袋方案现在主流所采取的方案之一，它做得最好的一方案叫 DBOW2，也是一个开源的方案。 Bundle Adjustment（BA）：光束平差法，就是利用非线性最小二乘法来求取相机位姿，三维点坐标。在仅给定相机内部矩阵的条件下，对四周物体进行高精度重建。 Bundle Adjustment 可以将所观测的图像位置和预测的图像位置点进行最小 error 的映射（匹配），由很多非线性函数的平方和表示（error）。因此，最小化 error 由非线性最小二乘法实现。 Essential Graph：基于位置优化的实时闭环控制。它通过生成树构建，生成树由系统、闭环控制链接和视图内容关联强边缘进行维护。 关于SLAM学习 https://github.com/GeekLiB/Lee-SLAM-source 重要概念：https://blog.csdn.net/fang_liu_yang/article/details/53488765 原文翻译1：https://blog.csdn.net/u011344545/article/details/78836717#commentBox 原文翻译2：https://blog.csdn.net/u012525173/article/details/70332125 项目源码：https://github.com/raulmur/ORB_SLAM ORB_SLAM PATH_TO_VOCABULARY：是一种树型数据结构模型，ORB-SLAM里面主要用来做回访(loop-closure)检 测，对于不同数据集严格来说需要离线单独处理生成，但一般成像条件都差不多所以对于不同图像数据集可以使用相同的词汇数据文件（相当于一个数据库文件，方 便快速保存和查询视觉特征信息）。虽然是TXT文件，打开就是许多数字而已。 http://blog.leanote.com/post/gaunthan/ORB-SLAM-A-Versatile-and-Accurate-Monocular-SLAM-System-2 https://blog.csdn.net/fuxingyin/article/details/53511439","categories":[],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://xiaotong1996.github.io/tags/计算机图形学/"},{"name":"SLAM","slug":"SLAM","permalink":"https://xiaotong1996.github.io/tags/SLAM/"}]},{"title":"Vision 3D","slug":"Vision-3D","date":"2019-11-06T21:40:40.000Z","updated":"2019-11-06T22:00:53.479Z","comments":true,"path":"2019/11/06/Vision-3D/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/Vision-3D/","excerpt":"","text":"Vision 3D传感器和测量方法 Mesures absolues 深度信息得到物体的位置和转向 体视法 和 摄影测量术 temps de vol 成焦或散焦的形状 结构光：结构光投影和激光三角测量 卷信息 断层摄影术 Mesures relatives 对象表面的[局部]几何形状，但不是其位置 阴影（shading）形状 纹理（textures）形状 3D重建方法 选配 （自上而下） 搜索已知对象类型的出现，并在场景空间中进行替换。 高级原语：预定义的对象 建设 （自下而上） 无需事先使用已知对象即可进行重建 使用低级重建原语，原语的程序集构造一个较高级的实体。 3D重建的视觉部分Vision Active Image + source （图像和源） Laser （激光） Tomographie 断层摄影术 Shape from shading 阴影形状 Vision Passive 利用图像之间的差异 多眼视觉（立体视觉） 运动中的单眼视觉 Shape from Shading 阴影形状 原理1：光度法 a: 恒定且已知的反照率 已知光源 原理2： 扩散照明模型（朗伯型） Lambertien 原理3： 伪尺度照明模型 Shape / Depth from focus / defocus 问题：通过更改传感器的焦距或位置获得的2张或更多图像得到场景的3D估算 Depth from focus (actif) 聚焦深度 离焦深度（passif） Reconstruction stéréo 立体重建 Principe : Triangulation 三角测量 需要校准 Shape from structured light 结构光图形 激光投影：半径→点，平面→线，网格 激光平面 plan laser： 柱面镜或旋转镜 已知方程 校准好的相机 一个或多个模式的投影 模式： 干扰（光相干） 投影 模式编码 两种模式之间只有1位的变化 Range Imaging : Time of Flight 距离成像：飞行时间principe:lidar 激光雷达 在持续时间d的t0处发出一个光脉冲 测量脉冲t0 + Dt（i，j）的反射光的每个像素（i，j）：Dt表示距离 技术 TOF：反射信号的Dt的脉冲测量 相位：在频率f处的连续调制，反射信号的相移测量 Méthodes de reconstruction 重建方法 Méthodes Globales : 处理所有图像。 shape from XXX 立体技术： 关联 / 弹性匹配 应用： 深度图 Méthodes basées sur des primitives : 基于原语的方法： 仅处理从图像中提取的图元。 特别点 Points particuliers 等高线 Contours 地区 Régions 条件重建 Primitives 2D / 3D 原语 Points d’intérêts 特别点 Sommet 顶点 缺点： 相似度低的标准1 ， 可以使用其邻域来描述 优点： 点视差 及时差异 Les contours 等高线 Arête (segment, courbe) 棱边（段，曲线） 优点： 强大的形态学标准 ； 轮廓上的差异 Les régions 地区 Face (facette, carreau) 面 优点：区域邻接图 缺点： 毛点差 差异不明显 Calibration 校准 相机参数的估计 确定空间点经过的变换以获得图像的点 型号： Pin Hole1ou sténopé 场景参考系=》照相机参考系 外在参数 照相机参考系=》图像参考系 内在参数 Calibration : Paramètres intrinsèques 校准：内在参数 Distorsions 扭曲 发生在投影线性模型和与图像相关的点之间 来源： 镜片瑕疵 镜头/矩阵未对准 形式： 在径向变形中&gt;&gt;切向变形 如果考虑到径向和切向变形，（Du，Dv）可能是高度非线性的 考虑到 ： K1拒绝相机模型的参数并破坏模型的线性 独立于模型的失真估计和图像校正 我们将处理校正后的像素（u’，v’）： Paramètres extrinsèques 外部参数 场景标记和相机标记之间的刚性移动 由包含已知3D点的校准图案表示的场景标记 通过记录图像中的特定点来估计瞄准器和摄像机之间的刚性位移 Calibration avec OpenCV Calibration stéréo… Feature points 目的：检测同一对象的其他图像中易于识别的兴趣点（特征点） 点检测： 例子：SIFT：标度空间中的高斯差（DoG）的最小值和最大值 点上的特征映射： 描述符向量之间的欧式距离（通常为32、64或128个分量） 不变性 ： 位移：位置不干预匹配 旋转：特征点沿渐变方向定向 尺度： 使用比例空间（ScaleSpace）可为检测到的特征点提供比例因子 局部不变性： 光照 仿射变换或投影 Descripteurs et Matching 描述符和匹配 Descripteurs 根据检测点的方向在附近的尺度上对邻域中的梯度方向描绘局部直方图 Matching Entre points （点之间）： 描述符之间的欧式距离 在k-d tree中寻找最优点 Entre ensembles de points （点集之间）: 在mmc的意义上进行调整 de l’homographiecorrespondante (si nb pts &gt;= 4 de la matrice essentielle (si nb pts &gt;= 8) 分解为奇异值（SVD） Etude de cas : Recalage / cible pour augmentationTP1 SLAMSLAM定义主要任务： 跟踪：估计摄像机的姿势 特征匹配 Optical Flow 光流 制图：环境重建 三角测量 深度参数化 其他任务 重新定位 （ 失去追踪后 ） 闭环 地图初始化 ： 深度参数化 &amp; 延迟初始化/特定运动 定位： 同义词： 视觉里程表 Visual Odometry 根据…确定姿势 2D / 3D映射：图像点 3D点 =》 透视点（PnP） 3D（或2.5D）/ 3D匹配 ： 深度点↔3D点 =》 ICP：迭代最近点 制图 /映射： 确定环境图 同义词： Reconstruction, Structure fromMotion (SfM) 重构，运动构造（SfM） Mapping Local局部映射： 2D相机：了解两个图像之间的相对姿势 =》三角剖分=》3D点 Cameras2D : 了解相机之间的bases=》三角剖分=》3D点 Camera 3D : carte de profondeur （深度图）⟹points 3D Mapping Global Pose + carte locale ⟹carte globale 姿势+本地地图⟹全球地图 SLAM：架构 Graph-BasedSLAM … Feature-Base vs Direct… Visual SLAM : Méthodes sparses 稀疏的 基于特征 优势： 基本要素加大要素(特征描述的容忍度和光照强度) 通过捆绑调整同时优化姿势和贴图 计算更轻 劣势： 缺少纹理⇒没有points 例子： PTAM ORB-SLAM VisualSLAM : Méthodes denses 密集的 基于像素 优势： 没有特征提取（在处理时间上花费更多） 毛状体，无纹理，或纹理重复(沥青质) 重建密集 劣势： 光度一致性限制了视点/特征匹配之间的基线：对需要大量“基线”的重建精度的影响 对卷帘快门，自动增益和自动曝光敏感，因为它们对图像的影响需要光度学校准（在DSO中执行） 计算较重 例子： DTAM LSD-SLAM DSO Visual SLAM : Autres méthodes 优势： 混合方法（深度图像）+特征点（RGB图像） 重建（非常）密集 劣势： 3D地图尺寸 传感器（Kinect）在大空间中的局限性 例子： RGB-D SLAM Ajustement de faisceaux (Bundle Adjustment) 捆绑调整… ORB-SLAM：功能 所有阶段的ORB点和ORB描述符 跟踪，映射，重定位和闭环。 大型环境中的实时跟踪和映射 可测图:跟踪和地图绘制的唯一关于“可测区域”独立和“全球地图”的地图 Loop closinget relocalisatonen Temps Réel Essential Graph 生成树“按权重链接“可见性图”的节点（nb映射公共点） 和与基本图的关键帧相关的词袋。 基于两个平行假设的评估进行稳健的初始化 平面摄影场景 或用于非平面场景的基本矩阵 用于点映射（3D）和关键帧选择的“适者生存”方法 Suppression des keyframes redondantes 删除冗余的关键帧 删除冗余映射点 ORB-SLAM : Architecture ORB-SLAM：数据 Map Points : pi Position : Xw,i 视角方向 Viewing direction :ni 最佳影像描述符 Best image descriptor :Di Viewing distance range [dmin..dmax]/ Best Descriptor Keyframes Camera parameters Tiw:Camera extrinsics(Pose) [Camera intrinsics] Featurepoints (2D points + descriptors ) 是否与Mappoint相关联（3D点） Bag of Wordsdes features 用于在失去跟踪器的情况下进行重定位和闭环 Organisation des Keyframes 关键帧的组织 图：邻居关键帧图 Graphe : Graphe des Keyframesvoisines Covisibility graph可视图：通过观察到的map points将关键帧链接在一起。 Essential graph 基本图: 关键帧通过它们共同观察到的映射点数链接在一起 Spanning tree 生成树 ORB-SLAM : Tracking 追踪 ORB提取 Tracking OK : Initial pose estimation from previous frame 追踪成功代表成功通过前一帧初始化相机位置预测 Match Mappoints from previous frame 通过比对前一帧的map points Pose optimisation from correspondences 通过对应关系优化pose Tracking Lost: Convert frame to Bow and query Keyframes 追踪丢失，把当前帧转换为bow并查询关键帧 Match map points from Keyframes Loop candidates 通过比对可能构成环路的关键帧和map points If enough inliers: Pose optimisation 如果是正常值，优化pose Track Local Map from Init. Pose Est. &amp; Feature Matches 从初始化位置和匹配特征追踪local map Project local map points into frame 将本地map points映射到frame k1：Keyframes sharing map points with current frame k2: Neighbors of k1 in visibility graph kref ∈ k1: Keyframe sharing most map points with current frame Match map {K1，K2} points with current frame keypoints 上面三步获取map points，比较k1，k2点和当前帧关键点 Pose optimisation 优化姿势 New Keyframe decision 新的关键帧的选择： Spawn new Keyframe if: More than 20 frames have passed and local mapping is idle and current frames tracks at least 50 points and current frame tracks less than 90% point of kref 当超过20帧已经通过且local mapping是闲置状态且当前帧已经追踪到至少50个点且当前帧追踪少于kref中90%的点，则产生新的关键帧 ORB-SLAM : Local Mapping Keyframe insertion Ki 插入关键帧Ki Update visibility graph and spanning tree 更新可见图和生成树 Compute BoW for keyframe 为关键帧计算Bow Recent map points culling 最近map points删减 ~ Prune map points not visible in more than 3 connected keyframes in visibility graph 删除可见图中3个以上相连的关键帧中不可见的map points New map points creation 生成新的map points Triangulate Ki matched ORBs from connected Keyframes (Kc) in visibility graph 从可见图中相连的关键帧中对应上ORB的点做三角化处理 Match ki unmatched ORBs in kc with epipolar constraint and triangulate them Local Bundle Adjustment 本地捆绑包调整 Optimize ki，kc all map points seen in these frames =》all keyframes containing these points 优化ki，kc所有帧中可见map points=》确保所有关键帧都包含这些点 Local Keyframes culling 关键帧删减 Discard keyframes in Kc whose 90% points are seen in 3 other keyframes 丢弃掉在其他三个关键帧中90%的点都可见的关键帧 ORB-SLAM: Loop Closing Loop candidates detection 闭环可能性检测 Query DBoW for loop candidates keyframes withKi(except Kc):{kl} Compute Similarity transformations between Ki and {kl}: Sil=[dx,dy,dz,rx,ry,rz,s]计算相似度转化 Retain loop closure candidate with most inliers in 3D/3D correspondences : Kl Loop fusion 闭环融合 Correct Tiw with Sil and propagate to all neighbors of ki -&gt; Align both sides of the loop 用Sil矫正Tiw并应用与所有临近点 Fuse map points of kl and ki +kc合并点 Update keyframes edges of the loop in the visibility graph 更新可见性图表中循环的关键帧边缘 Essential graph optimization 基本图优化 Pose graph optimization on the Essential graph to distribute the loop closing error along the graph 对基本图进行位姿图优化，使闭环误差沿图分布","categories":[],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"https://xiaotong1996.github.io/tags/计算机图形学/"},{"name":"SLAM","slug":"SLAM","permalink":"https://xiaotong1996.github.io/tags/SLAM/"}]},{"title":"Network Programming（复习）","slug":"Network-Programming（复习）","date":"2019-11-06T21:38:35.000Z","updated":"2019-11-06T21:38:54.569Z","comments":true,"path":"2019/11/06/Network-Programming（复习）/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/Network-Programming（复习）/","excerpt":"","text":"UDP multicastclient/sender 不变，只需要把地D类广播组地址 server/revicer 需要添加结构体，设置socket struct ip_mreq{strtuct in_addr imr_multiaddr;struct in_addr imr_interface;}; struct ip_mreq multicastGroupInfo;multicastGrouInfo.imr_multiaddrs.s_addr=inet_addr(multicastIPAddr);multicastGroupInfo.imr_interface.s_addr=htonl(INADDR_ANY); setsockopt(sock,IPPROTO_IP,IP_ADD_MEMBERSHIP,(void*)&amp;multicastGroupInfo,sizefo(multicastGroupInfo))&lt;0) UDP broadcastclient和server都只需要添加一句int boradcast=1;if(setsockopt(sock,SOL_SOCKET,SO_BROADCAST,&amp;broadcast,sizeof(broadcast)&lt;0){perror();…} ThreadTCP 应用client什么都不变server在listen完后，while(1)中，accept（）后，创建一个thread，在thread中通信，关闭通信 123456789pthread_t threadId ;while(1)&#123;code = pthread_create ( &amp;threadId, 0, thread_handler, ( void * ) &amp;new ) ;if ( code != 0 ) &#123; perror ( &quot;Thread creation&quot; ) ; close ( new ) ; exit ( 1 ) ; &#125; pthread_create ( &amp;threadId, 0, thread_handler, ( void ) &amp;new ) ; threadid是通过应用传递填充的thread id，0/null表示使用一个default 的 thread不加更改main以外定义thread_ha ndler（void)&amp;new 传给thread_handler参数返回0成功 123456789void * thread_handler ( void * threadSock )&#123;int sock = * ( int * ) threadSock ; int retThread ; 。。。 通信recv（），mirror(), send（） pthread_exit ( &amp; retThread ) ;&#125; thread跑完exit就行了 selectclient不变，server bind地址后，初始化一个desctiptor sockets setsocket listen在循环中，修改这个set","categories":[],"tags":[{"name":"Network Programming","slug":"Network-Programming","permalink":"https://xiaotong1996.github.io/tags/Network-Programming/"},{"name":"笔记","slug":"笔记","permalink":"https://xiaotong1996.github.io/tags/笔记/"}]},{"title":"Network Programming（六）","slug":"Network-Programming（六）","date":"2019-11-06T21:35:09.000Z","updated":"2019-11-06T21:36:39.073Z","comments":true,"path":"2019/11/06/Network-Programming（六）/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/Network-Programming（六）/","excerpt":"","text":"Network Programming（六）网络编程进阶 Network services网络服务服务与端口相关联ports分三类： well-known ports (0到1023)是基本服务(系统使用，需要超级用户特权) referenced ports 参考端口(1024至49151)由IANA根据请求实体的申请为特定服务关联(在大多数系统上，普通用户可以使用注册端口)。 Dynamic or private or ephemeral ports 动态或私有或短暂端口(49152至65535)用于其他目的。 与服务相关文件Services databasefile - /etc/services servant 数据结构有set of functions用于连接服务列表其中两个返回一个指向struct的指针，这个struct包含关于service的信息。定义在&lt;netdb.h&gt;struct servent{char s_name;char** s_aliases;int s_port;char s_proto;} s_name:官方服务名称 s_aliases:以NULL结尾的服务替代名称列表 s_port:按网络字节顺序给出的服务端口号 s_proto:与此服务一起使用的协议的名称 获取服务信息（函数）函数一：struct servent getservbyname(const char name,const char* proto)name是服务名，proto是协议名从数据库返回与使用协议原型匹配的服务名称的条目的servents结构的函数。如果protois为NULL，则将匹配任何协议。如有必要，将打开与数据库的连接.定义在 netdb.h 返回指向静态分配的servents结构的指针，如果发生错误或到达文件末尾，则返回NULL。 函数二：struct servent getservbyport(int port,const char proto)port是端口号proto是协议和上一个函数相似，不多加说明 协议文件/etc/protocols 协议数据结构同样定义在netdb.h struct protoent{char* p_name;char** p_aliases;int p_proto;} p_name: 协议的官方名p_aliases: 以NULL结尾的协议其他代替名列表p_proto: 协议号 获取协议信息的函数struct protoent getprotobyname(const char name) name是协议名 struct protoent* getprotobynumber(int proto) proto是相关数字 主机文件 /etc/hosts host数据结构 struct hostent{ char* h_name; char h_aliases; int h_addrtype; int h_length; char h_addr_list; } h_name: host官方名 h_aliases: 代替名 h_addrtype: 地址类型：AF_INET or AF_INET6 h_length: 地址长度 bytes h_addr_list 列表指向主机网络地址的指针数组(按网络字节顺序)，由空指针终止。为了保证向后兼容性，h addr(h addr列表中与主机关联的第一个网络地址)被定义为:# define h_addr h_addr_list[0] 获取主机信息struct hostent gethostbyname(const char name)如果名称是一个IPv4地址，则不执行查找，gethostbyname()只是将名称复制到返回主机结构的h _ name字段中，并将它的结构添加到h _ addr _ list[0]字段中。返回值：hostent structure 出错时，null，h_errno(在netdb.h中定义)变量保存一个错误号。使用herror(char* s)产生相应的错误信息 struct hostent gethostbyaddr(const void addr, socklen_t len,int type)addr : IP地址len：长度type： AF_INET or AF_INET6 (#include &lt;sys/socket.h&gt;) host_address参数是一个指针，指向一个类型取决于地址类型的结构，例如地址类型AF_INET的结构地址(可能是通过调用inet_addr(3))获得的。返回值：hostent structure 出错时，null，出错时，h_errno(在netdb.h中定义)变量保存一个错误号。使用herror(char s)产生相应的错误信息 UDP sockets的multicast多播和broadcast广播怎么发送data给多个接收者？法一：unicast data的copy到每个接收者（没有效率）法二：使用network supportBroadcasting:发送一个datagram所有在到达的子网上的主机都会接受子网中的每台主机都必须通过UDP层处理数据报，以防万一，即使主机不参与应用程序。这也可能会造成过多的处理负载Multicasting：一个message仅发送给主机的子集任何人都可以加入多播组任何人都可以发送给多播组 只有UDP sockets可以广播和多播 两种广播地址：子定向广播地址(example192.168.66.255 for a subnet192.168.66.0/24）受限的广播地址255.255.255.255 不应该由路由器转发 为了使用广播，必须更改套接字的选项 12int breadcastPermission=1;setsockopt(sock,SOL_SOCKET,SO_BROADCAST,(void*)&amp;broadcastPermission,sizeof(broadcastPermission)); SO_BROADCAST很重要 对于多播，使用D类地址：224.0.0.0 to 239.255.255.255; IPv4地址的前四位设置为1110 有一些特殊的组播组 - “众所周知的组播组”，由于分配给它们的特殊用途，不应在应用程序中使用： 224.0.0.1是全主机组。–224 . 0 . 0 . 2是全路由器组。–224 . 0 . 0 . 4是全DVMRP路由器，224.0.0.5是全OSPF路由器，224.0.013是全无源互调路由器，等等。–224 . 0 . 0 . 0至224.0.0.255保留用于本地目的(作为管理和维护任务)–239 . 0 . 0 . 0至239.255.255.255也保留用于管理目的。 为了发送一个多播UDP数据报： 打开一个UPDsocket，填充D类地址 不需要改变socket options 需要设置TTL（time-to-live），为了限制数据包中继的跳数 setsockopt(sock,IPPROTO_IP,IP_MULTICAST_TTL,(void*)&amp;multicastTTL,sizeof(multicastTTL)) 当TTL为0，packet被丢弃 使用setsockopt( )关闭环回，这样可以避免接收正在发送的数据包 为了接受一个多播UDP数据报：-创建一个SOCK_DGRAM socket()-bind一个多播地址和port 使用setsockopt()加入多播组，设置IP_ADD_MEMBERSHIP 这告诉系统在网络上接收目的地是多播组地址的数据包。 使用ip _ mreq structureto指定多播组地址和要使用的接口(使用0.0.0.0表示任何接口) 使用recvfrom()来接受多播数据报 例子如下 UDP多播设置","categories":[],"tags":[{"name":"Network Programming","slug":"Network-Programming","permalink":"https://xiaotong1996.github.io/tags/Network-Programming/"},{"name":"笔记","slug":"笔记","permalink":"https://xiaotong1996.github.io/tags/笔记/"}]},{"title":"Network Programming（五）","slug":"Network-Programming（五）","date":"2019-11-06T21:33:07.000Z","updated":"2019-11-06T21:34:44.350Z","comments":true,"path":"2019/11/06/Network-Programming（五）/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/Network-Programming（五）/","excerpt":"","text":"Network Programming（五）之前的例子都是TCP的应用，之后这两个例子是关于UDP的 UDPsocket使用模式 实例五写一个client和server，server显示client的端口号和地址，并返回client发送过去的message的镜像（如client发送ALO，server返回OLA） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130客户端# include &lt;sys/socket.h&gt;# include &lt;netdb.h&gt;# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;# include &lt;string.h&gt;# include &lt;unistd.h&gt;# include &lt;arpa/inet.h&gt; //inet_addr# define SERVERPORT 9999# define LOCALHOST &quot;127.0.0.1&quot;# define MYMSGLEN 2048void question ( int sock, char * msg, struct sockaddr_in * addr, struct sockaddr_in * from )&#123; int code, length, ret ; socklen_t len; // Send the length of the string. length = strlen ( msg ) ; // + 1 ; // Send the string of characters. len = sizeof ( struct sockaddr_in ) ; code = sendto ( sock, msg, length, 0, ( struct sockaddr * ) addr, len ) ; if ( code == -1 ) &#123; perror ( &quot;sendto&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; // Wait for the answer. memset ( msg, 0, length ) ; len = sizeof ( * from ) ; code = recvfrom ( sock, ( char * ) msg, length, 0, ( struct sockaddr * ) from, &amp; len ) ; if ( code == -1 ) &#123; perror ( &quot;recvfrom&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; // Empty message!!!! 0 value returned in UDP mode does not mean closing a connection since there is no connection // We release the resource and exit the program anyway if ( code == 0 ) &#123; // Release ressources. code = close ( sock ) ; if ( code == -1 ) &#123; perror ( &quot;close&quot; ) ; &#125; exit ( 1 ) ; &#125; &#125;int main ( int argc, char * argv [ ] )&#123; int item ; socklen_t len; // Ask for the string of characters. char string [ MYMSGLEN ] ; // Create UDP socket and init server address structure. int sock ; sock = socket ( AF_INET, SOCK_DGRAM, 0 ) ; if ( sock == -1 ) &#123; perror ( &quot;socket&quot; ) ; exit ( 1 ) ; &#125; // Initialisation of the sockaddr_in data structure struct sockaddr_in addr ; memset ( &amp; addr, 0, sizeof ( struct sockaddr_in ) ) ; addr . sin_family = AF_INET ; addr . sin_port = htons ( SERVERPORT ) ; addr . sin_addr . s_addr = inet_addr ( LOCALHOST ) ; while ( 1 ) &#123; memset ( string, 0, sizeof( string ) ) ; printf ( &quot;\\n----------------------------------------------------------------------\\n&quot; ) ; printf ( &quot;Please type a message to transfer for processing:&quot; ) ; item = scanf ( &quot;%[^\\n]%*c&quot;, string ) ; //reads a hole line till a new line feed //This is in case of empty message if ( item == 0 ) &#123; scanf(&quot;%*c&quot;); continue; &#125; printf ( &quot;The message being sent is: &apos;%s&apos; \\n&quot;, string ) ; printf( &quot;----------------------------------------------------------------------\\n&quot; ) ; if ( !memcmp ( &quot;quit#&quot;, string, 5 ) ) &#123; printf ( &quot; Client exiting upon user request \\n&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; // Ask the question and wait for the answer. struct sockaddr_in from ; question ( sock, string, &amp; addr, &amp; from ) ; // Display the result. printf ( &quot;\\n----------------------------------------------------------------------\\n&quot; ) ; printf ( &quot;The processed message is received from server %s, with port number: %d \\n&quot; , inet_ntoa( from.sin_addr ), ntohs( from.sin_port ) ) ; printf ( &quot;The message is : %s\\n&quot;, string ) ; printf ( &quot;----------------------------------------------------------------------\\n&quot; ) ; &#125; return ( 0 ) ;&#125; 客户端编程思路：第一步：创建socket，注意：sock = socket ( AF_INET, SOCK_DGRAM, 0 ) ;这时模式是SOCK_DGRAM第二步，bind地址：与TCP相似地址存在sockaddr_in中，记住先把addr各位置0第三步，在while（1）中，不断读入字符串scanf(“%[^\\n]%c”)，这里用到了正则表达式%[^ n]扫描所有内容，直到 \\n，但不扫描 \\n。星号()告诉它丢弃所扫描的任何内容。%c扫描单个字符，在本例中，该字符是%[^\\n]所剩余的\\n。星号指示scanf放弃已扫描的字符。第四步，判断client是否输入”quit#”第五步，调用question（），其中利用sendto向server发送msg，利用recvfrom从server接受。第六步，输出信息 ssize_t sendto(int sockfd,const void buf,size_t len,int flags,const struct sockaddr dest_addr,socklen_t addrlen);用来向另一个socket传送message需要指定目标地址flags：特殊设置，通常是0返回传送的字节数-1 error ssize_t recvfrom(int sockfd,void buf,size_t len,int flags,struct sockaddr src_addr, socklen_t* addrlen);用来从一个socket接受messagesrc_addr调用之后被填充flags：特殊设置，通常是0返回接受的字节数-1 error 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141服务器# include &lt;sys/socket.h&gt;# include &lt;netdb.h&gt;# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;# include &lt;string.h&gt;# include &lt;unistd.h&gt;# include &lt;arpa/inet.h&gt; //inet_addr# define SERVERPORT 9999# define LOCALHOST &quot;127.0.0.1&quot;# define MYMSGLEN 2048void mirror ( char * msg )&#123; int i ; int length ; char car ; length = strlen ( msg ) ; for ( i = 0 ; i &lt; ( length / 2 ) ; i ++ ) &#123; car = msg [ i ] ; msg [ i ] = msg [ length - i - 1 ] ; msg [ length - i - 1 ] = car ; &#125;&#125;void answer_client ( int sock )&#123; struct sockaddr_in from ; socklen_t len; // Receive the length of the string. int code, length ; char string [ MYMSGLEN ]; // Receive the string of characters. while ( 1 ) &#123; memset ( string, 0, MYMSGLEN ); len = sizeof ( from ) ; length = recvfrom ( sock, string, MYMSGLEN, 0,( struct sockaddr * ) &amp; from, &amp; len ) ; if ( length == -1 ) &#123; perror ( &quot;recvfrom&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; printf ( &quot;Request received from: %s, with port number: %d \\n&quot; , inet_ntoa( from.sin_addr ), ntohs( from.sin_port ) ) ; if ( length == 0 ) &#123; printf(&quot;Ignoring empty message received \\n&quot;); continue ; &#125; printf ( &quot;Received message: %s\\n&quot;, string ) ; // Check the string of characters. mirror ( string ) ; // Prepare the answer // Return the answer. len = sizeof ( from ) ; code = sendto ( sock, string, length, 0, ( struct sockaddr * ) &amp; from, len ) ; if ( code == -1 ) &#123; perror ( &quot;sendto&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; // Release ressources. &#125; &#125;int naming ( )&#123; // Socket creation. int sock ; sock = socket ( AF_INET, SOCK_DGRAM, 0 ) ; if ( sock == -1 ) &#123; perror ( &quot;socket&quot; ) ; exit ( 1 ) ; &#125; // Reuse the same port (useful when developing...). int code, enable = 1; code = setsockopt ( sock, SOL_SOCKET, SO_REUSEADDR, &amp; enable, sizeof ( int ) ) ; if (code == -1 ) &#123; perror ( &quot;setsockopt&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; // Initialisation of the sockaddr_in data structure. struct sockaddr_in addr ; memset ( &amp; addr, 0, sizeof ( struct sockaddr_in ) ) ; addr . sin_family = AF_INET ; addr . sin_port = htons ( SERVERPORT ) ; addr . sin_addr . s_addr = inet_addr ( LOCALHOST ) ; // Name the socket. code = bind ( sock, ( struct sockaddr * ) &amp; addr, sizeof ( struct sockaddr_in ) ) ; if ( code == -1 ) &#123; perror ( &quot;bind&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; // Return the socket ID. return ( sock ) ;&#125;int main ( int argc, char * argv [ ] )&#123; // Name the socket. int sock ; sock = naming ( ) ; // Answering incoming requests. printf ( &quot;UDP Mirror server ready to process client requests \\n&quot; ) ; answer_client ( sock ) ; // This point in the program will never be reached. return ( 0 ) ;&#125; 服务器编程思路：第一步：编写服务器处理程序，这里就是mirror（）第二步：通过naming创建socket，设置和bind地址，这一步可以和client一样写在main中第三步：调用answer_client()，在while（1）中，接受client的msg，处理，返回结果。","categories":[],"tags":[{"name":"Network Programming","slug":"Network-Programming","permalink":"https://xiaotong1996.github.io/tags/Network-Programming/"},{"name":"笔记","slug":"笔记","permalink":"https://xiaotong1996.github.io/tags/笔记/"}]},{"title":"Network Programming（四）","slug":"Network-Programming（四）","date":"2019-11-06T21:32:11.000Z","updated":"2019-11-06T21:33:41.431Z","comments":true,"path":"2019/11/06/Network-Programming（四）/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/Network-Programming（四）/","excerpt":"","text":"Network Programming（四）Struct struct sockaddr{sa_family_t sa_family;char sa_data[14];} 对于IPv4 struct sockaddr_in{sa_family_t sin_family;in_port_t sin_port;struct in_addr sin_addr;};这个就是我们常用来填充的结构体 struct in_addr{uint32_t s_addr;};s_addr通常用到htonl（INADDR_ANY);htonl就是把本机字节顺序转化为网络字节顺序htonl 是针对32位，4个字节而言htons 是针对16位，2个字节而言htonl()–”Host to Network Long”ntohl()–”Network to Host Long”htons()–”Host to Network Short”ntohs()–”Network to Host Short 实例三写一个服务器用来接受多个客户端的消息，并判断这个消息是否是回文，返回结果。写一个客户端，用来发送消息，用户输入“quit#”退出连接。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145客户端# include &lt;sys/socket.h&gt;# include &lt;arpa/inet.h&gt;# include &lt;netdb.h&gt;# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;# include &lt;string.h&gt;# include &lt;unistd.h&gt;# define SERVERPORT 8888# define LOCALHOST &quot;127.0.0.1&quot;# define MYMSGLEN 2048int question ( int sock, char * string )&#123; int code, length, ret ; // Send the length of the string. length = strlen ( string ) + 1 ; // Send the string of characters. code = send ( sock, string, length, 0 ) ; if ( code == -1 ) &#123; perror ( &quot;send&quot; ) ; exit ( 1 ) ; &#125; printf ( &quot;Message sent to server, waiting for the answer ..... \\n &quot; ) ; // Wait for the answer. code = recv ( sock, &amp; ret, sizeof ( int ), 0 ) ; if ( code == -1 ) &#123; perror ( &quot;recv&quot; ) ; exit ( 1 ) ; &#125; //ret返回服务器判断结果 return ret ;&#125;int connecting ( )&#123; // Socket creation.第一步，创建socket int sock ; sock = socket ( AF_INET, SOCK_STREAM, 0 ) ;//TCP直连 if ( sock == -1 ) &#123; perror ( &quot;socket&quot; ) ; exit ( 1 ) ; &#125; // Initialisation of the sockaddr_in data structure struct sockaddr_in addr ; socklen_t len ; struct sockaddr_in newAddr ; struct sockaddr_in peerAddr ; //在初始化地址时，最好先把地址各位归0 memset ( &amp; addr, 0, sizeof ( struct sockaddr_in ) ) ; addr . sin_family = AF_INET ; //SERVERPORT 8888 //之所以需要这些函数是因为计算机数据表示存在两种字节顺序：网络字节顺序NBO(Network Byte Order)与主机字节顺序HBO(Host Byte Order) //htons()--&quot;Host to Network Short&quot; addr . sin_port = htons(SERVERPORT) ; //LOCALHOST &quot;127.0.0.1&quot; //in_addr_t inet_addr(const char* strptr);//将点分十进制变成IP地址，-1 failure，不能用于广播（255.255.255.2555） addr . sin_addr . s_addr = inet_addr(LOCALHOST) ; // Name the socket. int code ; code = connect ( sock, ( struct sockaddr * ) &amp; addr, sizeof ( struct sockaddr_in ) ) ; if ( code == -1 ) &#123; perror ( &quot;connect&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; len = sizeof ( struct sockaddr_in ) ; //获取sock绑定的本地地址 code = getsockname ( sock, ( struct sockaddr * ) &amp; newAddr, &amp; len ) ; if ( code == -1 ) &#123; perror ( &quot;getsockname&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; len = sizeof ( struct sockaddr_in ) ; //在TCP的服务器端accept成功后，通过getpeername()函数来获取当前连接的客户端的IP地址和端口号。 code = getpeername ( sock, ( struct sockaddr * ) &amp; peerAddr, &amp; len ) ; if ( code == -1 ) &#123; perror ( &quot;getpeername&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; //char* inet_ntoa(struct in_addr invader);//将IP地址转换为ASCII点十进制符号 printf ( &quot; The local address bound to the current socket --&gt; %s:%d \\n&quot; , inet_ntoa ( newAddr.sin_addr ), ntohs ( newAddr.sin_port ) ) ; printf ( &quot; The peer address bound to the peer socket --&gt; %s:%d \\n&quot; , inet_ntoa ( peerAddr.sin_addr ), ntohs ( peerAddr.sin_port ) ) ; // Return the socket ID. return sock ;&#125;int main ( int argc, char * argv [ ] )&#123; // Ask for the string of characters. char string [ MYMSGLEN ]; // Connect to the server. int sock ; sock = connecting ( ) ; //利用connecting（）实现socket创建，connect // Ask the question and wait for the answer. int ret ; while ( 1 ) &#123; //每次用到字符串前，先初始化为0 memset ( string, 0, sizeof( string ) ); printf ( &quot;Type a string to check: &quot; ) ; scanf ( &quot;%s&quot;, string ) ; //memcmp若两个字符串完全相同返回0，socket关闭 if ( !memcmp ( &quot;quit#&quot;, string, 5 ) ) &#123; printf ( &quot; Client exiting upon user request \\n&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; //在question函数中实现与服务器间的通信send，recv ret = question ( sock, string ) ; // Display the result. if (ret == 1) printf ( &quot;Reply received: &apos;%s&apos; is a palindrom.\\n&quot;, string ) ; else printf ( &quot;Reply received: &apos;%s&apos; is not a alindrom.\\n&quot;, string ); &#125; return ( 0 ) ;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192服务器# include &lt;sys/socket.h&gt;# include &lt;arpa/inet.h&gt;# include &lt;netdb.h&gt;# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;# include &lt;string.h&gt;# include &lt;unistd.h&gt;# define SERVERPORT 8888# define LOCALHOST &quot;127.0.0.1&quot;# define MYMSGLEN 2048//功能函数，用来判断是否是回文int palindrom ( char * s )&#123; char * t = s + strlen ( s ) - 1 ; while ( * s == * t ) s ++, t -- ; return s &gt;= t ;&#125;//在无限循环中实现客户端数据的接受recv，处理palindrom和返回结果sendint answer_client ( int sock ) &#123; // Receive the length of the string. int code, length ; char string [ MYMSGLEN ]; while ( 1 ) &#123; // Receive the string of characters. printf ( &quot;Waiting for a string to process....\\n&quot; ) ; memset ( string, 0, sizeof( string ) ); length = recv ( sock, string, sizeof ( string ), 0 ) ; if ( length == -1 ) &#123; perror ( &quot;recv&quot; ) ; code = close ( sock ) ; if ( code == -1 ) perror ( &quot;close&quot; ) ; return ( -1 ) ; &#125; if ( length == 0 ) &#123; // Connection closed by remote peer, release ressources. printf ( &quot;Connection closed by remote peer ....\\n&quot; ) ; code = close ( sock ) ; if ( code == -1 ) &#123; perror ( &quot;close&quot; ) ; return ( -1 ) ; &#125; return ( 0 ) ; &#125; printf ( &quot;Going to process the received string &apos;%s&apos;\\n&quot;, string ) ; // Check the string of characters. int ret ; ret = palindrom ( string ) ; // Return the answer. printf ( &quot;Processing done, sending back the answer\\n&quot; ) ; code = send ( sock, &amp; ret, sizeof ( int ), 0 ) ; if ( code == -1 ) &#123; perror ( &quot;send&quot; ) ; close ( sock ) ; return ( -1 ) ; &#125; &#125;&#125;//socket创建+设置+bind地址int naming ( )&#123; // Socket creation. int sock ; //AF_INET：IPv4 protocols。定义在&lt;sys/socket.h&gt;中， //SOCK_STREAM: connected communication withend to end control flow sock = socket ( AF_INET, SOCK_STREAM, 0 ) ; if ( sock == -1 ) &#123; perror ( &quot;socket&quot; ) ; exit ( 1 ) ; &#125; // Reuse the same port (useful when developing...). int code, enable = 1; //SO_REUSEADDR：Allows other sockets to bind() to this port code = setsockopt ( sock, SOL_SOCKET, SO_REUSEADDR, &amp; enable, sizeof ( int ) ) ; if (code == -1 ) &#123; perror ( &quot;setsockopt&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; code = setsockopt ( sock, SOL_SOCKET, SO_REUSEPORT, &amp; enable, sizeof ( int ) ) ; if (code == -1 ) &#123; perror ( &quot;setsockopt&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; // Initialisation of the sockaddr_in data structure. struct sockaddr_in addr ; memset ( &amp; addr, 0, sizeof ( struct sockaddr_in ) ) ; addr . sin_family = AF_INET ; addr . sin_port = htons(SERVERPORT) ; addr . sin_addr . s_addr = inet_addr(LOCALHOST) ; // Name the socket. code = bind ( sock, ( struct sockaddr * ) &amp; addr, sizeof ( struct sockaddr_in ) ) ; if ( code == -1 ) &#123; perror ( &quot;bind&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; // Return the socket ID. return sock ;&#125;int main ( int argc, char * argv [ ] )&#123; // Name the socket. int sock ; sock = naming ( ) ; // Set up listening on the port. int code ; //backlog为0时在linux上表明允许不受限制的连接数，这是一个缺陷，因为它可能会导致SYN Flooding(拒绝服务型攻击) code = listen ( sock, 0 ) ; if ( code == -1 ) &#123; perror ( &quot;listen&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; // Wait for incoming connections and deal with the clients. int new ; socklen_t len ; struct sockaddr_in addr ; struct sockaddr_in newAddr ; struct sockaddr_in peerAddr ; for ( ; ; ) &#123; printf ( &quot;Server waiting for a new connection \\n&quot; ) ; len = sizeof ( struct sockaddr_in ) ; //获取到用来与客户端通信的socket new = accept ( sock, ( struct sockaddr * ) &amp; addr, &amp; len ) ; if ( new == -1 ) &#123; perror ( &quot;accept&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; printf ( &quot; A new connection from --&gt; %s:%d \\n&quot; ,inet_ntoa ( addr.sin_addr ), ntohs ( addr.sin_port ) ) ; len = sizeof ( struct sockaddr_in ) ; code = getsockname ( new, ( struct sockaddr * ) &amp; newAddr, &amp; len ) ; if ( code == -1 ) &#123; perror ( &quot;getsockname&quot; ) ; close ( sock ) ; close ( new ) ; exit ( 1 ) ; &#125; len = sizeof ( struct sockaddr_in ) ; code = getpeername ( new, ( struct sockaddr * ) &amp; peerAddr, &amp; len ) ; if ( code == -1 ) &#123; perror ( &quot;getpeername&quot; ) ; close ( sock ) ; close ( new ) ; exit ( 1 ) ; &#125; printf ( &quot; The local address bound to the new socket --&gt; %s:%d \\n&quot; , inet_ntoa ( newAddr.sin_addr ), ntohs ( newAddr.sin_port ) ) ; printf ( &quot; The peer address bound to the new socket --&gt; %s:%d \\n&quot; , inet_ntoa ( peerAddr.sin_addr ), ntohs ( peerAddr.sin_port ) ) ; //以上打印连接信息 //以下调用answer_client()与client通信 if ( answer_client ( new ) == ( -1 ) ) &#123; close ( sock ) ; exit ( 0 ) ; &#125; &#125; // This point in the program will never be reached. return ( 0 ) ;&#125; 总结：客户端编程思路：写2个子函数：connecting（）负责socket创建，connectquestioning（）通过参数传入socket和要询问的信息，负责socket的send和recv在main（）中循环外使用connecting（）建立连接，循环内每次先判断是否满足断开连接要求，在调用questioning（）。注意：地址转换和网络字节顺序转换函数的使用。 服务器端编程思路：写3个子函数：palindrom（）用来处理收到的信息，判断是否是回文，用在answerclient中int naming ( )负责socket创建+设置+bind地址，返回socketint answer_client ( int sock ) 在无限循环中实现客户端数据的接受recv，处理palindrom和返回结果send。这里的循环会在客户端断开连接后跳出，是为了让server能处理多条client的消息。在main（）中先调用naming（）设置好服务器端socket，并开启监听listen（）在无线循环中获取与客户端通信的socketaccept（），打印出各类连接信息，调用answer_client实现通信。这里的循环是为了确保服务器一直运行能与多个客户端相连。 获取socket信息 int getsockname(int sockfd,struct sockaddr addr,socklen_t addrlen);通过引用传递，获取sockfd绑定的地址。0,success。-1 error int getpeername(int sockfd,struct sockaddr addr,socklen_t addrlen);通过引用传递，获取sockfd对端的地址。0,success。-1 error 实例四在实例三的基础上应用struct保存信息，计算信息的价值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167# include &lt;sys/socket.h&gt;# include &lt;arpa/inet.h&gt;# include &lt;netdb.h&gt;# include &lt;stdio.h&gt;# include &lt;stdlib.h&gt;# include &lt;string.h&gt;# include &lt;unistd.h&gt;# define SERVERPORT 8888# define LOCALHOST &quot;127.0.0.1&quot;# define MYMSGLEN 2048typedef struct &#123; uint16_t ret ; uint16_t msgLen ; uint32_t cost ; char buff[ MYMSGLEN - 8 ] ; &#125; messageCost; void question ( int sock, messageCost * msg )&#123; int code, length, ret ; // Send the length of the string. length = strlen ( msg-&gt;buff ) ; // + 1 ; // Send the string of characters. code = send ( sock, msg-&gt;buff, length, 0 ) ; if ( code == -1 ) &#123; perror ( &quot;send&quot; ) ; exit ( 1 ) ; &#125; printf ( &quot;Message sent to server, waiting for the answer ..... \\n &quot; ) ; // Wait for the answer. code = recv ( sock, ( char * ) msg, sizeof ( messageCost ), 0 ) ; if ( code == -1 ) &#123; perror ( &quot;recv&quot; ) ; exit ( 1 ) ; &#125; // Release ressources. XXX To remove //code = close ( sock ) ; //if ( code == -1 ) &#123; // perror ( &quot;close&quot; ) ; // exit ( 1 ) ; //&#125; &#125;int connecting ( )&#123; // Socket creation. int sock ; sock = socket ( AF_INET, SOCK_STREAM, 0 ) ; if ( sock == -1 ) &#123; perror ( &quot;socket&quot; ) ; exit ( 1 ) ; &#125; // Initialisation of the sockaddr_in data structure struct sockaddr_in addr ; socklen_t len ; struct sockaddr_in newAddr ; struct sockaddr_in peerAddr ; memset ( &amp; addr, 0, sizeof ( struct sockaddr_in ) ) ; addr . sin_family = AF_INET ; addr . sin_port = htons ( SERVERPORT ) ; addr . sin_addr . s_addr = inet_addr ( LOCALHOST ) ; // Name the socket. int code ; code = connect ( sock, ( struct sockaddr * ) &amp; addr, sizeof ( struct sockaddr_in ) ) ; if ( code == -1 ) &#123; perror ( &quot;connect&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; len = sizeof ( struct sockaddr_in ) ; code = getsockname ( sock, ( struct sockaddr * ) &amp; newAddr, &amp; len ) ; if ( code == -1 ) &#123; perror ( &quot;getsockname&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; len = sizeof ( struct sockaddr_in ) ; code = getpeername ( sock, ( struct sockaddr * ) &amp; peerAddr, &amp; len ) ; if ( code == -1 ) &#123; perror ( &quot;getpeername&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; printf ( &quot; The local address bound to the current socket --&gt; %s:%d \\n&quot; , inet_ntoa ( newAddr.sin_addr ), ntohs ( newAddr.sin_port ) ) ; printf ( &quot; The peer address bound to the peer socket --&gt; %s:%d \\n&quot; , inet_ntoa ( peerAddr.sin_addr ), ntohs ( peerAddr.sin_port ) ) ; // Return the socket ID. return ( sock ) ;&#125;int main ( int argc, char * argv [ ] )&#123; // Ask for the string of characters. char string [ MYMSGLEN ] ; messageCost *msg = (messageCost *) string ; // Connect to the server. int sock ; sock = connecting ( ) ; while ( 1 ) &#123; memset ( string, 0, sizeof( string ) ) ; //printf ( &quot;String to check: &quot; ) ; //scanf ( &quot;%s&quot;, msg-&gt;buff ) ; printf ( &quot;\\n----------------------------------------------------------------------\\n&quot; ) ; printf ( &quot;Please type a message to transfer for processing:&quot; ) ; scanf ( &quot;%[^\\n]%*c&quot;, msg-&gt;buff ) ; //reads a hole line till a new line feed printf ( &quot;The message being sent is: &apos;%s&apos; \\n&quot;, msg-&gt;buff ) ; printf( &quot;----------------------------------------------------------------------\\n&quot; ) ; if ( !memcmp ( &quot;quit#&quot;, string, 5 ) ) &#123; printf ( &quot; Client exiting upon user request \\n&quot; ) ; close ( sock ) ; exit ( 1 ) ; &#125; // Ask the question and wait for the answer. question ( sock, msg ) ; // Process the answer msg-&gt;cost = ntohl ( msg-&gt;cost ) ; msg-&gt;msgLen = ntohs ( msg-&gt;msgLen ) ; msg-&gt;ret = ntohs ( msg-&gt;ret ); // Display the result. printf ( &quot;\\n----------------------------------------------------------------------\\n&quot; ) ; if ( msg-&gt;ret == 1 ) printf ( &quot;&apos;%s&apos; is a palindrom.\\n&quot;, msg-&gt;buff ) ; else printf ( &quot;&apos;%s&apos; is not a palindrom.\\n&quot;, msg-&gt;buff ); printf ( &quot;The processed message length is: %d, with a cost of: %.2f Euros\\n&quot;, msg-&gt;msgLen, ( ( float ) msg-&gt;cost / 100 ) ) ; printf ( &quot;----------------------------------------------------------------------\\n&quot; ) ; &#125; return ( 0 ) ;&#125; 123456789typedef struct &#123; uint16_t ret ; uint16_t msgLen ; uint32_t cost ; char buff[ MYMSGLEN - 8 ] ; &#125; messageCost; char string [ MYMSGLEN ] ;messageCost *msg = (messageCost *) string ; 注意这里struct的用法，将字符串强制装换为messageCost，避免了使用malloc（）和free（），msg和string指向同一块地址的起始位置。其他与实例三相似，不加赘述。","categories":[],"tags":[{"name":"Network Programming","slug":"Network-Programming","permalink":"https://xiaotong1996.github.io/tags/Network-Programming/"},{"name":"笔记","slug":"笔记","permalink":"https://xiaotong1996.github.io/tags/笔记/"}]},{"title":"Network Programming（三）","slug":"Network-Programming（三）","date":"2019-11-06T21:30:14.000Z","updated":"2019-11-06T21:33:36.316Z","comments":true,"path":"2019/11/06/Network-Programming（三）/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/Network-Programming（三）/","excerpt":"","text":"Network Programming（三） 实例 一Application client/serveur TCPA和B通信，A向B发送message，B收到后，将这个msg在print出来A是客户端，B是serveur 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101程序A#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#define MYMSGLEN 2000int main(int argc,char* argv[])&#123; int sock; struct sockaddr_in server; char message[MYMSGLEN],server_reply[MYMSGLEN]; sock=socket(AF_INET,SOCK_STREAM,0); /*int socket(int domain,int type,int protocol); * 创建一个通信endpoint，返回一个描述符（descriptor） * 创建成功，一个对应新的socket的文件描述符（file descriptor） * 错误，-1 * * domain描述ptotocol family。这些families定义在&lt;sys/socket.h&gt; * l例如：AF_INET：IPv4协议 * * type指定服务类型：SOCK_StREAM：点对点控制流通信 * SOCK_DGRAM：未连接的通信 * SOCK_RAW：直接连间到协议（需要超级用户权限） * * protocol描述socket使用哪种协议，通常只有一种协议来支持socket类型，对应给协议簇 * 0：default */ if(sock==-1) &#123; printf(&quot;Could not create socket\\n&quot;); return(-1); &#125; printf(&quot;socket created\\n&quot;);/*int connect(int sockfd,const struct sockaddr* addr,socklen_t addrlen);*服务器通过connect和server建立连接*将client的socket-&gt;sockfd和server的地址-&gt;addr相关联。**sockfd:用于连接的socket*addr:被动参与者的地址（server的地址）*addrlen:size of addr**0,成功连接，否则-1*/ server.sin_addr.s_addr=inet_addr(&quot;127.0.0.1&quot;); server.sin_family=AF_INET; server.sin_port=htons(8888); int res; if((res=connect(sock,(struct sockaddr*)&amp;server,sizeof(server)))&lt;0) &#123; perror(&quot;Connect failed error\\n&quot;); close(sock); return -1; &#125; printf(&quot;Returned value,%d\\n&quot;,res); printf(&quot;connection established, waiting to be accepted ......&quot;); while(1) &#123; //void* memset(void* ptr,int value,size_t num); //将ptr指的内存区域的前num个字节值都设置为value，然后返回指向ptr的指针 memset(message,0,MYMSGLEN); printf(&quot;\\nPlease type a message to transfer for processing:&quot;); scanf(&quot;%s&quot;,message); /*ssize_t send(int sockfd,const void *buf,size_t len,int flags) * 将一个message传到另一个socket * flags，特殊选项，通常都是0 * 成功，返回传送的字节数 * 失败 -1 */ if(send(sock,message,strlen(message),0)&lt;0) &#123; printf(&quot;send failed\\n&quot;); close(sock); return -1; &#125; memset(server_reply,0,MYMSGLEN); /*ssize_t recv(int sockfd,void* buf,size_t len,int flags); * 和send差不多 */ if(recv(sock,server_reply,MYMSGLEN,0)&lt;0) &#123; printf(&quot;recv failed\\n&quot;); close(sock); return -1; &#125; printf(&quot;Server reply:%s&quot;,server_reply); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135程序B#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#define MYMSGLEN 2000int main(int argc,char** argv)&#123; int socket_desc,client_sock; int socket_size,read_size; struct sockaddr_in server,client; char client_message[MYMSGLEN]; socket_desc=socket(AF_INET,SOCK_STREAM,0); if(socket_desc==-1) &#123; perror(&quot;Could not create socket&quot;); return -1; &#125; printf(&quot;Socket created\\n&quot;); /*socket options * int setsockopt(int socket,int level,int option_name,const void* option_value,socklen_toption_len); * sock：将要被设置或者获取选项的套接字。 * level：选项所在的协议层。 * optname：需要访问的选项名。 * optval：对于getsockopt()，指向返回选项值的缓冲。对于setsockopt()，指向包含新选项值的缓冲。 * optlen：对于getsockopt()，作为入口参数时，选项值的最大长度。作为出口参数时，选项值的实际长度。对于setsockopt()，现选项的长度。 * level指定控制套接字的层次.可以取三种值: * 1)SOL_SOCKET:通用套接字选项. * 2)IPPROTO_IP:IP选项. * 3)IPPROTO_TCP:TCP选项. * optname指定控制的方式(选项的名称),我们下面详细解释 * SO_REUSERADDR 允许重用本地地址和端口 int */ int code,enable=1; code = setsockopt(socket_desc,SOL_SOCKET,SO_REUSEADDR,&amp;enable,sizeof(int)); if(code==-1)&#123; perror(&quot;setsockopr&quot;); return 1; &#125; server.sin_family=AF_INET; server.sin_addr.s_addr=INADDR_ANY; server.sin_port=htons(8888);/*当一个socket创建后，我们需要将一个本地地址绑定到他 * TCP/IP协议需要一个IP地址和一个端口号对应每个端点地址 * * int bind(int sock,struct sockaddr* addr,socklen_t len) * sock:socket descriptor * addr:用来指定的地址 * len:指定addr数据结构的size * 返回0,success * 返回-1,error * * addr是一个整体的数据类型，根据address family由不同 * 对于IPv4： * struct sockaddr_in&#123; * sa_family_t sin_family; address family:AF_INET * in_port_t sin_port; port * struct in_addr sin_addr; internet address * &#125; * * struct in_addr&#123; * unit32_t s_addr; * &#125;; * */ if(bind(socket_desc,(struct sockaddr*)&amp;server,sizeof(server))&lt;0) &#123; perror(&quot;bind failed. Error&quot;); close(socket_desc); return -1; &#125; printf(&quot;bind done\\n&quot;); /*int listen(int sockfd,int backlog) * sockfd:整数，是一个文件描述符指向类型为SOCK_STREAM的socket * backlog：整数，主动参与者的数量 * listening 0 * error -1 */ code=listen(socket_desc,2); if(code==-1)&#123; perror(&quot;listen&quot;); exit; &#125; printf(&quot;Waiting for incoming connections...\\n&quot;); socket_size=sizeof(struct sockaddr_in); /* int accept(int sockfd,struct sockaddr* addr,socklent_t* addrlen) * sockfd:整数，正在被监听的socket * addr：struct sockaddr，主动参与者的地址 */ client_sock=accept(socket_desc,(struct sockaddr*)&amp;client,(socklen_t*)&amp;socket_size); if(client_sock&lt;0) &#123; close(socket_desc); perror(&quot;accept failed&quot;); return -1; &#125; printf(&quot;Connection accepted\\n&quot;); while((read_size=recv(client_sock,client_message,MYMSGLEN,0))&gt;0) &#123; client_message[read_size]=&apos;\\0&apos;; printf(&quot;MSG received: %s,size of the message received %d\\n&quot;,client_message,read_size); write(client_sock,client_message,read_size); &#125; if(read_size==0) &#123; printf(&quot;client disconnected\\n&quot;); fflush(stdout); &#125; else if(read_size==-1) &#123; printf(&quot;recv failed\\n&quot;); &#125; close(socket_desc); close(client_sock); return 0;&#125; 客户端编程思路： 创建socket：int socket(int 协议簇,int 服务类型,int 协议 ), 返回对应该socket的文件描述符，失败，返回-1 建立连接：int connect(int 用于连接的socket ,struct sockaddr* 服务器的地址结构, socklen_t addr的大小)，返回0,成功连接，否则-1 在循环中本地通过scanf输入msg，再发送msg：ssize_t send(int 已经连接的socket和connect中的一样,const void* 待发送的信息这里是字符串指针,size_t strlen(message), int 特殊选项一般为0 )，成功，返回传送的字节数，失败，-1 同样在这个循环中，跟在send后，接受server的回复：ssize_t recv()和send差不多 断开连接：close(socket); 服务器编程思路： 创建socket：int socket(int 协议簇,int 服务类型,int 协议 ), 返回对应该socket的文件描述符，失败，返回-11.5 设置socket：int setsockopt(int 要设置的socket,int 选项所在协议层,int 需要访问的选项名,const void* 指向选项值的指针,socklen_t 选项的长度); 返回-1,设置失败 绑定地址：int bind(int 创建出来的socket,struct sockaddr* 自己设定好的地址,socklen_t len，地址长度sizeof)返回0,success。返回-1,error 开始监听：int listen(int 用于监听的socket,int 主动参与者数量)。0正在监听，-1 error 接受连接：int accept(int 用于监听的socket,struct sockaddr 主动参与者的地址通过应用传递在return语句之后被填充,socklent_t 地址长度)，返回客户端的socket，-1 error 在循环中不停接受来自客户端的message，recv()同客户端一样 处理接收到的数据，这里就是输出 把message送回给client write(client_sock,client_message,read_size); 断开连接：close(socket); 实例二Programme client HTTP编写一个客户端程序，向指定网站发送请求并获取数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;netdb.h&gt;#define MYMSGLEN 2000int main(int argc,char** argv)&#123; int socket_desc; struct sockaddr_in server; char *message,server_reply[MYMSGLEN]; struct hostent *he; struct in_addr inaddr; socket_desc=socket(AF_INET,SOCK_STREAM,0); if(socket_desc==-1) &#123; perror(&quot;Could not create socket&quot;); return -1; &#125; printf(&quot;Socket created\\n&quot;); //把DNS主机名变成IP地址（使用DNS） if((he=gethostbyname(&quot;httpd.apache.org&quot;))==NULL) &#123; perror(&quot;gethostbyname&quot;); return 2; &#125; memcpy((char*)&amp;inaddr,he-&gt;h_addr,sizeof(struct in_addr)); printf(&quot;IP address for httpd.apache.org is %s \\n&quot;,inet_ntoa(inaddr)); server.sin_family=AF_INET; server.sin_addr.s_addr=inet_addr(inet_ntoa(inaddr)); server.sin_port=htons(80); if(connect(socket_desc,(struct sockaddr*)&amp;server,sizeof(server))&lt;0) &#123; printf(&quot;connect error&quot;); return 1; &#125; printf(&quot;Connection\\n&quot;); message=&quot;GET / HTTP/1.1\\r\\nhost: httpd.apache.org \\r\\n\\r\\n&quot;; if(send(socket_desc,message,strlen(message),0)&lt;0) &#123; puts(&quot;Send failed&quot;); return -1; &#125; puts(&quot;message request sent&quot;); int res; memset(server_reply,0,MYMSGLEN); while((res=recv(socket_desc,server_reply,MYMSGLEN,0))!=0) &#123; if(res &lt;0) &#123; puts(&quot;recv failed&quot;); break; &#125; else &#123; printf(&quot;%s&quot;,server_reply); memset(server_reply,0,MYMSGLEN); &#125; &#125; close(socket_desc); return 0;&#125; 主机名和地址转换功能 struct hostent gethostbyname(const char hostname);把DNS主机名变成IP地址（使用DNS） strcut hostent gethostbyaddr(const char addr,size_t len,int family);把IP地址变成DNS主机名 char* inet_ntoa(struct in_addr invader);将IP地址转换为ASCII点十进制符号 in_addr_t inet_addr(const char* strptr);将点分十进制变成IP地址，-1 failure，不能用于广播（255.255.255.2555） int inet_aton(const char* sttrptr,struct in_addr inaddr);将点十进制表示法转换为IP地址;成功返回1，失败返回0 int inet_pton(int af,const char src, void dst);将IPv4和IPv6地址从文本转换为二进制形式 const char inet_ntop(int af,const void src,char* dst,socklen_t size);将IPv4和IPv6地址从二进制转换为文本形式 其他一些有用函数 void bzero(void* s,size_t n);将区域的前n个字节设置为从零开始 void memset(void s,int c,size_t n);用常量字节c填充指向的存储区的前n个字节返回指向内存区域s的指针 void memcpy(void dest,const void* src,size_t n);将n个字节从内存区域src复制到内存区域dest。内存区域不能重叠","categories":[],"tags":[{"name":"Network Programming","slug":"Network-Programming","permalink":"https://xiaotong1996.github.io/tags/Network-Programming/"},{"name":"笔记","slug":"笔记","permalink":"https://xiaotong1996.github.io/tags/笔记/"}]},{"title":"Network Programming（二）","slug":"Network-Programming（二）","date":"2019-11-06T21:28:03.000Z","updated":"2019-11-06T21:29:48.714Z","comments":true,"path":"2019/11/06/Network-Programming（二）/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/Network-Programming（二）/","excerpt":"","text":"Network Programming（二）Client/server communication 客户端/服务器通信 服务器：被动地等待和响应客户 passive socket 客户端：开始通信 必须知道服务器的地址和端口 active socket 功能说明:–指定本地和远程通信端点 –启动连接 –等待传入连接 –发送和接收数据 –正常终止连接 –错误处理 Network APIapi：application programming interface 应用程序接口API是由程序系统提供的一组功能/服务。 Network API：服务(通常由操作系统提供)提供应用程序和协议软件之间的接口 有各种各样的应用程序接口可用于TCP / IP :Sockets by BerkeleyXTI (X/Open Transport Interface) by AT&amp;TWinsock -Windows Sockets API by MicrosoftMacTCP/ Open Transport by Apple Sockets 用于通信的编程接口 提供此服务的一组原语 通用•可以适应不同的通信需求 独立的特定网络或协议，•最初在4.2BSD系统中开发用于因特网通信，于1983年发布。 不需要使用网络进行通信•本地机器通信：Unix域 套接字:–应用程序进程发送和接收数据的入口点–唯一标识通过互联网地址端到端协议(例如，TCP或UDP )端口号 两种类型的( TCP/IP )套接字—流套接字/连接模式(例如使用TCP )提供可靠的字节流服务—数据语法套接字/非连接模式(例如使用UDP )提供尽力而为的数据报服务最多65.500字节的消息 套接字用于客户端/服务器通信套接字的使用方法如下： 每个应用程序:创建一个套接字–想法:两个应用程序之间的通信将通过一个将两个套接字连接在一起的假想“管道”进行。关闭一个socket套接字 服务器: 将其套接字绑定到一个已知的地址 客户端：找到服务器套接字（通过其已知的地址）并与服务器“发起通信”","categories":[],"tags":[{"name":"Network Programming","slug":"Network-Programming","permalink":"https://xiaotong1996.github.io/tags/Network-Programming/"},{"name":"笔记","slug":"笔记","permalink":"https://xiaotong1996.github.io/tags/笔记/"}]},{"title":"Network Programming（一）","slug":"Network-Programming（一）","date":"2019-11-06T21:22:41.000Z","updated":"2019-11-06T21:27:32.893Z","comments":true,"path":"2019/11/06/Network-Programming（一）/","link":"","permalink":"https://xiaotong1996.github.io/2019/11/06/Network-Programming（一）/","excerpt":"","text":"Network Programming（一）介绍计算机网络是set of hosts，routers 和 intermediate devices（主机，路由器和中间设备）主机运行通信连接到端到端applications路由relay（转发）数据包（data packets）Packets：一系列字节包含用户数据+控制信息（如：目标主机）一次通信（数据交换）遵循一个预定义的通信协议 TCP/IP Generalities（概述）针对不同问题的几个协议：协议簇：TCP/IPTCP/IP提供点到点连接并指定数据应该如何格式化、寻址、传输、路由和在目的地接收可用于互联网和独立的专用网络它被组织成层 IP地址：是分配给网络接口以标识自身的唯一地址。用于与他人通信，并找到中继数据包的路由。长度：4bytes。类型：unicast单播，broadcast广播，multicast多播 TCP和UDPTCP：Transmission Control Protocol传输控制协议 可靠的字节流通道(有序，全部到达，无重复)，类似于文件输入/输出 流量控制 面向连接的 双指向性 TCP用于具有大数据容量和持久连接的服务。 UDP：User Datagram Protocol用户数据报协议 no acknowledgements没有确认 no retransmissions没有重传 out of order乱序执行 无连接，即app指示每个数据包的目的地 UDP更常用于快速查找和一次性查询回复操作。 端口号Ports numbers TCP和UDP都使用端口号用作通信的特定于应用的构造。端点16位无符号整数，范围从0到65535。提供端到端传输。 端口分为三类所有已知端口( 0到1023 )用于基本服务(系统使用，需要超级用户权限)。参考端口( 1024至49151 )由IANA根据请求实体的申请为特定服务关联(在大多数系统中，注册端口可由普通用户使用)动态或私有或短暂端口( 49152至65535 )用于其他目的。 TCP和UDP的一些常见示例以及它们的默认端口：DNS查阅 UDP 53FTP TCP 21HTTP TCP 80POP3 TCP 110Telnet TCP 23 保留端口的详细信息：列在/ etc / services文件中的大多数系统上 能通过 http://www.iana.org/assignments/port-numbers 找到","categories":[],"tags":[{"name":"Network Programming","slug":"Network-Programming","permalink":"https://xiaotong1996.github.io/tags/Network-Programming/"},{"name":"笔记","slug":"笔记","permalink":"https://xiaotong1996.github.io/tags/笔记/"}]},{"title":"SDL学习（一）","slug":"SDL学习（一）","date":"2019-03-16T20:54:51.000Z","updated":"2019-11-06T21:59:29.346Z","comments":true,"path":"2019/03/16/SDL学习（一）/","link":"","permalink":"https://xiaotong1996.github.io/2019/03/16/SDL学习（一）/","excerpt":"","text":"SDL（Specification and Description Languag）学习基础概念System：系统，是要开发的应用总体 environment：环境，是任何处于系统外部的东西 Architecture（体系结构）system可被分解成功能块（functional blocks） block可被分解为子块（sub-blocks) blcok通过一个或多个进程（processes），实现功能，通过信息/信号（messages/signals）来互相通信。 process是一个任务（task），有一个隐式的消息队列（implicit message queue）来从其他tasks接受messages。不必定义这个队列。 block在最终程序中不直接实现，是程序的组织和架构者 blocks和process也叫代理（agents） Communication（通信）Agents通过管道（channels）交换messages channels在最终程序中不直接实现，他们用于架构软件和定义接口 Behavior（行为）进程行为（process behavior）图形化地定义为有限状态机（finite state machine）Internalprocess states, events (messages), decisions, timer manipulations, semaphoremanipulations Data and syntax（数据和语法）SDL和SDL-RT的主要不同之处： SDL，data通过ADT（Abstract Data Types）定义，使用特定概念和符号。data实现也有特定语法 SDL-RT，使用C语言","categories":[],"tags":[{"name":"SDL","slug":"SDL","permalink":"https://xiaotong1996.github.io/tags/SDL/"},{"name":"建模","slug":"建模","permalink":"https://xiaotong1996.github.io/tags/建模/"}]},{"title":"Android学习（二）","slug":"Android学习（二）","date":"2019-03-16T20:52:40.000Z","updated":"2019-03-16T20:53:57.236Z","comments":true,"path":"2019/03/16/Android学习（二）/","link":"","permalink":"https://xiaotong1996.github.io/2019/03/16/Android学习（二）/","excerpt":"","text":"Android（二）活动生命周期（le cycle de vie des activite)进程（processus）进程管理 在不同的GNU/LInux系统中不同 目的：优化应用程序；节省资源；管理任务优先级 一个Android应用是一个Unix进程 可能有一个虚拟据（Dalvik）执行 一个虚拟机aspects的闭包（运行时ART android runtime） 这个进程有一个特殊的生命周期 几个活动生命周期的示例图 注意：执行AlterDialog弹出警告框，这不是一个新的activity，所以没有onPause（）* 进程销毁 onDestory（） 优先级等级 屏幕显示的进程 可见的进程 服务进程 后台任务进程 空进程（已结束，存在cache中的进程） Taches asynchrones（同步的任务）主进程（le thread principal） 刷新界面 处理用户相关事务 处理messages 执行services 不要阻断UI线程 不要从UI线程外部access到UI toolkit 管理线程冲突 两种解决方法： 给图像界面元素加锁 只用一个Thread管理图形界面元素 委托图形界面处理： Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable,long) 异步任务AsyncTask&lt;U,V,W&gt; JSON用HTTP读JSON objets：1. 把请求写入一个异步任务 2. 使用这个AsyncTask类要使用HTTP，有一个封装好的类：HttpURLConnection 自己写一个readStream（）方法用来读入数据流（flux de donnees）来构建结果 1234567891011121314151617private String readStream(InputStream is) throws IOException &#123; StringBuilder sb = new StringBuilder(); BufferedReader r = new BufferedReader(new InputStreamReader(is),1000); for (String line = r.readLine(); line != null; line =r.readLine())&#123; sb.append(line); &#125; is.close(); return sb.toString();&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiaotong1996.github.io/tags/Android/"}]},{"title":"Android学习（一）","slug":"Android学习（一）","date":"2019-03-16T20:50:30.000Z","updated":"2019-03-16T20:52:24.487Z","comments":true,"path":"2019/03/16/Android学习（一）/","link":"","permalink":"https://xiaotong1996.github.io/2019/03/16/Android学习（一）/","excerpt":"","text":"Android学习（一）日志 Log. v()。 用于 打印 那些 最为 琐碎 的、 意义 最小 的 日志 信息。 对应 级别 verbose， 是 Android 日志 里面 级别 最低 的 一种。 Log. d()。 用于 打印 一些 调试 信息， 这些 信息 对 你 调试 程序 和 分析 问题 应该 是有 帮助 的。 对应 级别 debug， 比 verbose 高 一级。 Log. i()。 用于 打印 一些 比较 重要的 数据， 这些 数据 应该 是你 非常 想 看到 的、 可以 帮你 分析 用户 行为 数据。 对应 级别 info， 比 debug 高 一级。 Log. w()。 用于 打印 一些 警告 信息， 提示 程序 在这 个 地方 可能 会有 潜在 的 风险， 最好 去 修复 一下 这些 出现 警告 的 地方。对应 级别 warn， 比 info 高 一级。 Log. e()。 用于 打印 程序 中的 错误 信息， 比如 程序 进入 到了 catch 语句 当中。 当 有错误 信息 打印 出来 的 时候， 一般 都 代表 你的 程序 出现 严重 问题 了， 必须 尽快 修复。 对应 级别 error， 比 warn 高 一级。 活动（Activity）活动（ Activity） 是最 容易 吸引 用户 的 地方， 它是 一种 可以 包含 用户 界面 的 组件， 主要 用于 和 用户 进行 交互。 在 java/ com. example. activitytest中新建一个activity 在 src/layout中创建一个布局文件, 在activity中加载布局（）回到 FirstActivity， 在 onCreate() 方法 中 加入 如下 代码： setContentView( R. layout. first_ layout); 在 AndroidManifest 文件 中 注册 配置 主 活动 的 方法 其 实在 第 1 章 中 已经 介绍 过了， 就是 在&lt; activity&gt; 标签 的 内部 加入&lt; intent- filter&gt; 标签， 并在 这个 标签 里 添加&lt; action android: name=” android. intent. action. MAIN”/&gt; 和&lt; category android: name=” android. intent. category. LAUNCHER” /&gt;这 两句 声明 即可。 Toast(短暂出现的提示框)首先 需要 定义 一个 弹出 Toast 的 触发 点， 正好 界面 上有 个 按钮， 那 我们 就让 点击 这个 按钮 的 时候 弹出 一个 Toast 吧。 在 onCreate()中添加 12345678910protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button=(Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener()&#123; public void onClick(View v)&#123; Toast.makeText(MainActivity.this,\"You clicked Button\", Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; 得到 按钮 的 实例 之后， 我们 通过 调用 setOnClickListener() 方法 为 按钮 注册 一个 监听器， 点击 按钮 时 就会 执行 监听器 中的 onClick() 方法。 静态方法makeText() 创建 出 一个 Toast 对象， 然后 调用 show() 将 Toast 显示 出来 就可以 了。 这里 需要 注意 的 是， makeText() 方法 需要 传入 3 个 参数。 第一个 参数 是 Context， 也就是 Toast 要求 的 上下文， 由于 活动 本身 就是 一个 Context 对象， 因此 这里 直接 传入 FirstActivity. this 即可。 第二个 参数 是 Toast 显示 的 文本 内容， 第三 个 参数 是 Toast 显示 的 时 长， 有两 个 内置 常量 可以 选择 Toast. LENGTH_ SHORT 和 Toast. LENGTH_ LONG。 Menu 在res/menu中新建Menu resource file 在新建出来的menuxml文件中添加items 在activity中重写onCreateOptionsMenu()方法 123public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main,menu); return true;&#125; inflate() 方法 接收 两个 参数， 第一个 参数 用于 指定 我们 通过 哪一个 资源 文件 来 创建 菜单， 这里 当然 传入 R. menu. main。 第二个 参数 用于 指定 我们 的 菜单项 将 添加 到 哪一个 Menu 对象 当中， 这里 直接 使用 onCreateOptionsMenu() 方法 中 传入 的 menu 参数。 然后 给 这个 方法 返回 true， 表示 允许 创建 的 菜单 显示 出来， 如果 返回 了 false， 创建 的 菜单 将 无法 显示。 定义菜单响应事件。在acticity中重写onOprionsItemsSelected()方法： 1234567891011121314public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.add_item: Toast.makeText(this,\"You clicked Add\", Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this,\"You clicked Remove\", Toast.LENGTH_SHORT).show(); break; default: Toast.makeText(this,\"Default\",Toast.LENGTH_SHORT).show(); &#125; return true; &#125; 销毁事件只要 按 一下 Back 键 就可以 销毁 当前 的 活动 了。 不过 如果 你 不想 通过 按键 的 方式， 而是 希望 在 程序 中 通过 代码 来 销毁 活动， 当然 也可以， Activity 类 提供 了 一个 finish() 方法， 我们 在 活动中 调用 一下 这个 方法 就可以 销毁 当前 活动 了。 Intent(连接各个活动)Intent 是 Android 程序 中 各组 件 之间 进行 交互 的 一种 重要 方式， 它不 仅可 以指 明 当前 组件 想要 执行 的 动作， 还可 以在 不同 组件 之间 传递 数据。 Intent 一般 可被 用于 启动 活动、启动 服务 以及 发送 广播 等 场景。 显示IntentIntent 有多 个 构造 函数 的 重载， 其中 一个 是 Intent( Context packageContext, Class&lt;?&gt; cls)。 这个 构造 函数 接收 两个 参数， 第一个 参数 Context 要求 提供 一个 启动 活动 的 上下文， 第二个 参数 Class 则是 指定 想要 启动 的 目标 活动， 通过 这个 构造 函数 就可以 构建 出 Intent 的“ 意图”。 然后 我们 应该 怎么 使用 这个 Intent 呢？ Activity 类 中 提供 了 一个 startActivity() 方法， 这个 方法 是 专门 用于 启动 活动 的， 它 接收 一个 Intent 参数， 这里 我们将 构建 好的 Intent 传入 startActivity() 方法 就可以 启动 目标 活动 了。 修改MainActivity中按钮点击事件 123456button.setOnClickListener(new View.OnClickListener()&#123; public void onClick(View v)&#123; Intent intent=new Intent(MainActivity.this,Test1Activity.class); startActivity(intent); &#125; &#125;); MainActivity.this作为上下文，Test1Activity.class作为目标活动。通过startActivity来执行Intent。 隐式Intent它 并不 明确 指出 我们 想要 启动 哪一个 活动， 而是 指定 了 一系列 更为 抽象 的 action 和 category 等 信息， 然后 交由 系统 去 分析 这个 Intent， 并 帮我 们 找出 合适 的 活动 去 启动。 在AndroidManifest.xml中指定活动能够响应的action和category 123456&lt;activity android:name=\".Test1Activity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.example.activitytest.ACTION_START\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 在&lt; action&gt; 标签 中 我们 指明 了 当前 活动 可以 响应 com. example. activitytest. ACTION_ START 这个 action， 而&lt; category&gt; 标签 则 包含 了 一些 附加 信息， 更 精确 地 指明 了 当前 的 活动 能够 响应 的 Intent 中 还可 能带 有的 category。 只有&lt; action&gt; 和&lt; category&gt; 中的 内容 同时 能够 匹配 上 Intent 中指 定的 action 和 category 时， 这个 活动 才能 响应 该 Intent。 修改按钮的点击事件 123456button.setOnClickListener(new View.OnClickListener()&#123; public void onClick(View v)&#123; Intent intent=new Intent(\"com.example.activitytest.ACTION_START\"); startActivity(intent); &#125; &#125;); 每个 Intent 中 只能 指定 一个 action， 但却 能 指定 多个 category 更多隐式Intent用法使用 隐式 Intent， 我们 不仅 可以 启动 自己 程序 内 的 活动， 还可以 启动 其他 程序 的 活动， 这 使得 Android 多个 应用 程序 之间 的 功能 共享 成为 了 可能。 比如说 你的 应用 程序 中 需要 展示 一个 网页， 这时 你 没有 必要 自己 去 实现 一个 浏览器（ 事实上 也不 太 可能）， 而是 只需 要 调用 系统 的 浏览器 来 打开 这个 网页 就 行了。 12345678button1.setOnClickListener(new View.OnClickListener()&#123; public void onClick(View v) &#123; Intent intent=new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse(\"http://www.google.com\")); startActivity(intent); &#125; &#125;); 了 Intent 的 action 是 Intent. ACTION_ VIEW， 这是 一个 Android 系统 内置 的 动作， 其 常 量值 为 android. intent. action. VIEW。 然后 通过 Uri. parse() 方法， 将 一个 网址 字符串 解析 成 一个 Uri 对象， 再 调用 Intent 的 setData() 方法 将 这个 Uri 对象 传递 进去。 setData()方法，它 接收 一个 Uri 对象， 主要 用于 指定 当前 Intent 正在 操作 的 数据， 而这 些 数据 通常 都是 以 字符串 的 形式 传入到 Uri. parse() 方法 中 解析 产生 的。 与此 对应， 我们 还可 以在&lt; intent- filter&gt; 标签 中 再 配置 一个&lt; data&gt; 标签， 用于 更 精确 地 指定 当前 活动 能够 响应 什么 类型 的 数据。&lt; data&gt; 标签 中 主要 可以 配置 以下 内容。 android: scheme。 用于 指定 数据 的 协议 部分， 如上 例 中的 http 部分。 android: host。 用于 指定 数据 的 主机 名 部分， 如上 例 中的 www. baidu. com 部分。 android: port。 用于 指定 数据 的 端口 部分， 一般 紧随 在 主机 名 之后。 android: path。 用于 指定 主 机名 和 端口 之后 的 部分， 如一 段 网址 中 跟在 域名 之后 的 内容。 android: mimeType。 用于 指定 可以处理 的 数据 类型， 允许 使用 通配符 的 方式 进行 指定。 除了 http 协议 外， 我们 还可以 指定 很多 其他 协议， 比如 geo 表示 显示 地理 位置、 tel 表示 拨 打电话。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiaotong1996.github.io/tags/Android/"}]},{"title":"C#数据库工具开发（十三）","slug":"C-数据库工具开发（十三）","date":"2019-01-09T10:17:58.000Z","updated":"2019-01-09T10:18:35.714Z","comments":true,"path":"2019/01/09/C-数据库工具开发（十三）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（十三）/","excerpt":"","text":"C#数据库工具开发（十三）问题（08/01）单行同步，容易实现，只要判断选择的行状态做操作就行。如何撤销？用栈存储已执行的sql指令以及执行前的字段状态，对应每个指定，做反操作。 做同步操作，全过程 根据差异同步DB 清空dblists 取更新后的dblists 用新的dblists填充dataDB 更新新的infolists 按照新的dblists顺序，对infolists排序，并删除已经选择去掉的项 用新的infolists填充dataxml 同步索引项","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（十二）","slug":"C-数据库工具开发（十二）","date":"2019-01-09T10:16:53.000Z","updated":"2019-01-09T10:17:48.157Z","comments":true,"path":"2019/01/09/C-数据库工具开发（十二）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（十二）/","excerpt":"","text":"C#数据库工具开发（十二）问题（07/30）1. 如何实现同步两个DGV的滚动条123456789private void dataXML_Scroll(object sender, ScrollEventArgs e) &#123; this.dataDB.FirstDisplayedScrollingRowIndex = this.dataXML.FirstDisplayedScrollingRowIndex;&#125;private void dataDB_Scroll(object sender, ScrollEventArgs e)&#123; this.dataXML.FirstDisplayedScrollingRowIndex = this.dataDB.FirstDisplayedScrollingRowIndex; &#125; 2. 如何实现一次删除DGV中的多行123456789101112131415foreach (DataGridViewRow row in dataXML.Rows)&#123; if((row.Cells[0].Value==null||row.Cells[0].Value.ToString()==&quot;&quot;)&amp;&amp;row.Index!=dataXML.Rows.Count-1) &#123; row.Selected = true; &#125; else &#123; row.Selected = false; &#125;&#125;foreach (DataGridViewRow row in dataXML.SelectedRows)&#123; dataXML.Rows.Remove(row);&#125; 在if条件中写要删除的行应该满足的条件，设置行被选中（利用Selected这个property），再删除选中的行。 注意：不能用foreach每一行，加上判断，直接删除。因为每一次删除后，实际上Rows已经改变，循环不能遍历到所有满足条件的行。（先存行号，后删除的做法也一样，同理，每一次删除，行号已经改变） 3. 避免事件无意间调用问题背景：我想要按下delete后，不删除这一行，只清空改行所有数据。想到的解决方法是在删除这一行后，在同一个index新建一行，但是总是出现各种问题。后来发现，因为我在dataXML_RowsAdded（行增加事件）中有完成其他功能，而实际上，我每次新建一行，都会触发这个事件，这就导致出现问题。解决方法：设定一个bool标签deleting，在删除触发的方法中，设定deleting一开始为true，最后设回false，并在增加行触发的方法中，判断deleting的值，若为true则不执行任何操作。","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（十一）","slug":"C-数据库工具开发（十一）","date":"2019-01-09T10:15:51.000Z","updated":"2019-01-09T10:16:43.396Z","comments":true,"path":"2019/01/09/C-数据库工具开发（十一）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（十一）/","excerpt":"","text":"C#数据库工具开发（十一）问题（07/26-07/27）1. 删除数据库中的一列，会自动删除与其关联的索引吗？MySQL是这样的，详情 SQLServer经实践发现，必须先删除索引再删除列。因为索引依赖于列。 2. 索引命名引起的异常问题背景：在新增索引时总是按照表名_INDEX_数字来给索引命名，数字是从0开始往上递增。问题在于，假设我们在test表中分别给三个字段添加了三个索引，即生成索引TEST_INDEX_0/1/2，那么如果我们删除了第一个索引TEST_INDEX_0，保留了索引TEST_INDEX_1/2，再次新建索引时，这个索引名字应该是0还是3结尾？而且我目前的实现，未考虑上述情况，只是在建立索引前查询表中索引数目，以这个数目作为新索引的结尾名，因此现在若创建一个新的索引会命名为TEST_INDEX_2，与表中已存在的索引冲突，发生异常。 解决方案一：每次删除一个索引，把它编号之后的索引编号减一，这涉及到索引的查找和修改。sp_rename &#39;tabName.old_indName&#39;,&#39;new_indName&#39;,&#39;INDEX&#39; 解决方案二：换一种命名方式：编号可用随机值生成真随机数的方法： 12345678910public static string GenerateRandomCode(int length) &#123; var result = new System.Text.StringBuilder(); for (var i = 0; i &lt; length; i++) &#123; var r = new Random(Guid.NewGuid().GetHashCode()); result.Append(r.Next(0, 10)); &#125; return result.ToString(); &#125; 解决方案三：不考虑名称的连续性，直接在最大值基础上往上加。 3. 字段有索引时，不能修改字段类型解决方法：先删除索引，修改字段后，再新建索引。这里会引起一个额外的问题：如何确认要修改的字段是否已存在索引。有以下几种情况： 字段有索引，checkbox已勾选=&gt;先删除索引，修改字段，再新建索引。 字段有索引，checkbox不勾选=&gt;先删除索引，再修改字段 字段无索引，checkbox已勾选=&gt;先修改字段，再添加索引 字段无索引，checkbox不勾选=&gt;直接修改字段 还有两种情况新增字段：先增加字段，根据checkbox值，选择是否添加索引。删除字段：先删除索引，再删除字段 此外，若只增删索引，则会重复修改字段操作。设定bool标识justindex，每次调用compareList（）方法时，确认行有差异，是否是因为只有索引列发生变化，如是则设为true，否则有其他引起行的差异则设为false。这样，在做同步操作前，先根据bool标识，获知引起行差异的原因，可省去没必要的修改字段操作。 一共有八钟可能的操作 只增加字段，不增加索引 OK 只修改字段，不增加索引 OK 不修改字段，增加索引 OK 不修改字段，删除索引 OK 既增加字段，又增加索引 OK 既修改字段，又增加索引 OK 既修改字段，又删除索引 OK 既删除字段，又删除索引 OK","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（十）","slug":"C-数据库工具开发（十）","date":"2019-01-09T10:14:47.000Z","updated":"2019-01-09T10:15:42.426Z","comments":true,"path":"2019/01/09/C-数据库工具开发（十）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（十）/","excerpt":"","text":"C#数据库工具开发（十）问题（07/24-07/25）1. 如何实现一个页面关闭触发上级页面的响应？问题背景：我有一个页面显示某个数据库中所有表名和表结构，在此页面可以打开另一个修改或创建新表的页面，完成后，我想立即在显示页面刷新，让刚刚修改或生成的表也能出现在列表中。解决方法：由于修改添加页面是在显示页面生成的： 12formxml = new FormXMLExecute(&quot;*Oracle*&quot;, filePath.Text);formxml.Show(); 我们只需要在创建formxml时添加一个页面关闭事件即可： 123formxml = new FormXMLExecute(&quot;*Oracle*&quot;, filePath.Text);formxml.FormClosing += new FormClosingEventHandler(this.FromXMLExecute_FormClosing);formxml.Show(); 在页面关闭事件中： 1234private void FromXMLExecute_FormClosing(object sender, FormClosingEventArgs e)&#123; //Do your stuff here.&#125; 实现想要完成的功能（如刷新页面等） 2. DataGridViewCheckBox的响应事件问题背景：想要实现点击DataGridViewCheckBox后，刷新页面解决方法：这个的即时响应和DataGridViewTextBox或DataGridViewComboBox相比简单很多，能直接用现有事件 1234567private void dataXML_CellContentClick(object sender, DataGridViewCellEventArgs e)&#123; if (e.ColumnIndex == 3 &amp;&amp; e.RowIndex != -1) &#123; //Do your stuff here. &#125;&#125; 唯一需要注意的和之前提到的一样：用单元格EditedFormattedValue属性而不是Value属性。 3. 如何查询某个表中所有设置了索引的字段？Oracle：​ 1select a.column_name from all_ind_columns a, all_indexes b where a.index_name=b.index_name and a.table_name = upper(&apos;&quot;+tableName+&quot;&apos;) order by a.table_name&quot;; SQLServer： 1&quot;USE &quot; + DBName+&quot; ;SELECT colname=d.name FROM sysindexes a JOIN sysindexkeys b ON a.id=b.id AND a.indid=b.indid JOIN sysobjects c ON b.id=c.id JOIN syscolumns d ON b.id=d.id AND b.colid=d.colid WHERE a.indid NOT IN(0,255) AND c.name=&apos;&quot;+tableName+&quot;&apos;&quot;; 3.1 更好的查询表中所有索引以及对应列名的sql查询语句1234567891011121314151617use GMP_BF;SELECTtab.name AS [表名],idx.name AS [索引名称],col.name AS [列名]FROMsys.indexes idxJOIN sys.index_columns idxCol ON (idx.object_id = idxCol.object_id AND idx.index_id = idxCol.index_id )JOIN sys.tables tab ON (idx.object_id = tab.object_id)JOIN sys.columns col ON (idx.object_id = col.object_id AND idxCol.column_id = col.column_id)WHERE tab.name=&apos;TEST2&apos;;","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（九）","slug":"C-数据库工具开发（九）","date":"2019-01-09T10:13:27.000Z","updated":"2019-01-09T10:14:35.202Z","comments":true,"path":"2019/01/09/C-数据库工具开发（九）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（九）/","excerpt":"","text":"C#数据库工具开发（九）问题（07/20）1. 如何实现DataGridView更改Cell值实时同步（像TextBox的效果）？具体实现： 123456789101112131415161718192021222324252627private void dataXML_EditingControlShowing(object sender, DataGridViewEditingControlShowingEventArgs e) &#123; if (e.Control.GetType().Equals(typeof(DataGridViewComboBoxEditingControl)))//cell为类ComboBox时 &#123; e.CellStyle.BackColor = Color.FromName(&quot;window&quot;); DataGridViewComboBoxEditingControl editingControl = e.Control as DataGridViewComboBoxEditingControl; editingControl.SelectedIndexChanged += new EventHandler(EditingTB_TypeChanged); &#125; else if (e.Control.GetType().Equals(typeof(DataGridViewTextBoxEditingControl)))//cell为类TextBox时 &#123; e.CellStyle.BackColor = Color.FromName(&quot;window&quot;); DataGridViewTextBoxEditingControl editingControl = e.Control as DataGridViewTextBoxEditingControl; editingControl.TextChanged += new EventHandler(EditingTB_LengthChanged); &#125; &#125; private void EditingTB_TypeChanged(object sender,EventArgs e) &#123; //添加操作 &#125; private void EditingTB_LengthChanged(object sender,EventArgs e) &#123; //添加操作 &#125; 参考：DataGridView的单元格内容即时更新方法注意点：要用dataGridView1.CurrentCell.EditedFormattedValue而不是dataGridView1.CurrentCell.Value 2. string删除空格三种方式：​ string trim = Regex.Replace( text, @”\\s”, “” ); 1234567string trim = text.Replace( &quot; &quot;, &quot;&quot; ); trim = trim.Replace( &quot;\\r&quot;, &quot;&quot; ); trim = trim.Replace( &quot;\\n&quot;, &quot;&quot; ); trim = trim.Replace( &quot;\\t&quot;, &quot;&quot; ); string text = &quot; My test\\nstring\\r\\n is\\t quite long &quot;; string trim = text.Trim(); 3. 获取系统时间DateTime.Now.ToString(&quot;f&quot;);//不显示秒 参考：C#获取当前系统时间 4. 导出文件不能立即在目标目录显示文件解决方法：将包含savefiledialog的窗体显示从showdialog改为show 5. 如何实现DataGridViewTextBox自动把小写转化为大写？同样用到EditingControlShowing这个事件，另外在DataGridViewTextBox中只需要设置某一列的CharacterCasing为Upper就行。具体实现​ 12345678910111213DataGridView dgv = (DataGridView)sender; if (e.Control is DataGridViewTextBoxEditingControl) &#123; DataGridViewTextBoxEditingControl editingControl = (DataGridViewTextBoxEditingControl)e.Control; if (dgv.CurrentCell.OwningColumn.Name == &quot;fieldName&quot;) &#123; editingControl.CharacterCasing = CharacterCasing.Upper; &#125; else &#123; editingControl.CharacterCasing = CharacterCasing.Normal; &#125; &#125;","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（八）","slug":"C-数据库工具开发（八）","date":"2019-01-09T10:11:14.000Z","updated":"2019-01-09T10:13:00.858Z","comments":true,"path":"2019/01/09/C-数据库工具开发（八）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（八）/","excerpt":"","text":"C#数据库工具开发（八）问题（07/19）1. 如何实现拖拽文件到textbox获取文件路径？利用textbox两个事件：dragenter和dragdrop具体实现 1234567891011private void filePath_DragEnter(object sender, DragEventArgs e) &#123; if (e.Data.GetDataPresent(DataFormats.FileDrop)) &#123; e.Effect = DragDropEffects.Link; &#125; else &#123; e.Effect = DragDropEffects.None; &#125; &#125; 12345private void filePath_DragDrop(object sender, DragEventArgs e)&#123;string path = ((System.Array)e.Data.GetData(DataFormats.FileDrop)).GetValue(0).ToString(); filePath.Text = path;&#125; 2. 数据库如何增删改字段？只考虑SQLServer和Oracle，增加和删除字段可用相同sql语句,修改字段略有不同：增加：sql = @&quot;use &quot; + DBName + &quot;; ALTER TABLE &quot; + tableName + &quot; ADD &quot; + fieldName + &quot; &quot; + fieldType + &quot;(&quot; + fieldLength + &quot;);&quot;;删除：sql = @&quot;use &quot; + DBName + &quot;; ALTER TABLE &quot; + tableName + &quot; DROP COLUMN &quot; + fieldName + &quot;;&quot;;修改：SQLSerer：sql = @&quot;use &quot; + DBName + &quot;; ALTER TABLE &quot; + tableName + &quot; ALTER COLUMN &quot; + fieldName + &quot; &quot; + fieldType + &quot;(&quot; + fieldLength + &quot;);&quot;;Oracle:sql = @&quot;ALTER TABLE &quot; + tableName + &quot; modify(&quot; + fieldName + &quot; &quot; + fieldType + &quot;(&quot; + fieldLength + &quot;))&quot;; 3. 如何导出文件？使用SaveFileDialog控件具体实现： 123456789101112131415161718192021222324252627SaveFileDialog saveFileDialog1 = new SaveFileDialog(); saveFileDialog1.Filter = &quot;TXT|*.txt&quot;; saveFileDialog1.Title = &quot;选择导出sql记录的存储路径&quot;; saveFileDialog1.ShowDialog(); // If the file name is not an empty string open it for saving. if (saveFileDialog1.FileName != &quot;&quot;) &#123; // Saves the Image via a FileStream created by the OpenFile method. System.IO.FileStream fs = (System.IO.FileStream)saveFileDialog1.OpenFile(); // Saves the Image in the appropriate ImageFormat based upon the // File type selected in the dialog box. // NOTE that the FilterIndex property is one-based. StreamWriter sw = new StreamWriter(fs); foreach(string result in sqlcommands) &#123; sw.WriteLine(result); &#125; //清空缓冲区 sw.Flush(); //关闭流 sw.Close(); fs.Close(); &#125; 4. 如何给DataGridView增加行号123456789101112131415private void dataXML_RowPostPaint(object sender, DataGridViewRowPostPaintEventArgs e) &#123; var grid = sender as DataGridView; var rowIdx = (e.RowIndex + 1).ToString(); var centerFormat = new StringFormat() &#123; // right alignment might actually make more sense for numbers Alignment = StringAlignment.Center, LineAlignment = StringAlignment.Center &#125;; var headerBounds = new Rectangle(e.RowBounds.Left, e.RowBounds.Top, grid.RowHeadersWidth, e.RowBounds.Height); e.Graphics.DrawString(rowIdx, this.Font, SystemBrushes.ControlText, headerBounds, centerFormat); &#125;","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（七）","slug":"C-数据库工具开发（七）","date":"2019-01-09T10:10:02.000Z","updated":"2019-01-09T10:11:01.501Z","comments":true,"path":"2019/01/09/C-数据库工具开发（七）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（七）/","excerpt":"","text":"C#数据库工具开发（七）问题（07/18）1. 返回登录界面程序入口是登录界面，登录成功后隐藏登陆界面，显示主界面。现在想要实现点击主界面的按钮，返回登录界面。 思路一：登录成功后，hide登录界面，new主界面。点击back按钮，hide主界面，show登陆界面。再次点击登陆，更新（reload）主界面有两个问题，第一为了防止之后反复创建新的主界面，我把主界面先作为登陆界面属性创建，在login按钮事件中，只是添加参数，将其显示出来。可以增加一个静态变量isShown表示主界面是hide还是show。问题在于，主界面的load方法只在一开始调用，要想办法实现主界面的重新加载。第二，主界面hide之后如何重新show登录界面。已知能用委托实现。 思路二：登录成功后，hide登陆界面，new主界面。点击back按钮，close主界面，show登录界面。再次点击登录，新建(new)主界面同样有两个问题，第二，我想保留当主界面close时，整个程序exit这个特性，所以我在FormMainOrcl_FormClosed事件中，有Application.Exit();，但是form.close()方法，也会引起这个事件的响应，这就导致点击back按钮后，整个程序都退出了。第二，与思路一第二点一致 目前暂时能想到的解决方案：不保留主界面close，程序exit这个设定，程序只有在登陆界面退出时才退出。 改进的实现思路二的方案：在主界面添加变量justback，默认false，若点击back按钮，将justback设为true，在formclosed事件中判断justback，可以跳过程序退出。对于第二点，不用委托，更简单的实现方法在登录界面中 1234this.Hide();FormMainTableShow formMain = new FormMainTableShow();formMain.Tag = this;formMain.Show(); 在主界面中 123FormLogin login = (FormLogin)this.Tag;login.Show();this.Close(); 2. 设置16进制颜色值例子：Color color=ColorTranslator.FromHtml(&quot;#CE76D1&quot;); 3. 调用资源文件例子：XElement root = XElement.Parse(Resources.ResourceManager.GetObject(&quot;XMLTypeOracle&quot;) as string);","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（六）","slug":"C-数据库工具开发（六）","date":"2019-01-09T10:08:59.000Z","updated":"2019-01-09T10:09:50.961Z","comments":true,"path":"2019/01/09/C-数据库工具开发（六）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（六）/","excerpt":"","text":"C#数据库工具开发（六）问题（07/17）1. 两个list的互相比较背景：我要比较两个DataGridView中多列值，可转变为两列list的互相比较 我的简单实现：用多次foreach循环，设置一个标签find=false；找到改为ture；实现查找两个lists中有哪些不同项。这样做能在循环中找到不同项和差项时，直接进行操作。可能存在问题是对于大量数据效率低，好在我这里只要比较数据库某个表中的字段名称，类型和长度。 其他实现：C# Linq获取两个List或数组的差集交集这样做的话，要先把DataGridView中的列存入list，linq取到差集后，再在DataGridView中定位差集中的元素，再进行操作。好处是linq在普通方法实现list比较时，效率高，对大量数据也适用。考虑之后学习linq，尝试实现。 2. CHARACTER_MAXIMUM_LENGTH返回值为空string length = (reader.IsDBNull(2)) ? &quot;&quot;: Convert.ToString(reader.GetInt32(2));sqlserver数据库中，CHARACTER_MAXIMUM_LENGTH查询结果为空，但是返回值不能用reader.GetInt32(2)==null来判断。原因是数据库中的null和字符串中的null是不同类型的值，所以要用IsDBNULL来判断。","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（五）","slug":"C-数据库工具开发（五）","date":"2019-01-09T10:07:59.000Z","updated":"2019-01-09T10:08:48.627Z","comments":true,"path":"2019/01/09/C-数据库工具开发（五）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（五）/","excerpt":"","text":"C#数据库工具开发（五）问题（07/16）1. xml.load()方法引发web exception未处理：远程服务器返回错误： ( 503 ) 服务器不可用异常解决方法： 尝试从XHTML文件中删除 DOCTYPE，可能你有指向外部DTD的链接。 doc.XmlResolver = null;//this忽略 DTD 2. sqlDataReader未关闭引发错误之前是直接拿sqlDataReader作返回值，但是sqlDataReader需要及时关闭，不然会导致二次调用同一方法引起异常。好的写法是：把sqlDataReader读到的数据存入dataTable中，关闭sqlDataReader，返回dataTable。","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（四）","slug":"C-数据库工具开发（四）","date":"2019-01-09T10:06:56.000Z","updated":"2019-01-09T10:07:48.365Z","comments":true,"path":"2019/01/09/C-数据库工具开发（四）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（四）/","excerpt":"","text":"C#数据库工具开发（四）问题（07/13）1. SQL查询某个表中所有字段名和字段类型SQLServer： 1string sql = @&quot;USE &quot; + DBName+ &quot;; select COLUMN_NAME,DATA_TYPE,CHARACTER_MAXIMUM_LENGTH,IS_NULLABLE from INFORMATION_SCHEMA.COLUMNS t where t.TABLE_NAME = &apos;&quot; + TableName+&quot;&apos;;&quot;; Oracle: 1string sql = @&quot;select column_name, data_type from user_tab_columns where table_name = &apos;&quot;+TableName+&quot;&apos;&quot;; 2. Linq to XML解析半闭合标签的XML文件有问题看（五）linq需要学习 3. XML Document System.Net.WebException异常在XmlDocument doc = new XmlDocument();doc.Load(path);之间加断点调试会引发上述异常。正常调试没问题。 4. C#string操作常用方法split：按字符分割返回一个string数组substring：获取部分字符串","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（三）","slug":"C-数据库工具开发（三）","date":"2019-01-09T10:05:47.000Z","updated":"2019-01-09T10:06:42.728Z","comments":true,"path":"2019/01/09/C-数据库工具开发（三）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（三）/","excerpt":"","text":"C#数据库工具开发（三）问题（07/11-07/12）1. 在实现ConfigerManager时，把实现都放在了登陆界面的事件函数中，没能很好的分离功能（待解决）虽然尝试了把这部分功能分离出来，但是最多把保存登陆信息和伴随用户选择更改登陆信息这两部分放到Configer工具类中，后者要用至少4个引用参数来为窗口中的控件提供Text值。而对于登录界面默认加载最近登录信息的功能，则需要更多参数来实习，考虑了一下又改回之前的实现方案。 2. 连接oracle服务器时，提示System.ComponentModel.Win32Exception: 安全包中没有可用的凭证异常。应该是安全认证方面的问题，解决方法是：win10用户退出微软登录账号，改用本地账号。不理解是为什么。 3. ORA-00911:无效字符连接成功后执行Oracle的sql语句，报错信息包含这样的错误。解决方法是：去掉sql语句结束的;分号。分号对与SQL Server的语句执行无影响。","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（二）","slug":"C-数据库工具开发（二）","date":"2019-01-09T10:03:17.000Z","updated":"2019-01-09T10:05:30.063Z","comments":true,"path":"2019/01/09/C-数据库工具开发（二）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（二）/","excerpt":"","text":"C#数据库工具开发（二）问题（07/09-/07/11）1. 数据库连接的开关，需要确认连接状态为了避免之后执行sql查询等操作时反复连接数据库，我把数据库连接打开和关闭分成两个方法，在登录成功时打开连接，一直到程序结束前断开连接。同时为了避免多次打开同一连接，需要在打开前先确认连接状态。 2. 执行SQL语句是忽略关键字GO问题发生在使用SQL语句进入特定数据库时。虽然在实际数据库中可以使用，但用C#连接的SQL server不识别GO。解决方法也很简单，use 数据库名之后不加GO，加;就行。更好的解决方法：处理批量sql语句ps：记录一种查询服务器中所有数据库 和 两种查询特定数据库中所有表的SQL语句：查数据库：Select Name FROM Master.dbo.SysDatabases ORDER BY Name;查表法一：select name from sysobjects where xtype=&#39;U&#39; order by name;查表法二：SELECT table_name FROM information_schema.tables WHERE table_type = &#39;base table&#39;详细1详细2 3. 存储sql执行语句结果的两种方式法一用SqlDataAdapter 123DataSet ds = new DataSet();SqlDataAdapter sAdapter = new SqlDataAdapter(sql, sqlConnection);sAdapter.Fill(ds); 法二用SqlDataReaderSqlDataReader sRead = cmd.ExecuteReader();这两种方法的主要区别 4. 查询结果如何在主窗口正确显示？最开始使用的ListView控件，通过添加listviewitem显示字段。具体方法如下： 12345ListViewItem li = new ListViewItem(); li.SubItems.Clear(); li.SubItems[0].Text = reader[&quot;name&quot;].ToString(); li += new EventHandler(this.dbItem_DoubleClick); DBList.Items.Add(li); 这种方法问题在于，我想实现点击item（字段）显示对应的表名或表结构，但是很难为item添加事件。解决措施：换用DataGridView控件，好处在于:第一，这个控件本来就是为数据库显示服务的，获得DataSet之后用dataView.DataSource = ds.Tables[0].DefaultView;就可以显示完整表单。第二，通过CurrentCellChanged事件就可以很方便实现点击显示对应表单的效果。","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（一）","slug":"C-数据库工具开发（一）","date":"2019-01-09T09:59:45.000Z","updated":"2019-01-10T22:24:16.084Z","comments":true,"path":"2019/01/09/C-数据库工具开发（一）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（一）/","excerpt":"","text":"C#数据库工具开发（一）源码查询我的Github：DBTool 开发日程 2019/07/09-/07/11sql server数据库连接+登录界面主界面+表单查询和显示 07/11-07/12登录配置文件oracle数据库连接 07/13-07/13读取保存数据库字段属性读取保存xml解析数据部分实现利用xml解析数据同步数据库（添加表）为主界面添加控件 07/13-07/13部分实现xml字段到sql字段映射xml导入配置页面部分实现利用xml解析数据同步数据库 07/16-07/16sql server和oracle数据库连接重构（sqlDataReader改用）xml导入创建新表部分实现xml与DB字段比较 07/17-07/17为比较页面（xml执行页面）添加字段长度项优化xml与DB字段比较用配置文件实现XML中字段类型映射界面优化 07/18-07/18增加logo增加数据库检索将SQL和Oracle显示table界面合二为一，删除SQL显示table界面中显示数据库的表（该功能与数据库检索重复)将字符串映射文件加入资源中 07/19-07/19更换logo，调整窗体增加拖拽文件直接加载功能优化字符串映射功能，避免bug对比界面自动刷新,优化显示增加同步数据库功能增加导出sql语句功能 07/20-07/20优化对比界面更改字段事件优化导出sql语句功能，避免线程卡死添加xml显示界面手动添加或删除字段并刷新比对的功能 07/24-07/24优化添加表完成后字段页面同步刷新优化添加表完成后导出sql语句优化添加表完成后表显示页面刷新修复修改字段不显示的bug新增特性返回表显示页面自动定位到最新改动的table 07/25-07/27添加索引列，新增设置索引功能增加索引同步功能（包括索引的增加、删除）重写数据库同步xml部分，优化索引的建立删除，使其能像其他字段一样简单使用xml执行界面添加用户误操作的警告和提示（如，用户添加字段名相同的行） 07/30-08/01优化对比界面(更好的对比显示，实现左右页面同步滚动）简化用户操作(现在不用点击就可以选到鼠标指定行，删除操作也更方便）更改logo 08/01-08/03添加单行同步与撤销操作功能 主要构成 DBconnection：SQLServer数据库连接工具类主要功能：配置连接信息；打开、关闭数据库连接；执行sql语句获得结果（以ShowDatabaseList方法为例，用sql语句查询服务器中所有数据库名，将该结果存入sRead供前端窗口调用显示） FormLogin：登录窗口主要功能：获取连接信息更新： 保存连接信息（记住密码） 检索数据库（用于选择登入那个数据库） FormMainTableShow：主窗口主要功能：主要逻辑业务的展示和执行界面，包含各种响应事件（第一阶段后可查看连接到远程数据库中所有表格）更新： 改为只用来展示数据库中所有表名和显示表信息 提供选择xml文件的入口 ConfigerManager：登陆信息实体类主要功能：方便实现存储登录记录实现写在FormLogin各种事件中 DBconnnectionOracle：Oracle数据库连接工具类主要功能：与DBconnection相似 FormXMLExecute：主要功能窗口主要功能：解析显示xml表结构，提供添加或同步数据库表/表结构的功能,提供修改xml列表实时验证两表差异性的功能 MappingTool：映射java类型到数据库的字段类型的工具类主要功能：解析保存映射信息的xml，将java类型，转换成保存数据库字段类型和对应默认字段长度的Dictionary。 XMLParsing：解析提供表结构的xml的工具类主要功能：将xml保存的表结构，解析出表名和字段名，字段类型 ParsedInfo：xml信息的实体类主要功能：保存xml解析出来的表结构信息 DBmodify：执行增删改数据库字段、增删索引的工具类 RowRecord:记录DGV中行信息的实体类主要功能：保存对xml显示部分增删改之前的行信息，用于实现撤销操作 参考页面 关于数据库表结构","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"深入理解C#（十六）：Lambda表达式和表达树","slug":"深入理解C-（十六）：Lambda表达式和表达树","date":"2019-01-09T09:56:26.000Z","updated":"2019-01-09T09:56:58.712Z","comments":true,"path":"2019/01/09/深入理解C-（十六）：Lambda表达式和表达树/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（十六）：Lambda表达式和表达树/","excerpt":"","text":"深入理解C#（十六）*第九章（C# 3：Lambda表达式和表达树）lambda=λ 作为委托的lambda表达式Func&lt;…&gt;委托类型简介.NET3.5的System命名空间中，有5个泛型Func委托类型。每个委托签名都获取0~4个参数，其类型使用类型参数来指定。最后一个类型参数用作每种情况下的返回类型。例如：Func&lt;string,double,int&gt;等价于public delegate int SomeDelegate(string arg1,double arg2) 转换成lambda表达式用匿名方法来创建委托实例 123Func&lt;string,int&gt; returnLength;returnLength=delegate(string text)&#123;return text.Length;&#125;;Console.WriteLine(returnLength(&quot;Hello&quot;)); Lambda表达式最冗长的形式是：(显示类型的参数列表）=》{语句}例子： 1234Func&lt;string, int&gt; returnLength;returnLength = (string text) =&gt; &#123; return text.Length; &#125;;Console.WriteLine(returnLength(&quot;Hello&quot;)); Lambda表达式有着和匿名方法控制返回语句一样的规则：不能从Lambda表达式返回void类型 使用单一表达式作为主体大多数情况可以用一个表达式来表示整个主体，该表达式的值是Lambda的结果 1（string text)=&gt;text.Length 隐式类型的参数列表编译器能推断出参数类型，可以不用显示声明参数类型，注意：隐式和显示类型参数不能一起用。此外要是有out或ref参数，只能使用显示参数。 1(text)=&gt;text.Length 单一参数的快捷语法如果lambda表达式只需要一个参数，且那个参数可以隐式指定类型，可以省略圆括号 1text=&gt;text.Length 现在，例子简化成： 1234 Func&lt;string, int&gt; returnLength;returnLength = text =&gt; text.Length;Console.WriteLine(returnLength(&quot;Hello&quot;)); 高阶函数Lambda表达式主体可以包含另一个Lambda表达式，另外，Lambda表达式的参数可以是另一个委托 使用List和事件的简单例子列表的过滤、排序和操作List的FindAll方法，获取一个Predicate,并返回一个新列表，包含原始列表中与谓词匹配的所有元素。Sort方法获取一个Comparison,并相应地对列表进行排序。ForEach方法获取一个Action,并对每个元素执行特定行为。 123456789101112131415161718192021222324252627282930var films = new List&lt;Film&gt;&#123; new Film &#123;Name=&quot;Jaws&quot;, Year=1975&#125;, new Film &#123;Name=&quot;Singing in the Rain&quot;, Year=1952&#125;, new Film &#123;Name=&quot;Some like it Hot&quot;, Year=1959&#125;, new Film &#123;Name=&quot;The Wizard of Oz&quot;, Year=1939&#125;, new Film &#123;Name=&quot;It&apos;s a Wonderful Life&quot;, Year=1946&#125;, new Film &#123;Name=&quot;American Beauty&quot;, Year=1999&#125;, new Film &#123;Name=&quot;High Fidelity&quot;, Year=2000&#125;, new Film &#123;Name=&quot;The Usual Suspects&quot;, Year=1995&#125;&#125;;Action&lt;Film&gt; print = film =&gt; Console.WriteLine(&quot;Name=&#123;0&#125;, Year=&#123;1&#125;&quot;, film.Name, film.Year);// Note: extra lines added for clarity when runningConsole.WriteLine(&quot;All films&quot;);films.ForEach(print);Console.WriteLine();Console.WriteLine(&quot;Oldies&quot;);films.FindAll(film =&gt; film.Year &lt; 1960) .ForEach(print);Console.WriteLine();Console.WriteLine(&quot;Sorted&quot;);films.Sort((f1, f2) =&gt; f1.Name.CompareTo(f2.Name));films.ForEach(print);Console.Read(); 创建委托实例,用来打印列表中的项，因为之后会使用三次，所以用变量print来保存，而不用每次都单独使用一个Lambda表达式。它可以打印一个film类型，通过foreach就能打印整个列表。Action&lt;Film&gt; print = film =&gt; Console.WriteLine(&quot;Name={0}, Year={1}&quot;, film.Name, film.Year); 1`films.ForEach(print);` 在事件处理程序中进行记录123456789101112131415161718192021222324252627static void Log(string title, object sender, EventArgs e)&#123; Console.WriteLine(&quot;Event: &#123;0&#125;&quot;, title); Console.WriteLine(&quot; Sender: &#123;0&#125;&quot;, sender); Console.WriteLine(&quot; Arguments: &#123;0&#125;&quot;, e.GetType()); foreach (PropertyDescriptor prop in TypeDescriptor.GetProperties(e)) &#123; string name = prop.DisplayName; object value = prop.GetValue(e); Console.WriteLine(&quot; &#123;0&#125;=&#123;1&#125;&quot;, name, value); &#125;&#125;static void Main()&#123; Button button = new Button(); button.Text = &quot;Click me&quot;; button.Click += (src, e) =&gt; Log(&quot;Click&quot;, src, e); button.KeyPress += (src, e) =&gt; Log(&quot;KeyPress&quot;, src, e); button.MouseClick += (src, e) =&gt; Log(&quot;MouseClick&quot;, src, e); Form form = new Form(); form.AutoSize = true; form.Controls.Add(button); Application.Run(form);&#125; 表达式树以编程方式构建表达式树，编译并执行1234567Expression firstArg = Expression.Constant(2);Expression secondArg = Expression.Constant(3);Expression add = Expression.Add(firstArg, secondArg);Func&lt;int&gt; compiled = Expression.Lambda&lt;Func&lt;int&gt;&gt;(add).Compile();Console.WriteLine(compiled());Console.Read(); 将C# Lambda表达式转换成表达式树123Expression&lt;Func&lt;int&gt;&gt; return5 = () =&gt; 5;Func&lt;int&gt; compiled = return5.Compile();Console.WriteLine(compiled()); （）=》 5是Lambda表达式","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（十五）：智能编译器","slug":"深入理解C-（十五）：智能编译器","date":"2019-01-09T09:55:42.000Z","updated":"2019-01-09T09:56:04.804Z","comments":true,"path":"2019/01/09/深入理解C-（十五）：智能编译器/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（十五）：智能编译器/","excerpt":"","text":"深入理解C#（十五）*第八章（C# 3：用智能的编译器来防错） 自动实现的属性简化普通属性的代码普通属性：可读/可写并将值存储到一个非常直观的私有变量中的属性。 1public string Name&#123;get;set;&#125; 仍然可以为取值和赋值方法指定不同的访问权限。 静态自动属性：取值方法是共有的，赋值方法是私有的，且赋值方法只能在类型初始化程序中使用。 定义struct时，使用自动属性，需要显式地调用无参构造函数 12345678public struct Foo&#123; public int Value&#123;get;private set;&#125; public Foo(int value):this() &#123; this.Value=value; &#125;&#125; 自动属性仍有几个小问题： 没办法在声明时，设定初始的默认值 没法把它们设定成真正的只读属性（使用私有赋值方法来解决） 隐式类型的局部变量使用var声明局部变量var并没有把C#变成动态类型或者弱类型的语言，只是类型由编译器推断编译器获取初始化表达式在编译时的类型，并使变量也具有那种类型。 隐式类型的限制只有在一下情况能使用： 局部变量，不是静态字段和实例字段 声明的同时被初始化 初始化表达式不是方法组和匿名函数 初始化表达式不是null 语句中之声明了一个变量 初始化表达式不包含正在声明的变量 对于第三点，显示声明变量是可以的，如：var starter = (ThreadStart)delegate(){ Console.WriteLine();}对于null也可以做强制类型转换，但是无意义。 最常见应用：用方法调用的结果来初始化一个变量。 隐式类型的优缺点优点：增强可读性，改变代码重心缺点：类型不明确 简化的初始化定义示例类型new Person{Name=&quot;Jon&quot;,Age=36} 为嵌入对象设置属性1234Person tom=new Person(&quot;Tom&quot;)&#123;Age=9,Home=&#123;Country=&quot;UK&quot;,Town=&quot;Reading&quot;&#125;&#125;; 集合初始化程序 使用集合初始化程序来创建新集合List&lt;string&gt; names=new List{ &quot;Holly&quot;,&quot;Jon&quot;,&quot;Tom&quot;};任何实现了IEnumerable类型，只要它为初始化列表中出现的每个元素都提供了一个恰当的公共的Add方法，就可以使用这个特性。 在其他对象初始化程序中填充集合 隐式类型的数组对于void MyMethod(string[] names)C#3 这样使用：MyMethod(new[] {&quot;Holly&quot;,&quot;Jon&quot;,&quot;Tom&quot;}); 匿名类型实例：使用匿名类型，填充数组 123456789101112131415var family = new[]&#123; new &#123; Name = &quot;Holly&quot;, Age = 37 &#125;, new &#123; Name = &quot;Jon&quot;, Age = 36 &#125;, new &#123; Name = &quot;Tom&quot;, Age = 9 &#125;, new &#123; Name = &quot;Robin&quot;, Age = 6 &#125;, new &#123; Name = &quot;William&quot;, Age = 6 &#125;&#125;;int totalAge = 0;foreach (var person in family)&#123; totalAge += person.Age;&#125;Console.WriteLine(&quot;Total age: &#123;0&#125;&quot;, totalAge); family中所有人具有相同的类型，否则编译器无法推断出何时类型。 匿名类型的成员 一个获取所有初始值的构造函数 共有的只读属性 属性的私有只读字段 重写的Equals、GethashCode和ToString 投影初始化程序实际使用时，往往希望从别的对象复制属性用以新建一个新的对象。 例如：new { Name=person.Name,IsAdult=(person.Age&gt;=18)}C# 3支持一种简化的语法：如果不指定属性名称，而只指定用于求指的表达式，它会使用表达式的最后一个部分作为名称，前提是它只是一个简单字段或属性。应用：new { person.Name, IsAdult=(Person.Age&gt;=18)}","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（十四）：其他特性","slug":"深入理解C-（十四）：其他特性","date":"2019-01-09T09:54:09.000Z","updated":"2019-01-09T09:54:32.790Z","comments":true,"path":"2019/01/09/深入理解C-（十四）：其他特性/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（十四）：其他特性/","excerpt":"","text":"深入理解C#（十四）*第七章（C# 2：其他特性）分部类型，静态类，独立的取值方法，命名空间别名，Pragma指令，固定大小的缓冲区，InternalsVisibleToAttribute（友元程序集） 分部类型在多个文件中创建一个类型创建分部类型，只需要加上partial关键字。编译器实际上是在编译之前把所有源文件合并在一起。（这就是为什么C#文件名和类名可以不一致了，同样一个class Example，可以用分部类型，写多个Example1/2/…cs文件 举例： 123456789 partial class Example&lt;TFirst, TSecond&gt; : IEquatable&lt;string&gt; where TFirst : class&#123; public bool Equals(string other) &#123; return false; &#125;&#125; 在这个文件中声明接口和类型参数约束 1234567 partial class Example&lt;TFirst, TSecond&gt; : EventArgs, IDisposable&#123; public void Dispose() &#123; &#125;&#125; 在这个文件中声明基类和接口 分布类型的使用分布类型的用途： 主要联接设计器和其他代码生成器 辅助进行重构 单元测试 C# 3的分部方法分部方法的声明与抽象方法相同:使用partial修饰符无须实现，在实际的实现部分也要partial修饰符。分部方法可以不被实现，这些未被实现的分部方法的调用会被编译器移除。由于方法可能不存在，分部方法返回类型必须为void，且不能获取out参数。必须是私有的 静态类型独立的取值方法/赋值方法属性访问器举例：​ 123456string name;public string Name&#123; get&#123;return name;&#125; private set&#123; name=value;&#125;&#125; Name属性对于其他所有类型都是只读的，但在类型内部能用属性语法设置。大部分的默认访问修饰符是私有的，但对于取值/赋值方法，访问修饰符和属性本身整体上保持一致另外不能把属性设为私有，但把取值方法设为公有 命名空间别名限定的命名控件别名C# 1例子：​ 1234567891011121314151617using System;using System.ComponentModel;using WebForms = System.Web.UI.WebControls;using WinForms = System.Windows.Forms;namespace Chapter07&#123;[Description(&quot;Listing 7.05&quot;)]class SimpleAliases&#123; static void Main() &#123; Console.WriteLine (typeof (WinForms.Button)); Console.WriteLine (typeof (WebForms.Button)); &#125;&#125;&#125; 若有一个类也叫WinForms，那编译器该如何区分？C# 2改进： 123456789101112131415161718192021using System;using System.ComponentModel;using WebForms = System.Web.UI.WebControls;using WinForms = System.Windows.Forms;namespace Chapter07&#123;[Description(&quot;Listing 7.06&quot;)]class DoubleColonForAliases&#123; class WinForms &#123; &#125; static void Main() &#123; Console.WriteLine (typeof (WinForms::Button)); Console.WriteLine (typeof (WebForms::Button)); &#125;&#125;&#125; 引入“::“来区分命名空间和类型 全局命名空间别名无法为命名空间层级的根或全局命名空间定义别名。可以使用global:: 外部别名pragma指令pragma指令是一个由#pragma开头的代码行所表示的预处理指令，它后面能包含任何文本。 警告pragma举例：例如我们使用了一个从未使用的变量，但想要忽略编译器警告 123#pragma warning disable 0169int x;#pragma warning restore 0169 校验和pragma非安全代码中固定大小的缓冲区把内部成员暴露给选定的程序集","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（十三）：迭代器","slug":"深入理解C-（十三）：迭代器","date":"2019-01-09T09:53:26.000Z","updated":"2019-01-09T09:53:48.114Z","comments":true,"path":"2019/01/09/深入理解C-（十三）：迭代器/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（十三）：迭代器/","excerpt":"","text":"深入理解C#（十三）*第六章（C# 2：实现迭代器的捷径） 知识简介迭代器模式：行为模式的一种范例，允许访问一个数据项序列中的所有元素，而不用关心序列的类型。能有效构建一个数据管道。(数据项序列进入数据管道后，经过一系列不同的转换或过滤后再从另一端出来）行为模式：一种简化对象之间通信的设计模式 迭代器模式通过IEnumerator和IEnumerable接口以及它们的泛型等价物来封装。若某个类型实现了IEnumerable接口，就意味着它可以被迭代访问。 难点在于怎么自建迭代器 C# 2：利用yield语句简化迭代器利用C# 2和yield return来迭代实例集合： 123456public IEnumerator GetEnumerator()&#123; for(int index=0;index&lt;values.Length;index++) &#123; yield return values[(index+startingPoint)%values.Length]; &#125;&#125; 这是一个实现迭代器块的方法，这个方法被声明为返回一个IEnumerator接口，所以就只能使用迭代器块来实现返回类型为IEnumerable、IEnumerator等的方法。如果方法声明的返回类型是非泛型接口，那么迭代器块的生成类型(yield type)是object，否则就是泛型接口的类型参数。如：方法声明返回IEnumerable,就会得到string类型的生成类型。在迭代器块中存在try/catch或try/finally代码块时，不能在try和finally中使用yield return编写迭代器块代码实际上是在请求编译器创建一个状态机当编译器看到迭代器块时，会为状态机创建一个嵌套类型，来正确记录块中的位置，以及局部变量（包括参数）的值。这个状态机实现一下功能： 必须具有某个初始状态 每次调用MoveNext，提供下一个值之前（执行到yield return语句之前），执行GetEnumerator方法中的代码 使用Current属性时，返回生成的上一个值 知道何时完成生成值的操作，以便MoveNext返回false 迭代器的工作流程 在第一次调用MoveNext之前，CreateEnumerable不会被调用 所有工作在调用MoveNext时就完成了，获取Current的值，不执行任何代码 在yield return的位置，代码就停止执行，在下一次调用MoveNext时又继续执行 在一个方法中的不同地方可以编写多个yield return语句 代码不会在最后的yield return处结束，而是通过返回false的MoveNext调用来结束 进一步了解yield return语句临时推出了方法，知道再次调用MoveNext后继续执行，根本没有检查finally代码块的行为。迭代器块不能实现具有ref或out参数的方法yield break结束迭代器的执行,类似于普通方法中的return语句finally在迭代器块中常用于释放资源，通常与using语句配合使用 迭代器示例迭代时刻表中的日期C# 1 123for(DataTime day=timetable.StartDate; day&lt;=timetable.EndDate; day=day.AddDays(1)) C# 2​ foreach(DateTime day in timetable.DateRange)想要手动实现迭代器很麻烦，但用迭代器块就很方便。为表示时刻表的类添加一个属性： 123456789101112public IEnumerable&lt;DateTime&gt; dateRange&#123; get &#123; for(DateTime day=StartDate； day&lt;=EndDate; day=day.AddDays(1)) &#123; yield return day; &#125; &#125;&#125; 迭代文件中的行在.NET 4中，框架提供了reader.ReadLines来实现,如何自己轻松实现？C# 1 12345678using(TextReader reader=File.OpenText(filename))&#123; string line; while((line=reader.ReadLine()) != null) &#123; //针对line进行操作 &#125;&#125; 获取TextReader 管理TextReader的生命周期（using） 迭代TextReader.ReadLine返回的行 对这些行处理 生命周期管理和迭代机制都是样板代码，有两种方法改进。一。使用委托，编写一个工具方法，将阅读器和委托作为参数，为文件中的每一行调用该委托，最后关闭阅读器。二。使用迭代器一次返回文件中的一行，如下 12345678910111213141516public static IEnumerable&lt;string&gt; ReadLines(string filename) &#123; using (TextReader reader = File.OpenText(filename)) &#123; string line; while ((line = reader.ReadLine()) != null) &#123; yield return line; &#125; &#125; &#125;foreach (string line in ReadLines(@&quot;文件路径&quot;)) &#123; Console.WriteLine(line); &#125; 进一步改进：如果我们想从网络流中读取文本或使用UTF-8以外的编码格式，最简单的想法是重新修改方法签名，使其接受一个TextReader。但这个方案很糟糕，问题是，如果在第一次调用MoveNext（）之前发生了异常，就没有机会清理了。另外，若GetEnumerate人（）被调用两次，但它们使用相同的阅读器。 12345static IEnumerable&lt;String&gt; ReadLines（Func &lt;TextReader&gt; provider)&#123; using (TextReader reader=provider()) &#123; 。。。 使用迭代器块和谓词对进行延迟过滤看过linq后回来重看 CCR实现伪同步代码CCR（Concurrency and Coordination Runtime，并发和协调运行时）看完异步开发回来看 ​","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（十二）：匿名方法","slug":"深入理解C-（十二）：匿名方法","date":"2019-01-09T09:52:44.000Z","updated":"2019-01-09T09:53:05.878Z","comments":true,"path":"2019/01/09/深入理解C-（十二）：匿名方法/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（十二）：匿名方法/","excerpt":"","text":"深入理解C#（十二）*第五章（C# 2：进入快速通道的委托（下））匿名方法 使用匿名方法的内联委托操作C# 1中的问题：用特定签名来实现委托是很常见的情况。有时只需要一个委托来做一件很简单的事，但是必须创建一个完整的新方法。 匿名方法允许指定一个内联委托实例的操作，作为创建委托实例表达式的一部分。 简单的匿名方法实例：处理一个参数.NET 2.0有一个泛型委托类型Action,它的签名如下：public delegate void Action&lt;T&gt;(T obj)Action就是对T的一个实例执行某些操作。如Action可以反转字符串并打印出来，Action可以打印传给它的那个数的平方根，Action&lt;IList&gt;可以计算出传给它的所有数的平均值并打印。实例： 123456Action&lt;string&gt; printReverse = delegate (string text)&#123;char[] chars = text.ToCharArray();Array.Reverse(chars);Console.WriteLine(new string(chars));&#125;; 匿名方法的语法：delegate关键字，参数，代码块（定义对委托实例的操作）匿名方法的结果是一个委托实例，和调用普通方法一样调用委托。 1printReverse(&quot;hello world&quot;); 逆变性不适用于匿名方法：必须指定和委托类型完全匹配的参数类型 匿名方法的是实现，是在IL中为源代码中断每个匿名方法创建一个方法 一个更精简的极端例子：体现匿名方法的一般用法，即作为传给另一个方法的参数使用。 12345678List&lt;int&gt; x = new List&lt;int&gt;();x.Add(5);x.Add(10);x.Add(15);x.Add(20);x.Add(25);x.ForEach(delegate (int n) &#123; Console.WriteLine(Math.Sqrt(n)); &#125;); 匿名方法的返回值12345Predicate&lt;int&gt; isEven = delegate (int x) &#123; return x % 2 == 0; &#125;;Console.WriteLine(isEven(1));Console.WriteLine(isEven(4)); 没有必要再声明一个返回类型，因为编译器会检查是否所有可能返回值都兼容于委托类型声明的返回类型。 忽略委托参数12345678910111213141516 class IgnoredParametersAnonymousMethods&#123; static void Main() &#123; Button button = new Button(); button.Text = &quot;Click me&quot;; button.Click += delegate &#123; Console.WriteLine(&quot;LogPlain&quot;); &#125;; button.KeyPress += delegate &#123; Console.WriteLine(&quot;LogKey&quot;); &#125;; button.MouseClick += delegate &#123; Console.WriteLine(&quot;LogMouse&quot;); &#125;; Form form = new Form(); form.AutoSize = true; form.Controls.Add(button); Application.Run(form); &#125;&#125; 一般写法：button.Click+=delegate(object sender,EventArgs e){...} 匿名方法中的捕获变量匿名方法外部对变量的更改在匿名方法内部是可见的，反之亦然。 12345678910111213141516171819static void Main()&#123;string captured = &quot;before x is created&quot;;MethodInvoker x = delegate&#123; Console.WriteLine(captured); captured = &quot;changed by x&quot;;&#125;;captured = &quot;directly before x is invoked&quot;;x();Console.WriteLine(captured);captured = &quot;before second invocation&quot;;x();Console.Read();&#125; 创建委托实例不会导致执行在整个方法中，我们使用的始终是同一个captured变量 捕获变量的实际用处能简化避免专门创建一些类来存储一个委托需要处理的信息（除了作为参数传递信息之外） 1234List&lt;Person&gt; FindAllYoungerThan(List&lt;Person&gt; people,int limit)&#123; return people.FinaAll(delegate(Person person)&#123; return person.Age&lt;limit;&#125;);&#125; 我们在委托实例内部捕获了limit参数，若不支持捕获变量，就不能使用作为参数传递的limit 捕获变量的延长生存期对于一个捕获变量，只要还有任何委托实例在引用它，它就会一直存在 局部变量实例化每声明一次局部变量，它就被实例化一次。 捕获变量的使用规则和小结 只在复杂情况下使用 捕获有for或foreach语句声明的变量之前，思考委托是否需要在循环迭代结束后延续，不是则在循环内另建一个变量来复制想要的值。 若创建多个委托实例，且捕获了变量，思考是否希望它们捕捉同一个变量 如果捕获的变量不发生改变，无需担心","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（十一）：改进的委托","slug":"深入理解C-（十一）：改进的委托","date":"2019-01-09T09:51:56.000Z","updated":"2019-01-09T09:52:22.000Z","comments":true,"path":"2019/01/09/深入理解C-（十一）：改进的委托/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（十一）：改进的委托/","excerpt":"","text":"深入理解C#（十一）*第五章（C# 2：进入快速通道的委托（上）） 回顾C# 1中我们的做法总是先定义事件/委托实际要处理的方法，如： 1234static void LogKeyEvent(object sender, KeyPressEventArgs e) &#123; Console.WriteLine(&quot;LogKey&quot;); &#125; 然后new一个新的事件/委托实例，把这个方法加到委托列表中，如：​ 1button.KeyPress += new KeyPressEventHandler(LogKeyEvent); 我们总是要把委托实例实际执行的代码做参数穿给委托实例，这样绕弯子会使代码难以阅读，且使得类中填充了大量只用于委托的方法。 方法组转换C# 2支持从方法组到一个兼容委托类型的隐式转换。方法组（method group）其实就是一个方法名，可以选择添加一个目标，也就是说和C# 1中创建委托实例使用的表达式相同（含义不同，一个是类型加参数，一个是方法组）。新的隐式转换：​ 1button.KeyPress+=LogkeyEvent; 一个创建线程的代码： 1Thread t=new Thread(MyMethod); 为什么表达式如LogKeyEvent属于方法组，因为如果有重载的话，可能不止一个方法适用。隐式转换会将一个方法组转换为具有兼容签名的任意委托类型。假定有以下两个方法签名： 12void MyMethod()void MyMethod(object sender,EventArgs e) 那么在向一个ThreadStart或EventHandler赋值时，都可以将MyMethod作为方法组使用： 12ThreadStart x=MyMethod;EventHandler y=MyMethod； 对于本身已重载成可以获取一个ThreadStart或EventHandler的方法，不能把它作为方法的参数使用。同样，不能利用隐式方法组转换来转换成普通的System.Delegate类型。可用辅助方法、强制转换或中间变量来解决。 协变性和逆变性委托参数的逆变性举例说明： 123public delegate void EventHandler(object sender,EventArgs e)public delegate void KeyPressEventHandler(object sender, KeyPressEventArgs e)public delegate void MouseEventHandler(object sender,MouseEventArgs e) 有三个委托类型的签名：KeyPressEventArgs和MouseEventArgs都是从EventArgs派生利用方法组转换和委托逆变性： 123456789101112131415161718static void LogPlainEvent(object sender, EventArgs e)&#123; Console.WriteLine (&quot;An event occurred&quot;);&#125;static void Main()&#123; Button button = new Button(); button.Text = &quot;Click me&quot;; button.Click += LogPlainEvent; button.KeyPress += LogPlainEvent; button.MouseClick += LogPlainEvent; Form form = new Form(); form.AutoSize = true; form.Controls.Add(button); Application.Run(form);&#125; 用一个事件处理方法来处理所有事件。 关于事件处理方法的参数说明：第一个参数是object类型，代表事件来源；第二个参数则负责携带与事件有关的任何额外信息 在有委托参数协变性后，我们可以使用一个具有EventHandler签名的方法，作为符合约定的所有委托类型的操作。 委托返回类型的协变性举例：首先声明一个委托类型 1delegate Stream StreamFactory(); 然后声明一个方法返回一个特定的流类型。 123456789static MemoryStream GenerateSampleData()&#123; byte[] buffer = new byte[16]; for (int i = 0; i &lt; buffer.Length; i++) &#123; buffer[i] = (byte)i; &#125; return new MemoryStream(buffer);&#125; 利用协变性转换方法组 123456789101112131415static void Main()&#123; StreamFactory factory = GenerateSampleData; using (Stream stream = factory()) //调用委托 &#123; int data; while ((data = stream.ReadByte()) != -1) &#123; Console.WriteLine(data); &#125; &#125; Console.Read();&#125; 注意：委托的返回类型是stream,但声明的方法的返回类型是MemoryStream。StreamFactory factory = GenerateSampleData;这句话用到了方法组的转换，并利用返回类型的协变性来允许GenerateSampleData用于StreamFactory，等到调用委托实例时，实际返回的是委托声明的类型，也就是说返回类型已从MemoryStream协变成stream 利用协变性和逆变性，还可以基于一个委托实例来构造另一个委托实例。 12EventHandler general=new EventHandler(HandleEvent);KeyPressEventHandler key=new KeyPressEventHandler(general); 不兼容的风险可能发生在派生类中。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（十）：可空类型","slug":"深入理解C-（十）：可空类型","date":"2019-01-09T09:50:43.000Z","updated":"2019-01-09T09:51:24.884Z","comments":true,"path":"2019/01/09/深入理解C-（十）：可空类型/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（十）：可空类型/","excerpt":"","text":"深入理解C#（十）*第四章（C# 2：可空类型） C# 1中表示空值的模式 魔值：牺牲一个值来表示空值（DBNull.Value表示数据库返回null的情况，这个魔值表示所有类型的空值） 引用包装类型：直接用object作为变量类型，并根据需要进行装箱和拆箱 额外的布尔标志：使用一个普通的值类型的值，同时使用另一个布尔标志来表示值是“真正”存在还是被忽略。要么在代码中维护两个单独的变量，要么将值和标志封装到另一个值类型中。 System.Nullable&lt;T&gt;和System.NullableNullable&lt;T&gt;是一个有着值类型约束的泛型类型。T的类型称为可空类型的基础类型(underlying type)。Nullable&lt;T&gt;有两个重要属性：HasValue和Value。就是采用上面第三种实现模式。Nullable&lt;T&gt;仍为值类型，值将直接包含一个bool和一个int，而不是其他对象的引用Nullable&lt;T&gt;引入一个名为GetValueOrDefault的新方法。存在值就返回值否则返回默认值/自己指定的返回值。Nullable&lt;T&gt;覆盖了其他方法：GetHashCode,ToString和Equals。GetHashCode在没有值时返回0，ToString在没有值时返回空字符串再次强调Nullable&lt;T&gt;是一个结构（值类型),如果把它转换成引用类型，需要对它装箱调用first.Equals(second)的具体规则：​ first没有值，second为null，相等 first没有值，second不为null，不相等 first有值，second为null，不相等 否则，若first的值等于second，相等 System.Nullable类是一个静态类，只包含静态方法。提供三个有用方法： 123public static int Compare&lt;T&gt;(Nullable&lt;T&gt; n1,Nullable&lt;T&gt; n2)public static bool Equals&lt;T&gt;(Nullable&lt;T&gt; n1,Nullable&lt;T&gt; n2)public static Type GetUnderlyingType(Type nullableType) Compare使用Comparer.Default来比较两个基础值，Equals使用EqualityComparer.Default。空值与空值相等，小于其他所有值。第三个方法如果参数是一个可空类型，方法就返回它的基础类型；否则返回null。 C# 2为可空类型提供的语法糖？修饰符Nullable&lt;byte&gt;与byte?可相互转换 使用null进行赋值和比较可空转换和操作符如果一个非可空的值类型支持一个操作符或一种转换，且那个操作符或转换只涉及其他非可空的值类型时，那么对应可空的值类型也支持同样的操作符或转换。举例：int=》long，int？=》long？具体细节待看 可空逻辑对可空类型使用as操作符在C# 2之前，as只能用于引用类型。在C# 2中，也可以用于可空类型。 空合并操作符（？？）first？？second 对first进行求值； 如结果非空，该结果就是表达式的结果 否则求second的值，其结果为整个表达式的结果这个操作符还可用于可空值类型+引用类型这个操作符是右结合的 用法案例：假设有一个在线订购系统，有billing address（账单寄送地址），contact address（联系地址），以及shipping address（送货地址）等，任何用户都必须有一个billing address，但contact address是可选的。对于一个订单来说，送货地址也是可选的，默认为billing address。遇到送货问题，要找联系人时。C# 1实现：​ 123456789Address contact=user.ContactAddress;if(contact==null)&#123; contact=order.ShippingAddress; if(contact==null) &#123; contact=user.BillingAddress; &#125;&#125; C# 2改进： 123Address contact=user.ContactAddress?? order.ShippingAddress?? user.BilllingAddress; 可空类型的新奇用法尝试一个不使用输出参数的操作输出参数的常规用法：用一个返回值来判断一个操作是否成功，并用一个输出参数来返回真正的结果。返回引用类型的方法经常使用这样一种模式：失败时返回null，成功是返回非空值。但是，假如在方法执行成功的前提下，null也是一个有效的返回值，这样就不行了。 1234567ArrayList list=hash[key];if(list==null)&#123; list=new ArrayList(); hash[key]=list;&#125;list.Add(newItem); 假设HashTable和Dictionary&lt;Tkey,TValue&gt;可以获取一个委托，每次查找到一个不存在的键时就调用这个委托来添加一个新值。使用这个模式适用这种情况。使用可空类型，能将这种模式扩展至值类型。 具体实例： 1public static bool TryParse(string s, out Int32 result); 这个int的方法的传统用法如下： 12345678910int result; if (int.TryParse(&quot;Not valid&quot;, out result))&#123; Console.WriteLine(&quot;Parsed to &#123;0&#125;&quot;, result);&#125;else&#123; Console.WriteLine(&quot;Couldn&apos;t parse&quot;);&#125;Console.Read(); 如果我们用可空类型： class NullableTryParse ​ {​ static int? TryParse(string data)​ {​ int ret;​ if (int.TryParse(data, out ret))​ {​ return ret;​ }​ else​ {​ return null;​ }​ } 12345678910111213 static void Main() &#123; int? parsed = TryParse(&quot;Not valid&quot;); if (parsed != null) &#123; Console.WriteLine(&quot;Parsed to &#123;0&#125;&quot;, parsed.Value); &#125; else &#123; Console.WriteLine(&quot;Couldn&apos;t parse&quot;); &#125; &#125;&#125; 这样做的好处是它将返回值与解析是否成功封装在一个变量中，还把做和测试分离了。还有一个好处是可以和空合并操作符配合使用。小结一下：上述模式的要点在于：先定义并获取方法返回值（做），再判断返回值（测试）。如返回值是引用类型，我们可以通过判断是否为null，很容易实现这个模式，但若是值类型，就不好办了（除非我们定义一个特殊值，但这样会导致语义不明，就像魔数一样），所以就用到了可空类型，这样我们也能像使用引用类型一样，使用值类型。更好的做法：在.NET 4中包含了Tuple类型，使用元祖可以使返回值含义更明确。 空合并操作符简化比较问题背景：假设要写一个电子商务网站，且有一个产品列表。希望按流行度，价格，名称依次排序。C# 1的实现： 1234567891011121314public int Compare(Product first,Product second)&#123; int ret=second.Popularity.CompareTo(first.Popularity); if( ret !=0) &#123; return ret; &#125; ret=first.Price.CompareTo(second.Price); if(ret ！=0） &#123; return ret； &#125; return first.Name.CompareTo(second.Name);&#125; 我们往往这样写Compare方法。但若是属性返回为null，我们在比较前还要先判断非空，这样代码就太复杂了。我们可以用空合并操作符来简化代码。 C# 2 ？？操作符实现： 12345678910111213141516171819202122232425262728293031public static class PartialComparer&#123; public static int? Compare&lt;T&gt;(T first, T second) &#123; return Compare(Comparer&lt;T&gt;.Default, first, second); &#125; public static int? Compare&lt;T&gt;(IComparer&lt;T&gt; comparer,T first,T second) &#123; int ret = comparer.Compare(first, second); return ret == 0 ? new int?() : ret; &#125; public static int? ReferenceCompare&lt;T&gt;(T first, T second) where T : class &#123; return first == second ? 0 : first == null ? -1 : second == null ? 1 : new int?(); &#125; public static bool? ReferenceEquals&lt;T&gt;(T first, T second) where T : class &#123; return first == second ? true : first == null ? false : second == null ? false : new bool?(); &#125;&#125; 先实现一个用于比较的辅助类。可注意ReferenceCompare方法中的条件操作符用法。现在可以重写Compare方法： 123456789public int Compare(Product first, Product second) &#123; return PartialComparer.ReferenceCompare(first, second) ?? // Reverse comparison of popularity to sort descending PartialComparer.Compare(second.Popularity, first.Popularity) ?? PartialComparer.Compare(first.Price, second.Price) ?? PartialComparer.Compare(first.Name, second.Name) ?? 0; &#125; 最后的0指明前面所有比较都通过，这两个Product相等。也可用Comparer&lt;string&gt;.Default.Compare(first.Name,second.Name)作比较。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（九）：泛型","slug":"深入理解C-（九）：泛型","date":"2019-01-09T09:50:00.000Z","updated":"2019-01-09T09:50:23.456Z","comments":true,"path":"2019/01/09/深入理解C-（九）：泛型/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（九）：泛型/","excerpt":"","text":"深入理解C#（九）*第三章（C# 2：泛型实现参数化类型） 理解泛型类型和方法泛型方法的类型推断例子： 123static List&lt;T&gt; MakeList&lt;T&gt;(T first,T second)...List&lt;string&gt; list=MakeList&lt;string&gt;(&quot;Line 1&quot;,&quot;Line 2&quot;); 使用编译器的类型推断： 1List&lt;string&gt; list=MakeList(&quot;Line 1&quot;,&quot;Line 2&quot;); 类型约束如List等，所有类型参数都可以指定为任意类型，它们未被约束。我们想制定规则，从而判断哪些是泛型类型或泛型方法呢能接受的有效类型实参。用约束来实现。约束放在泛型方法或泛型类型声明的末尾，有上下文关键字where引入。 引用类型约束确保使用的类型实参是引用类型：必须是第一个约束struct RefSample&lt;T&gt; where T:class以这种方式约束一个类型参数后，可以使用==和！=来比较引用（包括null） 值类型约束确保使用的类型实参是值类型:class ValSample&lt;T&gt; where T:structbr&gt;设定值类型约束后，不允许使用==和！=进行比较。以上两种约束比较少用，后两者更有用。 构造函数类型约束检查类型实参是否有一个可用于创建类型实力的无参构造函数。必须是最后一个约束。public T CreateInstance() where T : new() { return new T(); }在使用工厂风格的设计模式时，这个约束非常有用。 转换类型约束指定另一个类型，类型实参必须可以通过一致性、引用或装箱隐式地转换为该类型。还可以规定一个类型实参必须可以转换为另一个类型实参。这个约束意味着“在类型参数的实例上使用指定类型的成员” 实现泛型假装T是一个真正的类型名称。额外要注意： 默认值表达式：例子：Dictionary&lt;TKey,TValue&gt;有一个TryGetValue方法：用一个输出参数来接受你打算获取的值，用boolean返回值显示是否成功。这意味着方法必须用TValue类型的值来填充输出参数。C# 2提供了默认值表达式(default value expression)。例子：以泛型方式将一个给定的值和默认值进行比较 class DefaultValueComparison {​ static int CompareToDefault(T value)​ where T : IComparable​ {​ return value.CompareTo(default(T));​ } 12345678static void Main()&#123; Console.WriteLine(CompareToDefault(&quot;x&quot;)); Console.WriteLine(CompareToDefault(10)); Console.WriteLine(CompareToDefault(0)); Console.WriteLine(CompareToDefault(-10)); Console.WriteLine(CompareToDefault(DateTime.MinValue));&#125; } 这个泛型方法规定了只能使用实现了IComparable接口的类型，这样才能为传入的值调用CompareTo（T） 类型推断只能用于泛型方法，有一个泛型类型，其中不包含任何泛型方法，怎么实现类型推断？Pair&lt;int,string&gt; pair=new Pair&lt;int,string&gt;(10,&quot;value&quot;);解决方法是使用包含泛型方法的非泛型辅助类。​ 123456789public static class Pair&#123; public static Pair&lt;T1,T2&gt; Of&lt;T1,T2&gt;(T1 first,T2 second) &#123; return new Pair&lt;T1,T2&gt;(first,second); &#125;&#125;Pair&lt;int,string&gt; pair=Pair.Of(10,&quot;value&quot;); 等到第七章再回看 直接比较如果一个类型参数是未约束的（即没有对其应用约束），那么只能在该类型的值与null比较时才能使用==和！=操作符。不能直接比较两个T类型的值。如果一个类型参数被约束成值类型，就完全不能为它使用==和！=。如果被约束成引用类型，具体比较将完全取决于类型参数被约束成什么类型。 高级泛型静态字段和静态构造函数每个封闭类型都有它自己的静态字段集同样的规则也适用于静态初始化程序和静态构造函数。 JIT(just in time即时)编译器如何处理泛型暂略 泛型迭代对集合执行的最常见操作之一是便利（迭代）所有元素。最简单的办法使用foreach语句。当需要为自己的某个类型实现迭代时，由于IEnumerable扩展了旧的IEnumerable接口，所以要实现两个不同方法：IEnumerator GetEnumerator();IEnumerator GetRnumerator(); 反射和泛型反射的一切都是围绕“检查对象及其类型”展开的。typeof可通过两种方式作用于泛型类型。一种方式是获取泛型类型定义，另一种方式是获取特定的已构造类型。typeof(Dictionary&lt;,&gt;)或typeof(Dictionary&lt;string,X&gt;) 获取泛型和已构造Type对象的各种方式​ 12345678910111213141516string listTypeName = &quot;System.Collections.Generic.List`1&quot;;Type defByName = Type.GetType(listTypeName);Type closedByName = Type.GetType(listTypeName + &quot;[System.String]&quot;);Type closedByMethod = defByName.MakeGenericType(typeof(string));Type closedByTypeof = typeof(List&lt;string&gt;);Console.WriteLine(closedByMethod == closedByName);Console.WriteLine(closedByName == closedByTypeof);Type defByTypeof = typeof(List&lt;&gt;);Type defByMethod = closedByName.GetGenericTypeDefinition();Console.WriteLine(defByMethod == defByName);Console.WriteLine(defByName == defByTypeof); 反射泛型方法 12345678910111213public static void PrintTypeParameter&lt;T&gt;()&#123;Console.WriteLine(typeof(T));&#125;static void Main()&#123;Type type = typeof(GenericMethodReflection);MethodInfo definition = type.GetMethod(&quot;PrintTypeParameter&quot;);MethodInfo constructed;constructed = definition.MakeGenericMethod(typeof(string));constructed.Invoke(null, null);&#125; 获取泛型方法定义 使用MakeGenericMethod返回一个已构造的泛型方法。 后去已构造的方法后，就可以调用了。 泛型在C#和其他语言中的一些限制为什么不能将List转换成List?泛型是不变的，但为什么数组是协变的？为了支持从JAVA中编译来的代码，因为Java有协变数组。 使用泛型辅助类解决逆变性缺乏问题 缺乏操作符约束或者数值约束解决方法： 表达式树，第九章 C# 4的动态特性，14章有例子 为什么泛型只限于类型（包括类、结构、委托和接口）和方法? 缺乏泛型属性、索引器和其他成员类型 第三章小结泛型的三个优点： 编译时的类型安全性 性能 代码的表现力IDE和编译器能提前验证代码 值类型性能上获益最大。在强类型的泛型API中，不再需要装箱和拆箱。使用泛型，代码能更清楚地表达其意图。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（八）：类型系统","slug":"深入理解C-（八）：类型系统","date":"2019-01-09T09:49:01.000Z","updated":"2019-01-09T09:49:34.394Z","comments":true,"path":"2019/01/09/深入理解C-（八）：类型系统/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（八）：类型系统/","excerpt":"","text":"深入理解C#（八）*第二章（C# 类型系统）C# 1的类型系统是静态的、显示的和安全的 静态：描述表达式的编译时类型，使用不变的数据来分析哪些操作可用。 C# 1的类型系统何时不够用.NET 1.1内建了三种集合类型： 数组–强类型–内建到语言和运行时中 System.Collections命名空间中的弱类型集合 System.Collections.Specialized命名空间中的强类型集合 引用类型的数组支持协变（covariance），只要元素的类型之间允许转换，就能隐式将一种数组类型转换成另一种 方法覆盖和接口实现不允许协变性/逆变性参数类型的逆变性：使用一个放宽限制的签名如：void Process(object x) 值类型和引用类型类是引用类型；结构是值类型数组是引用类型；枚举是值类型委托类型是引用类型；接口类型是引用类型，但可由值类型实现 变量存储 变量的值在它声明时的位置存储 局部变量的值总是存储在栈（stack）中（C# 1中完全成立，高级版本可能存在堆中） 实例变量的值总是存储在实例本身存储的地方 引用类型实例总是存储在堆（heap）中，静态变量也是。 关于引用传递和值传递无论是引用传递还是值传递，永远不会传递对象本身。详见Parameter passing in C# 关于装箱和拆箱 对于引用类型的变量，它的值永远是一个引用 对于值类型的变量，它的值永远是该值类型的一个值 int i=5;object o=i;int j=(int) o; 第二行，发生了装箱操作：运行时在堆上创建一个包含值（5）的对象，o的值是对该新对象的一个引用。该对象的值是原始值的一个副本，改变i不会改变箱内的值。 第三行，执行相反操作，拆箱。必须告诉编译器将object拆箱成什么类型。 装箱什么时候方式？为一个类型的值调用ToString、Equals或GetHashCode方法时，如果该类型没有覆盖这些方法，也发生装箱。另外，将值作为接口表达式使用时也会发生装箱。 太过频繁的装拆箱会增大程序的操作开销，还会创建数量众多的对象，加重垃圾回收器的负担。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（七）：委托","slug":"深入理解C-（七）：委托","date":"2019-01-09T09:47:56.000Z","updated":"2019-01-09T09:48:28.588Z","comments":true,"path":"2019/01/09/深入理解C-（七）：委托/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（七）：委托/","excerpt":"","text":"深入理解C#（七）*第二章（C# 1的核心基础）委托，类型系统的特征，值/引用类型 委托（delegate） 类似于C语言的函数指针 不指定一个要执行的行为，将这个行为用某种方式“包含在一个对象中” 1. 委托的构成 声明委托类型 必须有一个方法包含了要执行的代码 必须创建一个委托实例 必须调用invoke委托实例​namespace Chapter02​ {​ //声明委托类型​ delegate void StringProcessor(string input);​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Person&#123;string name;public Person(string name)&#123;this.name = name;&#125;//声明兼容的实例方法public void Say(string message)&#123;Console.WriteLine(&quot;&#123;0&#125; says: &#123;1&#125;&quot;, name, message);&#125;&#125;class Background&#123;//声明兼容发静态方法public static void Note(string note)&#123;Console.WriteLine(&quot;(&#123;0&#125;)&quot;, note);&#125;&#125;[Description(&quot;Listing 2.1&quot;)]class SimpleDelegateUse&#123;static void Main()&#123;Person jon = new Person(&quot;Jon&quot;);Person tom = new Person(&quot;Tom&quot;);//创建三个委托实例StringProcessor jonsVoice, tomsVoice, background;jonsVoice = new StringProcessor(jon.Say);tomsVoice = new StringProcessor(tom.Say);background = new StringProcessor(Background.Note);//调用委托实例jonsVoice(&quot;Hello, son.&quot;);tomsVoice.Invoke(&quot;Hello, Daddy!&quot;);background(&quot;An airplane flies past.&quot;);&#125;&#125;&#125; 具体步骤： 声明一个委托类型。 找到或写一个方法，具有和委托类型相同的签名，并能做我们想做的事情。 创建委托实例，指定在调用委托实例时，执行该方法。（创建委托实例，取决于操作使用实例方法还是静态方法。具体做法就是new一个我们声明的委托类型，把任意匹配的方法，作为参数传入） 调用委托实例，可以显示用Invoke方法调用，也可用简化语句直接调用。 类比：委托就像提前请律师打官司，声明委托类型就像指明要处理那种类型的案件，找到或写一个方法就像找到一个满足要求的律师，创建委托实例就像和律师签订协议，在需要时调用委托实例，就像遇上官司了，就要请律师出门解决。所以实际执行的方法是律师在做，委托只是提前签好协定，这样我们就可以在任何有需求的时候解决问题。 合并和删除委托实际使用时，委托实例往往有一个操作列表（invocation list）与之关联。Combine负责将两个委托实例的调用列表连接到一起，Remove负责从一个委托实例中删除另一个实例的调用列表。一般使用+和+=操作符代替Combine。注意： 委托和string一样是不易变的。Combine和String.Concat很像，合并现有实例来形成新的实例。可用-和-=简写Remove操作注意：若委托的签名有一个非void的返回类型，则Invoke的返回值是最后一个操作的返回值。除非使用GetInvocationList获取操作列表时，都显示调用某个委托，否则只能看到最后一个操作的返回值。注意：如果调用列表中断任何操作爆出一个异常，都会组织执行后续操作。 事件的简单讨论基本思想：让代码在发生某事时作出响应。注意：事件不是委托类型的字段，但C#允许使用字段风格的时间（field-like event）可以将事件看作类似属性的东西。两者都声明具有一种特定的类型，对于事件来说，是一个委托类型。(即：事件之于委托，就像属性之于字段）使用属性，实际是在调用方法。实现属性，可在方法中添加别的功能（校验机制之类）。同样订阅或取消订阅事件，实际是在调用（add和remove方法）既然能用委托实现为什么还要事件？和属性类似，事件添加了一个封装层，实现发布/订阅模式。Delegates and Events 字段风格的事件，只需要一个声明。编译器将声明转换成一个具有默认add/remove实现的事件和一个私有委托类型的字段。表面上调用一个事件，实际调用存储在字段中的委托实例。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（六）：大致了解-异步代码","slug":"深入理解C-（六）：大致了解-异步代码","date":"2019-01-09T09:45:12.000Z","updated":"2019-01-09T09:45:52.075Z","comments":true,"path":"2019/01/09/深入理解C-（六）：大致了解-异步代码/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（六）：大致了解-异步代码/","excerpt":"","text":"深入理解C#（六）*第一章（大致了解C#各个版本的特性：异步代码） C# 5特性：异步函数可以用它来中断代码执行，而不阻塞线程。 Windows Forms中有两条规范： 不能阻塞UI线程 不能在任何其他线程中访问UI元素 private async void CheckProduct(object sender, EventArgs e)​ {​ try​ {​ // Only permit one lookup at a time​ productCheckButton.Enabled = false;​ statusLabel.Text = “Checking…”;​ nameValue.Text = “”;​ priceValue.Text = “”;​ stockValue.Text = “”; 123456789101112131415161718192021222324 string id = idInput.Text; Task&lt;Product&gt; productLookup = directory.LookupProductAsync(id); Task&lt;int&gt; stockLookup = warehouse.LookupStockLevelAsync(id); Product product = await productLookup; if (product == null) &#123; statusLabel.Text = &quot;Product not found&quot;; // We don&apos;t care about the result of the stock check return; &#125; nameValue.Text = product.Name; priceValue.Text = product.Price.ToString(&quot;c&quot;); int stock = await stockLookup; stockValue.Text = stock.ToString(); statusLabel.Text = &quot;Ready&quot;; &#125; finally &#123; // However we finish this method, allow another lookup productCheckButton.Enabled = true; &#125;&#125; 新的语法：方法的async修饰符和两个await表达式 说明：现在产品目录和库存中查询产品详细信息和当前库存。等待（await）直到找到产品信息，如果目录中没有条目与给定ID对应，就退出。否则，将产品名称和价格显示在UI元素上，然后再等待获得库存信息并显示。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（五）：大致了解-COM和动态类型","slug":"深入理解C-（五）：大致了解-COM和动态类型","date":"2019-01-09T09:44:17.000Z","updated":"2019-01-09T09:44:49.652Z","comments":true,"path":"2019/01/09/深入理解C-（五）：大致了解-COM和动态类型/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（五）：大致了解-COM和动态类型/","excerpt":"","text":"深入理解C#（五）*第一章（大致了解C#各个版本的特性：COM和动态类型） C# 4特性：互操作性包括：处理旧的COM技术和在DLR（Dynamic Language Runtime，动态语言运行时）上执行全新动态语言。 简化COM互操作用COM控制让数据出现在Excel中例子： 1234567891011121314var app = new Application &#123; Visible = false &#125;;Workbook workbook = app.Workbooks.Add();Worksheet worksheet = app.ActiveSheet;int row = 1;foreach (var product in Product.GetSampleProducts().Where(p =&gt; p.Price != null))&#123;worksheet.Cells[row, 1].Value = product.Name;worksheet.Cells[row, 2].Value = product.Price;row++;&#125;workbook.SaveAs(Filename: &quot;demo.xls&quot;,FileFormat: XlFileFormat.xlWorkbookNormal);app.Application.Quit(); 与动态语言互操作问题：产品能通过WEb服务访问，但只能用Python代码。Web服务使用了Python特性来构建结果，没有声明我们要访问的属性类型。但要我们指定类型，怎么办？ 使用新的类型dynamic可以将dynamic类型隐式转换为其他类型 例子：从IronPython中获取产品列表并打印出来。 1234567ScriptEngine engine = Python.CreateEngine();ScriptScope scope = engine.ExecuteFile(@&quot;CSharp4\\FindProducts.py&quot;);dynamic products = scope.GetVariable(&quot;products&quot;);foreach (dynamic product in products)&#123;Console.WriteLine(&quot;&#123;0&#125;: &#123;1&#125;&quot;, product.ProductName, product.Price);&#125; products和product为动态类型，编译器允许我们对产品列表迭代打印，但是它不确保是否能执行成功。如果有错误，只有执行时才会知道失败。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（四）：大致了解-LINQ简介","slug":"深入理解C-（四）：大致了解-LINQ简介","date":"2019-01-09T09:43:28.000Z","updated":"2019-01-09T09:43:54.230Z","comments":true,"path":"2019/01/09/深入理解C-（四）：大致了解-LINQ简介/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（四）：大致了解-LINQ简介/","excerpt":"","text":"深入理解C#（四）*第一章（大致了解C#各个版本的特性：LINQ简介） LINQ简介LINQ（Language Integrated Query，语言集成查询）用于简化查询 查询表达式和进程内查询例子：查询所有供应商和对应产品，先连接产品和供应商，再按价格筛选，然后按先供应商名再产品名的优先级排序，最后打印每个供应商名称和产品名称 123456789101112131415List&lt;ProductWithSupplierID&gt; products = ProductWithSupplierID.GetSampleProducts();List&lt;Supplier&gt; suppliers = Supplier.GetSampleSuppliers();var filtered = from p in products join s in suppliers on p.SupplierID equals s.SupplierID where p.Price &gt; 10 orderby s.Name, p.Name select new &#123; SupplierName = s.Name, ProductName = p.Name &#125;;foreach (var v in filtered)&#123; Console.WriteLine(&quot;Supplier=&#123;0&#125;; Product=&#123;1&#125;&quot;,v.SupplierName, v.ProductName);&#125; 特性：隐式类型局部变量（implicitly typed local variable）使用var关键字说明，编译器根据变量的初始值推断其类型 LINQ to XML例子： 12345678910111213141516171819XDocument doc = XDocument.Load(&quot;data.xml&quot;);var filtered = from p in doc.Descendants(&quot;Product&quot;) join s in doc.Descendants(&quot;Supplier&quot;) on (int)p.Attribute(&quot;SupplierID&quot;) equals (int)s.Attribute(&quot;SupplierID&quot;) where (decimal)p.Attribute(&quot;Price&quot;) &gt; 10 orderby (string)s.Attribute(&quot;Name&quot;), (string)p.Attribute(&quot;Name&quot;) select new &#123; SupplierName = (string)s.Attribute(&quot;Name&quot;), ProductName = (string)p.Attribute(&quot;Name&quot;) &#125;;foreach (var v in filtered)&#123; Console.WriteLine(&quot;Supplier=&#123;0&#125;; Product=&#123;1&#125;&quot;, v.SupplierName, v.ProductName);&#125;&#125; LINQ to SQL例子： 123456789101112131415161718using (LinqDemoDataContext db = new LinqDemoDataContext()) &#123; var filtered = from p in db.Products join s in db.Suppliers on p.SupplierID equals s.SupplierID where p.Price &gt; 10 orderby s.Name, p.Name select new &#123; SupplierName = s.Name, ProductName = p.Name &#125;; foreach (var v in filtered) &#123; Console.WriteLine(&quot;Supplier=&#123;0&#125;; Product=&#123;1&#125;&quot;, v.SupplierName, v.ProductName); &#125; &#125; 虽然查询是用C#代码来表示的，但却是用SQL执行。实际发出一个数据库请求，被转化为SQL查询。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（三）：大致了解-处理未知数据","slug":"深入理解C-（三）：大致了解-处理未知数据","date":"2019-01-09T09:42:23.000Z","updated":"2019-01-09T09:43:00.268Z","comments":true,"path":"2019/01/09/深入理解C-（三）：大致了解-处理未知数据/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（三）：大致了解-处理未知数据/","excerpt":"","text":"深入理解C#（三）*第一章（大致了解C#各个版本的特性：处理未知数据） 表示未知的值类型问题描述：decimal表示产品价格，是值类型，若某个产品价格未知，该如何表示？（若是引用类型，可用null表示） C# 1解决方案： 给decimal建一个引用类型包装器 用一个单独的bool标志，表示价格是否已知 使用一个魔数（magic value）来表示，如decimal.MinValue C# 2:Nullable结构，提供一些语法糖来简化。例子： 123456decimal? price;public decimal? Price&#123; get&#123;return price;&#125; private set&#123;price=value;&#125;&#125; Price=null;null现在表示“没有其他数据的任意可空类型的一个特殊值”所有引用类型和基于Nullable的类型为可空类型与null值作比较，结果总是false 可选参数和默认值问题描述：对一个方法或构造函数，有时我们会自己设定参数，这时往往需要重构来减少参数量，并设置我们的默认值。有什么方法能简化？ C#4：可选参数和默认值：例子： 12345public Product(string name,decimal? price=null)&#123; this.name=name; this.price=price;&#125; 这里对于可空类型的参数price，我们设定他为可选参数，默认值为null，这样我们就不需要重载这个构造函数，但我们依然能使用形如：Product p=new Product(&quot;Unreleased product&quot;);这样的方式构造一个Product实例，因为price被设定有默认值null。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（二）：大致了解-排序和过滤","slug":"深入理解C-（二）：大致了解-排序和过滤","date":"2019-01-09T09:41:23.000Z","updated":"2019-01-09T09:42:04.742Z","comments":true,"path":"2019/01/09/深入理解C-（二）：大致了解-排序和过滤/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（二）：大致了解-排序和过滤/","excerpt":"","text":"深入理解C#（二）*第一章（大致了解C#各个版本的特性：排序和过滤） 按字母顺序打印产品列表按名称排序，找出最贵的产品这里只摘录C# 3的实现方法 Lambda表达式使用Comparison进行排序123456List&lt;Product&gt; products=Product.GetSampleProducts(); products.Sort((x,y)=&gt;x.Name.CompareTo(y));foreach(Product product in products)&#123; Console.WriteLine(product);&#125; 使用一个扩展方法对List进行排序12345List&lt;Product&gt; products=Product.GetSampleProducts();foreach(Product product in products.OrderBy(p=&gt;p.Name))&#123; Console.WriteLine(product);&#125; 查询集合C# 1需要循环，测试每个元素，操作符合条件的元素（这里是打印元素） C# 2测试和打印分开 1234567List&lt;Product&gt; products=Product.GetSampleProducts();Predicate&lt;Product&gt; test=delegate(Product p) &#123; return p.Price&gt;10m;&#125;;List&lt;Product&gt; matches=products.FinaAll(test);Action&lt;Product&gt; print=Console.WriteLine;matces.ForEach(print); 用FinaAll和ForEach分解问题另一个版本： 123List&lt;Product&gt; products=Product.GetSampleProducts();products.FindAll(delegate(Product p)&#123;return p.Price&gt;10;&#125;&#125;. .ForEach(Console.WriteLine); C# 3用Lambda表达式来测试 12345List&lt;Product&gt; products=Product.GetSampleProducts();foreach(Product product in products.Where(p=&gt;p.Price&gt;10))&#123; Console.WriteLine(product);&#125; 小结 C# 1，传统方法 C# 2, 匿名方法：有助于问题的分离性（将测试和打印分开） C# 3， Lambda表达式：增强了可读性","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（一）：大致了解-数据类型","slug":"深入理解C-（一）：大致了解-数据类型","date":"2019-01-09T09:39:12.000Z","updated":"2019-01-09T09:40:47.054Z","comments":true,"path":"2019/01/09/深入理解C-（一）：大致了解-数据类型/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（一）：大致了解-数据类型/","excerpt":"","text":"深入理解C#（一）*第一章（大致了解C#各个版本的特性：数据类型） 产品/名称/价格的例子C# 1实现1234567891011121314151617181920212223242526public class Product&#123;string name;public string Name&#123; get &#123; return name;&#125; &#125;decimal price;public decimal Price &#123; get &#123; return price; &#125;&#125;public Product(string name,decimal price)&#123; this.name=name; this.price = price;&#125;public static ArrayList GetSample()&#123; ArrayList list = new ArrayList(); list.Add(new Prodect(&quot;west side&quot;,9.99m)); list.Add(new Prodect(&quot;Assassins&quot;,14.99m)); return list;&#125;public override string ToString()&#123; return string.Format(&quot;&#123;0&#125;: &#123;1&#125;&quot;,name,price);&#125; 存在以下问题： ArrayList 没有 提供 与其 内部 内容 有关 的 编译 时 信息。 不慎 在 GetSampleProducts 创建 的 列表 中 添加 一个 字符串 是 完全 有可能 的， 而 编译器 对此 没有 任何 反应。(例如list.Add(&quot;this is a string&quot;);编译器不能发现错误） 代码 中为 属性 提供 了 公共 的 取值 方法， 这 意味着 如果 添加 对应 的 赋值 方法， 那么 赋值 方法 也 必须 是 公共 的。 用于 创建 属性 和 变量 的 代码 很复杂—— 封装 一个 字符串 和 一个 十进制 数 应该 是一 个 十分 简单 的 任务， 不该 这么 复杂。 C# 2实现123456public class Product&#123;string name;public string Name&#123; get &#123; return name;&#125; private set &#123; name=value;&#125; } ​ 123456789101112131415161718192021decimal price;public decimal Price &#123; get &#123; return price; &#125;&#125;public Product(string name,decimal price)&#123; this.name=name; this.price = price;&#125;public static List GetSample()&#123; List&lt;Product&gt; list = new List(); list.Add(new Prodect(&quot;west side&quot;,9.99m)); list.Add(new Prodect(&quot;Assassins&quot;,14.99m)); return list;&#125;public override string ToString()&#123; return string.Format(&quot;&#123;0&#125;: &#123;1&#125;&quot;,name,price);&#125; C# 2提出泛型List list = new List();且属性拥有私有赋值方法 private set { name=value;} 这样就解决了C# 1中前两个问题 C# 3实现特性1：自动实现的属性和简化的初始化 123public class Product&#123;public string Name&#123; get; private set; } ​ 12345678910111213141516171819202122public decimal Price &#123; get; private set; &#125;public Product(string name,decimal price)&#123; Name=name; Price = price;&#125;Product() &#123;&#125;public static List GetSample()&#123; return new List&#123; new Prodect&#123; Name=”West Side&quot;,Price=9.99m&#125;, new Prodect&#123;Name=&quot;Assassins&quot;, Price=14.99m&#125; &#125;;&#125;public override string ToString()&#123; return string.Format(&quot;&#123;0&#125;: &#123;1&#125;&quot;,Name,Price);&#125; 用属性代替变量，删除了所有与变量关联的代码，在类中处处使用属性，增强了一致性。有一个私有的无参构造函数，用于基于属性的初始化。 C# 4实现为了移除易变形,使用只读属性在调 用 构造 函数 时 指定 实 参 的 名称，关于只读属性 readonly是一个用于以下三种上下文的修饰符： 在字段定义中：readonly表示这个字段的实例化只能发生在变量声明时在所属类的构造器中 在只读段落（readonly struct）中：为一个struct加上readonly表示这个struct是不变的（immutable）。 在方法返回ref readonly中，表示这个方法返回一个reference，这个ref不可写 using System.Collections.Generic;​ public class Product​ {​ readonly string name;​ public string Name{ get { return name;} } 1234567891011121314151617181920212223readonly decimal price; public decimal Price &#123; get&#123;return price;&#125; &#125;public Product(string name,decimal price)&#123; this.name=name; this.price = price;&#125;Product() &#123;&#125;public static List GetSample()&#123; return new List&#123; new Prodect&#123; name:&quot;West Side&quot;,price:9.99m&#125;, new Prodect&#123;name:&quot;Assassins&quot;, price:14.99m&#125; &#125;;&#125;public override string ToString()&#123; return string.Format(&quot;&#123;0&#125;: &#123;1&#125;&quot;,name,price);&#125; 指定实参名称的好处是：在方法或构造函数包含多个参数时，使代码更清楚。另外可以不按顺序添加参数，而按照名称添加。这是C# 4为每个方法或构造函数自动添加的，直接使用。 小结一下：除了用到readonly的时候，大部分时候选用C# 3的属性自动实现的特性，隐藏变量，在方法中始终使用属性，保持一致性。对于拥有多个复杂参数的函数或构造函数，用命名实参来调用方法。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"C#review补档","slug":"C-review","date":"2019-01-08T22:21:25.000Z","updated":"2019-01-08T22:36:09.860Z","comments":true,"path":"2019/01/08/C-review/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/08/C-review/","excerpt":"","text":"C#回顾与java明显不同 WriteLine() 文件名可以不同于类的名称 动态（Dynamic）类型您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。 声明动态类型的语法：dynamic &lt;variable_name&gt; = value; 指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。 常量是使用 const 关键字来定义的 ? : 运算符我们已经在前面的章节中讲解了 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下：Exp1 ? Exp2 : Exp3; for(;;) 结构来表示一个无限循环。 return 语句可用于只从函数中返回一个值。但是，可以使用 输出参数 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。 关键字 out 在 C# 中，使用 ref 关键字声明引用参数。 数组：double[] balance = new double[10]; foreach (int j in n ) C# 参数数组:params 关键字 当声明一个方法时，您不能确定要传递给函数作为参数的参数数目在使用数组作为形参时，C# 提供了 params 关键字，使调用数组为形参的方法时，既可以传递数组实参，也可以只传递一组数组。params 的使用格式为：public 返回类型 方法名称( params 类型名称[] 数组名称 ) C# 中的析构函数类的 析构函数 是类的一个特殊的成员函数，当类的对象超出范围时执行。析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。 注意点 C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\\）当作普通字符对待，比如：string str = @&quot;C:\\Windows&quot;;等价于：string str = &quot;C:\\\\Windows&quot;; Console.ReadLine() 只接受字符串格式的数据。 可空类型：在处理数据库和其他包含可能未赋值的元素的数据类型时，将 null 赋值给数值类型或布尔型的功能特别有用：&lt; data_type&gt; ? &lt;variable_name&gt; = null; 我们可以使用 static 关键字把类成员定义为静态的。当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本。关键字 static 意味着类中只有一个该成员的实例。 您也可以把一个成员函数声明为 static。这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在。 抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。 待详细看 namespace命名空间:using System;命名空间的设计目的是为了提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。 可空类型 多维数组和交错数组:C# 支持多维数组。多维数组又称为矩形数组。交错数组是数组的数组。 Array 类是 C# 中所有数组的基类，它是在 System 命名空间中定义。Array 类提供了各种用于数组的属性和方法。直接调用array中的方法能实现数组的逆转和排序等 结构在 C# 中，结构是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。struct 关键字用于创建结构。 动态多态性 委托（delegate)C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。 委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 System.Delegate 类。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"2018-7-26-JavaEE-WEB-2","slug":"2018-7-26-JavaEE-WEB-2","date":"2018-07-26T21:01:27.000Z","updated":"2019-01-08T22:07:06.220Z","comments":true,"path":"2018/07/26/2018-7-26-JavaEE-WEB-2/","link":"","permalink":"https://xiaotong1996.github.io/2018/07/26/2018-7-26-JavaEE-WEB-2/","excerpt":"","text":"JAVA EE WEB学习（二）创建第一个Servlet Servlet作用 直接处理和响应用户请求 将处理工作委托给应用中其他部分的类 WEB容器会有一个或多个Servlet，用于处理JSP、显示目录列表、访问静态资源 继承的servlet类 继承HttpServlet 接收HttpServletRequest和HttpServletResponse参数 简单例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Demo3 extends HttpServlet &#123; private static final String DEFAULT_USER=&quot;Guest&quot;; /** * Constructor of the object. */ public Demo3() &#123; super(); &#125; /** * Destruction of the servlet. &lt;br&gt; */ public void destroy() &#123; super.destroy(); // Just puts &quot;destroy&quot; string in log // Put your code here System.out.println(this.getServletInfo()); System.out.println(&quot;fin&quot;); &#125; /** * The doGet method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to get. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String user =request.getParameter(&quot;user&quot;); if(user==null) &#123; user=Demo3.DEFAULT_USER; &#125; response.setContentType(&quot;text/html&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); PrintWriter out = response.getWriter(); out.append(&quot;&lt;!DOCTYPE HTML&gt;\\r\\n&quot;) .append(&quot;&lt;HTML&gt;\\r\\n&quot;) .append(&quot; &lt;HEAD&gt;\\r\\n&quot;) .append(&quot; &lt;TITLE&gt;A Servlet&lt;/TITLE&gt;\\r\\n&quot;) .append(&quot; &lt;/HEAD&gt;\\r\\n&quot;) .append(&quot; &lt;BODY&gt;\\r\\n&quot;) .append(&quot; Hello, &quot;).append(user).append(&quot;!&lt;br/&gt;&lt;br/&gt;\\r\\n&quot;) .append(&quot; &lt;form action=\\&quot;demo3\\&quot; method=\\&quot;POST\\&quot;&gt;\\r\\n&quot;) .append(&quot; Enter your name:&lt;br/&gt;\\r\\n&quot;) .append(&quot; &lt;input type=\\&quot;text\\&quot; name=\\&quot;user\\&quot;/&gt;&lt;br/&gt;\\r\\n&quot;) .append(&quot; &lt;input type=\\&quot;submit\\&quot; value=\\&quot;Submit\\&quot;/&gt;\\r\\n&quot;) .append(&quot; &lt;/form&gt;\\r\\n&quot;) .append(&quot; &lt;/BODY&gt;\\r\\n&quot;) .append(&quot;&lt;/HTML&gt;\\r\\n&quot;); &#125; /** * The doPost method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to post. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125; /** * Initialization of the servlet. &lt;br&gt; * * @throws ServletException if an error occurs */ public void init() throws ServletException &#123; // Put your code here System.out.println(&quot;start&quot;); System.out.println(this.getServletName()); &#125;&#125; 注意点 init方法在构造完成之后，响应第一个请求之前调用 调用init方法时，Servlet中所有属性都已设置完，提供了对ServletConfig和SercletContext对象的访问。 可以使用init方法读取属性文件或使用JDBC连接数据库 destory方法在Servlet不再接受请求之后立即调用，即web应用程序被停止或卸载，或Web容器关闭时。因此：应该使用destory方法清理servlet持有的资源 配置可部署的Servlet 在web.xml中部署，一般IDE会在创建时自动部署。 12345&lt;servlet&gt; ..... ..... &lt;load-on-startup&gt;x&lt;/load-on-startup&gt;&lt;/servlet&gt; Servlet按照x大小顺序启动，越小优先级越高。 将Servlet映射到URL&lt;servlet-name&gt;对应&lt;url-pattern&gt;一个servlet可以映射到多个url 了解doGet、doPost和其他方法HttpServletRequest 功能：从客户端发送的请求中获取参数。参数有两种形式：查询参数和请求正文（post请求）。查询参数在HTTP请求的第一行数据中如GET /index.jsp?id=412&amp;category=Books HTTP/1.1中有两个查询参数:id和category 或 作为post变量保存在请求正文中 获取请求参数：方法getParameter返回参数单个值，或多个参数第一个值；getParameterValues返回参数值的数组；getParameterMap返回包含所有参数名值对；getparameterNames返回所有可用参数的名字的枚举。后两种方法一般用于遍历所有请求参数。 确定与请求内容相关的信息：getContentType返回请求的内容类型；getContentLength返回请求正文长度。 读取请求的内容：getInputStream读二进制格式；BufferedReader读基于字符编码。不要在同一请求上同时使用这两种方法；不要在含post变量的请求上使用这些方法 获取请求特有的数据getRequestURL：返回完整URL；getRequestURI：返回服务器路径；getServletPath：只返回Servlet映射的URL; HttpServletResponse 功能：提供了对响应中与HTTP协议相关属性的访问。可用于：设置响应头、编写相应正文、重定向请求、设置HTTP状态码等 编写响应正文：将内容输出到响应正文中。getOutputStream和getWritter都可以向响应中输出数据。不要对同一响应对象同时使用这两种方法。 设置内容类型或编码格式：使用setContentType和setCharacterEncoding方法。必须放在getWritter方法之前，否则返回到writer使用容器默认编码。 设置头和其他响应属性：暂略 使用初始化参数配置应用程序使用上下文初始化参数 在web.xml文件中用&lt;context-param&gt;标签声明上下文初始化参数 在&lt;servlet&gt;外部 在Servlet代码中获得和使用这些参数：先获得servletcontext（getServletContext），用这个实例的getInitParameter方法，参数为param-name可得到param-value。 使用servlet初始化参数 将&lt;init-param&gt;添加到&lt;servlet&gt;内部 在Servlet代码中获得和使用这些参数：先获得ServletConfig（getServletConfig），用这个实例的getInitParameter方法，参数为param-name可得到param-value。 通常用这种方式改变数据库服务器的IP地址 通过表单上传文件","categories":[],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://xiaotong1996.github.io/tags/JavaEE/"}]},{"title":"2018-7-25-JavaEE-WEB-1","slug":"2018-7-25-JavaEE-WEB-1","date":"2018-07-25T21:01:27.000Z","updated":"2019-01-08T22:10:15.207Z","comments":true,"path":"2018/07/25/2018-7-25-JavaEE-WEB-1/","link":"","permalink":"https://xiaotong1996.github.io/2018/07/25/2018-7-25-JavaEE-WEB-1/","excerpt":"","text":"JAVA EE WEB学习（一）基本结构 Servlet等 servlet：接收响应HTTP请求 过滤器：拦截发送给servlet的请求，用于：数据格式化，对返回的数据压缩、认证和授权 监听器：通知代码多种事件，如：程序启动、关闭，HTTP会话创建和销毁 JavaServer Pages/JSP：创建图形用户界面 目录结构和归档文件WAR Java归档文件：JAR Java EE WEB归档文件：WAR ) 部署描述符 用于描述Web应用程序的元数据，为服务器部署和运行Web应用程序提供指令。 来自于/WEB-INF/web.xml 包含Servlet、监听器和过滤器的定义+HTTP会话、JSP和应用程序的配置选项。 可用注解配置Web应用程序 类加载器架构（ClassLoader) Java SE 平台中，java.*类加载到根类加载器-&gt;JRE中的扩展JAR加载到扩展类加载器-&gt;其他所有类加载到Class Loader 双亲优先类加载委托模式：低级别加载器申请加载一个类时，将委托不断向上传递至根加载器，确认成功。未能找到，则从自己的JAR文件和目录中尝试加载。 Java EE WEb中，使用子女优先类加载委托模式：公共的服务器类加载器给每个WEB应用程序分配一个自由的相互隔离的类加载器。在自己无法加载某个类时，请求它的父类加载器帮助加载。","categories":[],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://xiaotong1996.github.io/tags/JavaEE/"}]},{"title":"Java POI开发小结","slug":"2018-07-02-Apache-POI","date":"2018-07-02T09:38:03.000Z","updated":"2019-01-10T22:13:35.362Z","comments":true,"path":"2018/07/02/2018-07-02-Apache-POI/","link":"","permalink":"https://xiaotong1996.github.io/2018/07/02/2018-07-02-Apache-POI/","excerpt":"","text":"关于POI以及一些想法Apache POI是Apache软件基金会提供的100％开源库。大多数中小规模的应用程序开发主要依赖于Apache POI（HSSF+ XSSF）。它支持Excel 库的所有基本功能; 然而，呈现和文本提取是它的主要特点。 官网链接 Java Excelapi有很多，除了Apahce POI，网上教程较多的Jexcel等。虽然没有使用过其他java excelapi，就本人使用Apahce POI开发感受和其他人的提醒，能用VB操作excel就尽量不要用java了。 Apache POI提供的基本功能，简单的读写ｅｘｃｅｌ文档没有问题，但是没有实现复制单元格(cell)，复制电子表格(Sheet)等功能（也有可能提供了但我没找到，毕竟没有很详细地完整看完官方Guide）。学习基本功能和了解POI实现机制，可以看上面官网链接或易百中文教程。 我在下面会列出一些我在开发时自己编写的ＰＯＩ工具类中一些常用函数，具体代码可以在我的GitHub JavaPOI项目中找到。 代码实现获取有效行数123456789101112131415161718192021222324/******************************************************** * function : count the number of valid rows in a given sheet * ******************************************************* * parameters: * wb : workbook which contains the sheet we want * indexSheet : the index of the sheet in the xb (start from 0) *************************************************************** */ public static int getSheetRowNumber(XSSFWorkbook wb,int indexSheet) &#123; XSSFSheet sheet=wb.getSheetAt(indexSheet); int count=0; int begin = sheet.getFirstRowNum(); int end = sheet.getLastRowNum(); for (int i = begin; i &lt;= end; i++) &#123; if (null == sheet.getRow(i)|| getCellValue(sheet.getRow(i).getCell(0)) == \"\" || null==sheet.getRow(i).getCell(0)) &#123; continue; &#125; else count++; &#125; return count; &#125; 列编号(ABC…)与数字(123…)的转换1234567891011121314151617181920212223242526272829303132333435363738/********************************************************** * Excel column index begin 1 * @param colStr * @param length * @return **********************************************************/ public static int excelColStrToNum(String colStr, int length) &#123; int num = 0; int result = 0; for(int i = 0; i &lt; length; i++) &#123; char ch = colStr.charAt(length - i - 1); num = (int)(ch - 'A' + 1) ; num *= Math.pow(26, i); result += num; &#125; return result; &#125; /** * Excel column index begin 1 * @param columnIndex * @return */ public static String excelColIndexToStr(int columnIndex) &#123; if (columnIndex &lt;= 0) &#123; return null; &#125; String columnStr = \"\"; columnIndex--; do &#123; if (columnStr.length() &gt; 0) &#123; columnIndex--; &#125; columnStr = ((char) (columnIndex % 26 + (int) 'A')) + columnStr; columnIndex = (int) ((columnIndex - columnIndex % 26) / 26); &#125; while (columnIndex &gt; 0); return columnStr; &#125; 在不同工作簿(workbook)间，复制一个区域的单元格并保留格式，设置行宽12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/******************************************************** * function : copy a part of cells in different workbooks * ******************************************************* * @param: * xbIn : the resource workbook * xbOut : the destination workbook * indexSheetIn : the index of the sheet in the xbIn (start from 0) * indexSheetOut : the index of the sheet in the xbOut (start from 0) * rowInStart : the number of the first row that we need in the indexSheetIn ( start from 1 ) * rowInEnd : the number of the last row that we need in the indexSheetIn ( start from 1 ) * colInStart : the number of the first column that we need in the indexSheetIn ( start from 1, represent A in the sheet ) * colInEnd : the number of the last column that we need in the indexSheetIn ( start from 1, represent A in the sheet ) * rowOutStart : the number of the first row that we want to put cells in the indexSheetOut ( start from 1 ) * colOutStart : the number of the first column that we want to put cells in the indexSheetOut ( start from 1, represent A in the sheet ) * *******************************************************/ public static boolean copyCells(XSSFWorkbook wbIn,XSSFWorkbook wbOut,int indexSheetIn,int indexSheetOut, int rowInStart,int colInStart,int rowInEnd,int colINEnd,int rowOutStart,int colOutStart ) &#123; XSSFSheet sheetIn=wbIn.getSheetAt(indexSheetIn); XSSFRow rowIn; XSSFCell cellIn; XSSFCellStyle cellStyleIn; String cellInValue; XSSFSheet sheetOut=wbOut.getSheetAt(indexSheetOut); XSSFRow rowOut; XSSFCell cellOut; XSSFCellStyle cellStyleOut; int rowNum=rowInEnd-rowInStart; int colNum=colINEnd-colInStart; for(int i=0;i&lt;rowNum+1;i++) &#123; rowIn=sheetIn.getRow(rowInStart+i-1); rowOut = sheetOut.createRow(rowOutStart+i-1); //set the copied row&apos;s height rowOut.setHeight(rowIn.getHeight()); for(int j=0;j&lt;colNum+1;j++) &#123; cellIn=rowIn.getCell(colInStart+j-1); if(cellIn!=null) &#123; cellInValue=getCellValue(cellIn); cellOut=rowOut.createCell(colOutStart+j-1); cellStyleIn=cellIn.getCellStyle(); cellStyleOut=wbOut.createCellStyle(); cellStyleOut.cloneStyleFrom(cellStyleIn); cellOut.setCellStyle(cellStyleOut); cellOut.setCellValue(cellInValue); &#125; &#125; &#125; //in order to deal with merged regions java.util.List&lt;CellRangeAddress&gt; regions=sheetIn.getMergedRegions(); for(CellRangeAddress cellRangeAddress : regions) &#123; if(cellRangeAddress.getFirstColumn()&gt;=colInStart-1&amp;&amp; cellRangeAddress.getLastColumn()&lt;=colINEnd-1&amp;&amp; cellRangeAddress.getFirstRow()&gt;=rowInStart-1&amp;&amp; cellRangeAddress.getLastRow()&lt;=rowInEnd-1) &#123; int diffrow=rowOutStart-rowInStart; int diffcol=colOutStart-colInStart; int firstRow=cellRangeAddress.getFirstRow()+diffrow; int firstCol=cellRangeAddress.getFirstColumn()+diffcol; int lastRow=firstRow+cellRangeAddress.getLastRow()-cellRangeAddress.getFirstRow(); int lastCol=firstCol+cellRangeAddress.getLastColumn()-cellRangeAddress.getFirstColumn(); CellRangeAddress cellRangeAddressNew=new CellRangeAddress(firstRow, lastRow, firstCol, lastCol); sheetOut.addMergedRegion(cellRangeAddressNew); &#125; &#125; //set the copied column&apos;s width for(int columnIndex=colInStart-1;columnIndex&lt;=colINEnd-1;columnIndex++) &#123; int width=sheetIn.getColumnWidth(columnIndex); sheetOut.setColumnWidth(columnIndex, width); &#125; return true; &#125; 需要注意的 在linux环境下，使用LibreOffice Calc，虽然在给每个电子表格(sheet)命名时，无论代码中还是软件中，名称可以包含空格或特殊字符，但用apahce poi获取sheet名时，只会读到空格或特殊符号之前的部分。我的解决方法是在创建每个sheet时统一用横杠(-)代替空格和特殊字符。 对于合并单元格(merged region)，好的做法是在同一个函数中先把该表中所有要合并的单元格存到cellRangeAddress列表中，再进行复制之类的操作，避免在多个函数反复添加合并单元格。 自动设置列宽方法autoSizeColumn，对于合并单元格不能很好适用，建议还是自己设置。 在设置格式时，LibreOffice Calc中形如=$表名.单元格编号。但在java POI中形式为cell.setcellformula(表名!单元格编号)","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://xiaotong1996.github.io/tags/Java/"},{"name":"Apache POI","slug":"Apache-POI","permalink":"https://xiaotong1996.github.io/tags/Apache-POI/"}]},{"title":"WEB学习-Bootstrap框架学习","slug":"2018-02-21-WEB-Bootstrap-learning","date":"2018-02-19T23:00:00.000Z","updated":"2019-01-08T21:51:18.151Z","comments":true,"path":"2018/02/20/2018-02-21-WEB-Bootstrap-learning/","link":"","permalink":"https://xiaotong1996.github.io/2018/02/20/2018-02-21-WEB-Bootstrap-learning/","excerpt":"","text":"[TOC] Grid system(网格系统) 每一行rows应放在.container(fixed-width)或.container-fluid(full-width)中 使用rows来创建水平列组(groupes of columns) 内容放在column中，column是rows的子类 Chrome开发者工具ctrl+shift+i 应用框架要将 bootstrap CSS 应用于 bootstrap-prestructure.html 文件，需要：将 bootstrap-prestructure.html 文件移至你的 bootstrap 目录。打开 HTML 文件，在母体元素下方的 head 元素中添加一条指向 bootstrap CSS 文件的链接：&lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;&gt; 保存修改要将你在开发者工具中对 HTML 所做的更改保存至你的 HTML 文件，只需右键单击或 ctrl + 单击 元素，然后选择“复制为 HTML”，然后用复制的文本替换你文件中的 HTML。 响应式页面响应式图片加上class=&quot;img-responsive&quot; alt=&quot;Responsive image&quot; Bootstrap排版文字对齐加上class=&quot;text-left&quot;表示左对齐文字装换加上class=&quot;text-uppercase&quot;将文字变为大写可添加在文字类型如h1，h3，最好是直接添加在包含他们的div上 自定义CSS在/css文件夹下添加style.css文件从大到小对网页中的元素添加定制","categories":[],"tags":[{"name":"WEB入门","slug":"WEB入门","permalink":"https://xiaotong1996.github.io/tags/WEB入门/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://xiaotong1996.github.io/tags/Bootstrap/"}]},{"title":"WEB学习-HTML和CSS入门","slug":"2018-02-20-WEB-learning","date":"2018-02-19T23:00:00.000Z","updated":"2019-01-08T21:49:29.807Z","comments":true,"path":"2018/02/20/2018-02-20-WEB-learning/","link":"","permalink":"https://xiaotong1996.github.io/2018/02/20/2018-02-20-WEB-learning/","excerpt":"","text":"目录{:toc} WEB项目文件结构 常用网页框架设计 1个100%页面宽度的行类(.row) 占页面1/12-12/12的列类(.col-n)n为1-12的数字CSS类前有. flex 为了让行中列元素并排显示，需要给row加上display:flex 关于flex，查看flex,flexbox,flex-wrap 负空间（space） margin 外边距 padding 内边距 加上后缀-top -right -left -bottom具体设置border 边框 溢出 overflow:auto; 响应例子：@media only screen and (max-width:500px) and (orientation:landscape) @media实现页面响应 only‘用于兼容旧式浏览器 screen指示这个响应用于所有显示设备print用于响应当用户要打印页面时 and加上条件 orientation指的是手机方向：landscape mode横向，portrait mode纵向 浏览器兼容在head中添加normalize.css样式表，该表格google搜索下载 占位图片 &lt;img src=&quot;http://placehold.it/nxn&quot; &lt;img src=&quot;http://placekitten.com/n/n&quot; 字体 在Google Fonts中找到字体 在html的head中加入链接&lt;link href=&quot;https://fonts.googleapis.com/css?family=Roboto&quot; rel=&quot;stylesheet&quot;&gt; 在css中为需要使用该字体的元素添加font-family: &#39;Roboto&#39;, sans-serif;","categories":[],"tags":[{"name":"WEB入门","slug":"WEB入门","permalink":"https://xiaotong1996.github.io/tags/WEB入门/"}]},{"title":"Git 学习","slug":"2018-02-06-Git-learning","date":"2018-02-05T23:00:00.000Z","updated":"2019-01-08T21:43:39.022Z","comments":true,"path":"2018/02/06/2018-02-06-Git-learning/","link":"","permalink":"https://xiaotong1996.github.io/2018/02/06/2018-02-06-Git-learning/","excerpt":"","text":"目录{:toc} 基础以在GitLab上创建一个project为例 1. SSH秘钥生成SSH秘钥指令：$ ssh-keygen -t rsa -C &quot;votre.email@telecom-sudparis.eu&quot; -b 4096保存在$HOME/.ssh/id_rsa.pub将获得的SSH秘钥填入GitLab网站SSH秘钥用于GitLab网站识别Unix账号 2. 创建project并添加合作者命名规则：课程+年份+创作者给合作者Master权限 3. 克隆project到本地git clone git@gitlab.tem-tsp:votreprenom.votrenom/votrenomdeproject.git 4. 查看git状态git status 5. 创建第一个文件README.md并提交 git add README.md git commit -m &quot;注释&quot; git push origin master 其他合作者git pull origin git add：i） git add . 或 git add --all 提交所有修改 git commit：i） git commit后会生产一个hash码，用于标记此次commit操作 git push：i） git push默认将master上传ii）origin是远程仓库名，master是分支名 git pull：i）当有其他人想master分支推送了更新，则服务器上的master向前推进，本地的Master落后服务器版本，需要运行 git fetch来同步本地并用git merge合并，或直接用git pull。git pull=git fetch + git merge 分支操作branch 1. 创建分支git checkout -b module1 i） 创建并转到module1分支ii）git checkout 分支名 转到已存在的分支 2. 查看分支git branch i）一般而言，Master分支是默认创建的。但若是在项目一开始，即项目为空时，创建分支，会丢失master分支。 3. 在分支上进行操作 与在基础部分操作相同 在每个分支上做的add,commit操作是独立的 4. 查看日志 git log --graph --oneline --decorate 使用工具gitg/gitk 5. 合并（Fusion）分支 转到Mastergit checkout master git merge --no-ff moudle1 -m &quot;Merge branch &#39;modele1&#39;&quot; i) 有--no-ff则moudle1会保留，没有则不保留module1分支 冲突conflict设置冲突管理工具git config merge.tool meld 冲突前提分支module1和Master中有同一个文件，且分别在不同分支修改了文件，并做了add commit操作。做第二次commit时冲突发送。 解决方法：用git mergetool调用meld，查看修改冲突的地方，修改保存后会生成很多不必要的文件用rm 文件名.文件类型.* 文件名_* *~删除这些文件。 Git-flowGit-flow原则 两条长期分支master只保留官方的，实用的代码版本develop在这个分支进行开发，只有想正式对外发布且经过确认，才会和Master合并。 新建develop分支：git checkout -b develop master 将develop分支发布到Master分支：git checkout Master​ `git merge --no-ff develop ` 创建release(预发布)分支当要进行develop分支和Master合并时，先从develop分支上创建一个release分支，加上标签（tag)用于标记新的版本。建议创建一个release分支，这个分支里commit只用于修改bugs。 在develop的子分支（feature分支）上编码只有子分支状态满足，develop上的合并操作才会执行 hotfix当master上发现bug，就在master上引出一个hotfix分支。这个分支有两个作用： 为Master提供一个新版本 为develop修复整个project的bug 注意：release,feature和hotfix分支都是临时分支，使用完后，应该删除，使代码库的常设分支始终只有Master和Deve。 Git-flow例子 在本地建立工作文件夹，初始化库 123456mkdir exercice-git-flow cd exercice-git-flow git init touch README.md git add README.md git commit -m &quot;commit initial&quot; 新建develop分支git checkout -b develop 新建feature分支，以功能名命名git checkout -b navire1 在这个分支中写一个文本文档 123gedit navire.txt git add navire.txt git commit -m &quot;navire version 1` 修改和二次提交为navire.txt中加入新的几行 123gedit navire.txt git add navire.txt git commit -m &quot;navire version 2&quot; 现在我们已经实现了一定功能，合并这个分支和develop 12git checkout develop git merge --no-ff navire1 -m &quot;Merge branch &apos;navire1&apos; into develop&quot; 假设经过多次3-5，我们已经实现了很多功能，想把develop和master合并 12git checkout master git merge --no-ff develop -m &quot;commit release 1.0&quot; 因为这是一个正式版本，我们加上标签taggit tag -a v1.0 -m &quot;release 1.0&quot; 版本控制=有待完成=","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://xiaotong1996.github.io/tags/Git/"}]},{"title":"Vim学习（一）","slug":"2018-02-05-Vim-learning-1","date":"2018-02-04T23:00:00.000Z","updated":"2019-01-08T21:43:08.602Z","comments":true,"path":"2018/02/05/2018-02-05-Vim-learning-1/","link":"","permalink":"https://xiaotong1996.github.io/2018/02/05/2018-02-05-Vim-learning-1/","excerpt":"","text":"目录{:toc} vim学习Part 112345- i → Insert 模式，按 ESC 回到 ormal 模式.- x → 删当前光标所在的一个字符。- :wq → 存盘 + 退出 (:w 存盘, :q 退出) （注：:w 后可以跟文件名）- dd → 删除当前行，并把删除的行存到剪贴板里- p → 粘贴剪贴板 Part 2 插入模式 a → 在光标后插入 o → 在当前行后插入一个新行 O → 在当前行前插入一个新行 cw → 替换从光标所在位置后到一个单词结尾的字符 简单的移动光标 0 → 数字零，到行头 ^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等） $ → 到本行行尾 g_ → 到本行最后一个不是blank字符的位置。 /pattern → 搜索 pattern 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个） 拷贝/粘贴 P → 粘贴;p是表示在当前位置之后，P表示在当前位置之前 yy → 拷贝当前行当行于 ddP;y -&gt; 拷贝 Undo/Redo u → undo C-r → redo 打开/保存/退出/改变文件(Buffer) :e &lt;path/to/file&gt; → 打开一个文件 :w → 存盘 :saveas &lt;path/to/file&gt; → 另存为 &lt;path/to/file&gt; :x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车) :q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。 :bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。 Part 3 vim的重复 . 小数点，重复上一条命令 N加命令，重复N次 光标移动 数字加G，到第N行 gg，到第一行 G，到最后一行 w，到下个词开k移动到与当前光标相匹配的词（×是下一个，#是上一个） 组合命令（开始位置+命令+结束位置） 0y$; 拷贝本行，+p粘贴 能与光标移动联动的还有 d，删除 v，可视化选择 gU，变大写 gu，变小写 其他 Part 4 当前行上移动光标 0，到行头 ^，到本行的第一个非blank字符 $，到行尾 f字符，到下一个字符处 t字符，到符号前的第一个字符 3fa，到本行第三次出现的a处 F和T，与f和t相似，方向相反 dt符号，删除符号前的所有内容 可视化选择v,V J，把所有行连在一起 &lt;和&gt;,左右缩进 =，自动缩进 选中行后，$到最后，a插入字符，Esc为每行添加字符 分屏 ：split，创建分屏 ctrl-w，切屏","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"https://xiaotong1996.github.io/tags/vim/"}]},{"title":"Markdown 学习","slug":"2018-01-27-Markdown-learning","date":"2018-01-26T23:00:00.000Z","updated":"2019-01-08T21:41:43.413Z","comments":true,"path":"2018/01/27/2018-01-27-Markdown-learning/","link":"","permalink":"https://xiaotong1996.github.io/2018/01/27/2018-01-27-Markdown-learning/","excerpt":"","text":"目录{:toc} Markdown 学习一个好的Markdown学习网站 注释comment\\ 标题Header# 加空格实现 句段Sentence/Paragraph 换行 行末加两个空格 \\ 符号Punctuation Charcaters *倾斜* -或+ 列表 >引用 字符实体 tab 预格式化 分隔符Horizontal Rules-– 三个减号或星号或下划线需隔开上一行 文本格式Text Styling 星号（*）或下划线（_）包围的文字将会显示斜体 ex: 倾斜 两个星号（**）或下划线（__）包围的需要特别强调的文字将会加粗 ex: 加粗 两个等号（equalsigns：\\=）包围来突出高亮显示。ex: ==高亮== 使用两个加号（plus sign：+）来标记下划线。ex：++下划线++ 两个波浪符号（two wavy line:~~）包围来给文本添加删除线。ex: 删除线 脚标 Script标准 Markdown 不支持脚标，只能通过内嵌 HTML 的\\&lt;sup>和\\&lt;sub>标签来实现。 脚标两边加上\\&lt; &gt; ex: 2^10^ 脚标两边加上~ ~ ex: H~2~o 链接Hyperlink 文字 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要用尖括号包起来的文字， Markdown 就会自动把它转化成链接。如果你还想要加上链接的 title ，只要在网址后面用双引号把 title 文字包起来即可。 [text](url”解释“) ex: 链接 先定义参考refid：[text][refid]再定义refid所指：[refid]:URL 图片 插入图片 需要在链接文字方括号之前添加一个感叹号（exclamation mark：!），其语法格式 ![alt_text](url) 其中alt_text可以置空 Markdown中的段落（包括图片）默认顶格左对齐，若要将图片居中，可以直接内嵌 HTML 的 标签，设置align=”middle”。如果还不行，可以尝试封裹一层 div 设置 style=”text-align:center” 实现 图片链接 我们在 Markdown 图片标记外面再嵌套一层即可建立图片超链接，点击图片即可跳转到链接地址。图片链接的格式看起来大概是这样的:[![](img_url)](ref_url) 锚点inner link 书签Bookmark 先定义锚点id：bookmark_text 再定义一个id为auchor_id的对象（这里以为例）：auchor_text 脚注Footnote 先在需要脚注的单词（terminology）后面添 加 [^Footnote] ： terminology[^Footnote] 再在文末 glossary 区域定义脚注（添加注解）： [^Footnote]：explanatory notes 引用BlockquoteMarkdown 标记区块引用是使用类似 email 的引用方式，在断好的行前加上 &gt; （more than or greater than sign）： 代码Code 行内代码Inline CodeUse the printf() function.(此处使用了反斜杠转义) 代码块Code Blocks 可使用预格式化引用语法格式。Preformatted Code Block在句段的行首插入1个 tab 或4个空格，则表示代码块。 [Fenced Code Block]在句段行首和行末用三个反引号换行闭包，并在行首三个反引号后添加 YAML 语言标识。 列表List 无序列表Unordered List无序列表（unordered, bulleted）项目的行首使用星号（或加号，或减号）加空格作为列表标记list markers 有序列表Ordered List有序列表（ordered / numbered）项目的行首则使用数字接一个英文句点标记（use numbers followed by periods） 扩展支持把列表变成带勾选框的任务列表，只需要在列表标记后添加[ ]标记☐表示unchecked，在中括号中填写x（[x]）标记☑︎表示checked（filled）。 表格TableYou can create tables by assembling a list of words and dividing them with hyphens - (for the first row), and then separating each column with a pipe | (vertical bar): t1 t2 t11 t12 t21 t22","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://xiaotong1996.github.io/tags/Markdown/"}]}]}