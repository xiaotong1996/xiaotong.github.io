{"meta":{"title":"xiaotong's blog","subtitle":null,"description":null,"author":"Xiaotong CHEN","url":"https://xiaotong1996.github.io"},"pages":[{"title":"About","date":"2019-01-08T20:01:50.000Z","updated":"2019-01-08T20:03:30.111Z","comments":true,"path":"about/index.html","permalink":"https://xiaotong1996.github.io/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-01-08T21:13:48.666Z","updated":"2019-01-08T21:13:48.666Z","comments":true,"path":"tags/index.html","permalink":"https://xiaotong1996.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SDL学习（一）","slug":"SDL学习（一）","date":"2019-03-16T20:54:51.000Z","updated":"2019-03-16T20:58:38.963Z","comments":true,"path":"2019/03/16/SDL学习（一）/","link":"","permalink":"https://xiaotong1996.github.io/2019/03/16/SDL学习（一）/","excerpt":"","text":"SDL（Specification and Description Languag）学习基础概念System：系统，是要开发的应用总体 environment：环境，是任何处于系统外部的东西 Architecture（体系结构）system可被分解成功能块（functional blocks） block可被分解为子块（sub-blocks) blcok通过一个或多个进程（processes），实现功能，通过信息/信号（messages/signals）来互相通信。 process是一个任务（task），有一个隐式的消息队列（implicit message queue）来从其他tasks接受messages。不必定义这个队列。 block在最终程序中不直接实现，是程序的组织和架构者 blocks和process也叫代理（agents） Communication（通信）Agents通过管道（channels）交换messages channels在最终程序中不直接实现，他们用于架构软件和定义接口 Behavior（行为）进程行为（process behavior）图形化地定义为有限状态机（finite state machine）Internalprocess states, events (messages), decisions, timer manipulations, semaphoremanipulations Data and syntax（数据和语法）SDL和SDL-RT的主要不同之处： SDL，data通过ADT（Abstract Data Types）定义，使用特定概念和符号。data实现也有特定语法 SDL-RT，使用C语言","categories":[],"tags":[{"name":"SDL","slug":"SDL","permalink":"https://xiaotong1996.github.io/tags/SDL/"},{"name":"建模","slug":"建模","permalink":"https://xiaotong1996.github.io/tags/建模/"}]},{"title":"Android学习（二）","slug":"Android学习（二）","date":"2019-03-16T20:52:40.000Z","updated":"2019-03-16T20:53:57.236Z","comments":true,"path":"2019/03/16/Android学习（二）/","link":"","permalink":"https://xiaotong1996.github.io/2019/03/16/Android学习（二）/","excerpt":"","text":"Android（二）活动生命周期（le cycle de vie des activite)进程（processus）进程管理 在不同的GNU/LInux系统中不同 目的：优化应用程序；节省资源；管理任务优先级 一个Android应用是一个Unix进程 可能有一个虚拟据（Dalvik）执行 一个虚拟机aspects的闭包（运行时ART android runtime） 这个进程有一个特殊的生命周期 几个活动生命周期的示例图 注意：执行AlterDialog弹出警告框，这不是一个新的activity，所以没有onPause（）* 进程销毁 onDestory（） 优先级等级 屏幕显示的进程 可见的进程 服务进程 后台任务进程 空进程（已结束，存在cache中的进程） Taches asynchrones（同步的任务）主进程（le thread principal） 刷新界面 处理用户相关事务 处理messages 执行services 不要阻断UI线程 不要从UI线程外部access到UI toolkit 管理线程冲突 两种解决方法： 给图像界面元素加锁 只用一个Thread管理图形界面元素 委托图形界面处理： Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable,long) 异步任务AsyncTask&lt;U,V,W&gt; JSON用HTTP读JSON objets：1. 把请求写入一个异步任务 2. 使用这个AsyncTask类要使用HTTP，有一个封装好的类：HttpURLConnection 自己写一个readStream（）方法用来读入数据流（flux de donnees）来构建结果 1234567891011121314151617private String readStream(InputStream is) throws IOException &#123; StringBuilder sb = new StringBuilder(); BufferedReader r = new BufferedReader(new InputStreamReader(is),1000); for (String line = r.readLine(); line != null; line =r.readLine())&#123; sb.append(line); &#125; is.close(); return sb.toString();&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiaotong1996.github.io/tags/Android/"}]},{"title":"Android学习（一）","slug":"Android学习（一）","date":"2019-03-16T20:50:30.000Z","updated":"2019-03-16T20:52:24.487Z","comments":true,"path":"2019/03/16/Android学习（一）/","link":"","permalink":"https://xiaotong1996.github.io/2019/03/16/Android学习（一）/","excerpt":"","text":"Android学习（一）日志 Log. v()。 用于 打印 那些 最为 琐碎 的、 意义 最小 的 日志 信息。 对应 级别 verbose， 是 Android 日志 里面 级别 最低 的 一种。 Log. d()。 用于 打印 一些 调试 信息， 这些 信息 对 你 调试 程序 和 分析 问题 应该 是有 帮助 的。 对应 级别 debug， 比 verbose 高 一级。 Log. i()。 用于 打印 一些 比较 重要的 数据， 这些 数据 应该 是你 非常 想 看到 的、 可以 帮你 分析 用户 行为 数据。 对应 级别 info， 比 debug 高 一级。 Log. w()。 用于 打印 一些 警告 信息， 提示 程序 在这 个 地方 可能 会有 潜在 的 风险， 最好 去 修复 一下 这些 出现 警告 的 地方。对应 级别 warn， 比 info 高 一级。 Log. e()。 用于 打印 程序 中的 错误 信息， 比如 程序 进入 到了 catch 语句 当中。 当 有错误 信息 打印 出来 的 时候， 一般 都 代表 你的 程序 出现 严重 问题 了， 必须 尽快 修复。 对应 级别 error， 比 warn 高 一级。 活动（Activity）活动（ Activity） 是最 容易 吸引 用户 的 地方， 它是 一种 可以 包含 用户 界面 的 组件， 主要 用于 和 用户 进行 交互。 在 java/ com. example. activitytest中新建一个activity 在 src/layout中创建一个布局文件, 在activity中加载布局（）回到 FirstActivity， 在 onCreate() 方法 中 加入 如下 代码： setContentView( R. layout. first_ layout); 在 AndroidManifest 文件 中 注册 配置 主 活动 的 方法 其 实在 第 1 章 中 已经 介绍 过了， 就是 在&lt; activity&gt; 标签 的 内部 加入&lt; intent- filter&gt; 标签， 并在 这个 标签 里 添加&lt; action android: name=” android. intent. action. MAIN”/&gt; 和&lt; category android: name=” android. intent. category. LAUNCHER” /&gt;这 两句 声明 即可。 Toast(短暂出现的提示框)首先 需要 定义 一个 弹出 Toast 的 触发 点， 正好 界面 上有 个 按钮， 那 我们 就让 点击 这个 按钮 的 时候 弹出 一个 Toast 吧。 在 onCreate()中添加 12345678910protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button=(Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener()&#123; public void onClick(View v)&#123; Toast.makeText(MainActivity.this,\"You clicked Button\", Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; 得到 按钮 的 实例 之后， 我们 通过 调用 setOnClickListener() 方法 为 按钮 注册 一个 监听器， 点击 按钮 时 就会 执行 监听器 中的 onClick() 方法。 静态方法makeText() 创建 出 一个 Toast 对象， 然后 调用 show() 将 Toast 显示 出来 就可以 了。 这里 需要 注意 的 是， makeText() 方法 需要 传入 3 个 参数。 第一个 参数 是 Context， 也就是 Toast 要求 的 上下文， 由于 活动 本身 就是 一个 Context 对象， 因此 这里 直接 传入 FirstActivity. this 即可。 第二个 参数 是 Toast 显示 的 文本 内容， 第三 个 参数 是 Toast 显示 的 时 长， 有两 个 内置 常量 可以 选择 Toast. LENGTH_ SHORT 和 Toast. LENGTH_ LONG。 Menu 在res/menu中新建Menu resource file 在新建出来的menuxml文件中添加items 在activity中重写onCreateOptionsMenu()方法 123public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main,menu); return true;&#125; inflate() 方法 接收 两个 参数， 第一个 参数 用于 指定 我们 通过 哪一个 资源 文件 来 创建 菜单， 这里 当然 传入 R. menu. main。 第二个 参数 用于 指定 我们 的 菜单项 将 添加 到 哪一个 Menu 对象 当中， 这里 直接 使用 onCreateOptionsMenu() 方法 中 传入 的 menu 参数。 然后 给 这个 方法 返回 true， 表示 允许 创建 的 菜单 显示 出来， 如果 返回 了 false， 创建 的 菜单 将 无法 显示。 定义菜单响应事件。在acticity中重写onOprionsItemsSelected()方法： 1234567891011121314public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.add_item: Toast.makeText(this,\"You clicked Add\", Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this,\"You clicked Remove\", Toast.LENGTH_SHORT).show(); break; default: Toast.makeText(this,\"Default\",Toast.LENGTH_SHORT).show(); &#125; return true; &#125; 销毁事件只要 按 一下 Back 键 就可以 销毁 当前 的 活动 了。 不过 如果 你 不想 通过 按键 的 方式， 而是 希望 在 程序 中 通过 代码 来 销毁 活动， 当然 也可以， Activity 类 提供 了 一个 finish() 方法， 我们 在 活动中 调用 一下 这个 方法 就可以 销毁 当前 活动 了。 Intent(连接各个活动)Intent 是 Android 程序 中 各组 件 之间 进行 交互 的 一种 重要 方式， 它不 仅可 以指 明 当前 组件 想要 执行 的 动作， 还可 以在 不同 组件 之间 传递 数据。 Intent 一般 可被 用于 启动 活动、启动 服务 以及 发送 广播 等 场景。 显示IntentIntent 有多 个 构造 函数 的 重载， 其中 一个 是 Intent( Context packageContext, Class&lt;?&gt; cls)。 这个 构造 函数 接收 两个 参数， 第一个 参数 Context 要求 提供 一个 启动 活动 的 上下文， 第二个 参数 Class 则是 指定 想要 启动 的 目标 活动， 通过 这个 构造 函数 就可以 构建 出 Intent 的“ 意图”。 然后 我们 应该 怎么 使用 这个 Intent 呢？ Activity 类 中 提供 了 一个 startActivity() 方法， 这个 方法 是 专门 用于 启动 活动 的， 它 接收 一个 Intent 参数， 这里 我们将 构建 好的 Intent 传入 startActivity() 方法 就可以 启动 目标 活动 了。 修改MainActivity中按钮点击事件 123456button.setOnClickListener(new View.OnClickListener()&#123; public void onClick(View v)&#123; Intent intent=new Intent(MainActivity.this,Test1Activity.class); startActivity(intent); &#125; &#125;); MainActivity.this作为上下文，Test1Activity.class作为目标活动。通过startActivity来执行Intent。 隐式Intent它 并不 明确 指出 我们 想要 启动 哪一个 活动， 而是 指定 了 一系列 更为 抽象 的 action 和 category 等 信息， 然后 交由 系统 去 分析 这个 Intent， 并 帮我 们 找出 合适 的 活动 去 启动。 在AndroidManifest.xml中指定活动能够响应的action和category 123456&lt;activity android:name=\".Test1Activity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.example.activitytest.ACTION_START\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 在&lt; action&gt; 标签 中 我们 指明 了 当前 活动 可以 响应 com. example. activitytest. ACTION_ START 这个 action， 而&lt; category&gt; 标签 则 包含 了 一些 附加 信息， 更 精确 地 指明 了 当前 的 活动 能够 响应 的 Intent 中 还可 能带 有的 category。 只有&lt; action&gt; 和&lt; category&gt; 中的 内容 同时 能够 匹配 上 Intent 中指 定的 action 和 category 时， 这个 活动 才能 响应 该 Intent。 修改按钮的点击事件 123456button.setOnClickListener(new View.OnClickListener()&#123; public void onClick(View v)&#123; Intent intent=new Intent(\"com.example.activitytest.ACTION_START\"); startActivity(intent); &#125; &#125;); 每个 Intent 中 只能 指定 一个 action， 但却 能 指定 多个 category 更多隐式Intent用法使用 隐式 Intent， 我们 不仅 可以 启动 自己 程序 内 的 活动， 还可以 启动 其他 程序 的 活动， 这 使得 Android 多个 应用 程序 之间 的 功能 共享 成为 了 可能。 比如说 你的 应用 程序 中 需要 展示 一个 网页， 这时 你 没有 必要 自己 去 实现 一个 浏览器（ 事实上 也不 太 可能）， 而是 只需 要 调用 系统 的 浏览器 来 打开 这个 网页 就 行了。 12345678button1.setOnClickListener(new View.OnClickListener()&#123; public void onClick(View v) &#123; Intent intent=new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse(\"http://www.google.com\")); startActivity(intent); &#125; &#125;); 了 Intent 的 action 是 Intent. ACTION_ VIEW， 这是 一个 Android 系统 内置 的 动作， 其 常 量值 为 android. intent. action. VIEW。 然后 通过 Uri. parse() 方法， 将 一个 网址 字符串 解析 成 一个 Uri 对象， 再 调用 Intent 的 setData() 方法 将 这个 Uri 对象 传递 进去。 setData()方法，它 接收 一个 Uri 对象， 主要 用于 指定 当前 Intent 正在 操作 的 数据， 而这 些 数据 通常 都是 以 字符串 的 形式 传入到 Uri. parse() 方法 中 解析 产生 的。 与此 对应， 我们 还可 以在&lt; intent- filter&gt; 标签 中 再 配置 一个&lt; data&gt; 标签， 用于 更 精确 地 指定 当前 活动 能够 响应 什么 类型 的 数据。&lt; data&gt; 标签 中 主要 可以 配置 以下 内容。 android: scheme。 用于 指定 数据 的 协议 部分， 如上 例 中的 http 部分。 android: host。 用于 指定 数据 的 主机 名 部分， 如上 例 中的 www. baidu. com 部分。 android: port。 用于 指定 数据 的 端口 部分， 一般 紧随 在 主机 名 之后。 android: path。 用于 指定 主 机名 和 端口 之后 的 部分， 如一 段 网址 中 跟在 域名 之后 的 内容。 android: mimeType。 用于 指定 可以处理 的 数据 类型， 允许 使用 通配符 的 方式 进行 指定。 除了 http 协议 外， 我们 还可以 指定 很多 其他 协议， 比如 geo 表示 显示 地理 位置、 tel 表示 拨 打电话。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiaotong1996.github.io/tags/Android/"}]},{"title":"C#数据库工具开发（十三）","slug":"C-数据库工具开发（十三）","date":"2019-01-09T10:17:58.000Z","updated":"2019-01-09T10:18:35.714Z","comments":true,"path":"2019/01/09/C-数据库工具开发（十三）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（十三）/","excerpt":"","text":"C#数据库工具开发（十三）问题（08/01）单行同步，容易实现，只要判断选择的行状态做操作就行。如何撤销？用栈存储已执行的sql指令以及执行前的字段状态，对应每个指定，做反操作。 做同步操作，全过程 根据差异同步DB 清空dblists 取更新后的dblists 用新的dblists填充dataDB 更新新的infolists 按照新的dblists顺序，对infolists排序，并删除已经选择去掉的项 用新的infolists填充dataxml 同步索引项","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（十二）","slug":"C-数据库工具开发（十二）","date":"2019-01-09T10:16:53.000Z","updated":"2019-01-09T10:17:48.157Z","comments":true,"path":"2019/01/09/C-数据库工具开发（十二）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（十二）/","excerpt":"","text":"C#数据库工具开发（十二）问题（07/30）1. 如何实现同步两个DGV的滚动条123456789private void dataXML_Scroll(object sender, ScrollEventArgs e) &#123; this.dataDB.FirstDisplayedScrollingRowIndex = this.dataXML.FirstDisplayedScrollingRowIndex;&#125;private void dataDB_Scroll(object sender, ScrollEventArgs e)&#123; this.dataXML.FirstDisplayedScrollingRowIndex = this.dataDB.FirstDisplayedScrollingRowIndex; &#125; 2. 如何实现一次删除DGV中的多行123456789101112131415foreach (DataGridViewRow row in dataXML.Rows)&#123; if((row.Cells[0].Value==null||row.Cells[0].Value.ToString()==&quot;&quot;)&amp;&amp;row.Index!=dataXML.Rows.Count-1) &#123; row.Selected = true; &#125; else &#123; row.Selected = false; &#125;&#125;foreach (DataGridViewRow row in dataXML.SelectedRows)&#123; dataXML.Rows.Remove(row);&#125; 在if条件中写要删除的行应该满足的条件，设置行被选中（利用Selected这个property），再删除选中的行。 注意：不能用foreach每一行，加上判断，直接删除。因为每一次删除后，实际上Rows已经改变，循环不能遍历到所有满足条件的行。（先存行号，后删除的做法也一样，同理，每一次删除，行号已经改变） 3. 避免事件无意间调用问题背景：我想要按下delete后，不删除这一行，只清空改行所有数据。想到的解决方法是在删除这一行后，在同一个index新建一行，但是总是出现各种问题。后来发现，因为我在dataXML_RowsAdded（行增加事件）中有完成其他功能，而实际上，我每次新建一行，都会触发这个事件，这就导致出现问题。解决方法：设定一个bool标签deleting，在删除触发的方法中，设定deleting一开始为true，最后设回false，并在增加行触发的方法中，判断deleting的值，若为true则不执行任何操作。","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（十一）","slug":"C-数据库工具开发（十一）","date":"2019-01-09T10:15:51.000Z","updated":"2019-01-09T10:16:43.396Z","comments":true,"path":"2019/01/09/C-数据库工具开发（十一）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（十一）/","excerpt":"","text":"C#数据库工具开发（十一）问题（07/26-07/27）1. 删除数据库中的一列，会自动删除与其关联的索引吗？MySQL是这样的，详情 SQLServer经实践发现，必须先删除索引再删除列。因为索引依赖于列。 2. 索引命名引起的异常问题背景：在新增索引时总是按照表名_INDEX_数字来给索引命名，数字是从0开始往上递增。问题在于，假设我们在test表中分别给三个字段添加了三个索引，即生成索引TEST_INDEX_0/1/2，那么如果我们删除了第一个索引TEST_INDEX_0，保留了索引TEST_INDEX_1/2，再次新建索引时，这个索引名字应该是0还是3结尾？而且我目前的实现，未考虑上述情况，只是在建立索引前查询表中索引数目，以这个数目作为新索引的结尾名，因此现在若创建一个新的索引会命名为TEST_INDEX_2，与表中已存在的索引冲突，发生异常。 解决方案一：每次删除一个索引，把它编号之后的索引编号减一，这涉及到索引的查找和修改。sp_rename &#39;tabName.old_indName&#39;,&#39;new_indName&#39;,&#39;INDEX&#39; 解决方案二：换一种命名方式：编号可用随机值生成真随机数的方法： 12345678910public static string GenerateRandomCode(int length) &#123; var result = new System.Text.StringBuilder(); for (var i = 0; i &lt; length; i++) &#123; var r = new Random(Guid.NewGuid().GetHashCode()); result.Append(r.Next(0, 10)); &#125; return result.ToString(); &#125; 解决方案三：不考虑名称的连续性，直接在最大值基础上往上加。 3. 字段有索引时，不能修改字段类型解决方法：先删除索引，修改字段后，再新建索引。这里会引起一个额外的问题：如何确认要修改的字段是否已存在索引。有以下几种情况： 字段有索引，checkbox已勾选=&gt;先删除索引，修改字段，再新建索引。 字段有索引，checkbox不勾选=&gt;先删除索引，再修改字段 字段无索引，checkbox已勾选=&gt;先修改字段，再添加索引 字段无索引，checkbox不勾选=&gt;直接修改字段 还有两种情况新增字段：先增加字段，根据checkbox值，选择是否添加索引。删除字段：先删除索引，再删除字段 此外，若只增删索引，则会重复修改字段操作。设定bool标识justindex，每次调用compareList（）方法时，确认行有差异，是否是因为只有索引列发生变化，如是则设为true，否则有其他引起行的差异则设为false。这样，在做同步操作前，先根据bool标识，获知引起行差异的原因，可省去没必要的修改字段操作。 一共有八钟可能的操作 只增加字段，不增加索引 OK 只修改字段，不增加索引 OK 不修改字段，增加索引 OK 不修改字段，删除索引 OK 既增加字段，又增加索引 OK 既修改字段，又增加索引 OK 既修改字段，又删除索引 OK 既删除字段，又删除索引 OK","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（十）","slug":"C-数据库工具开发（十）","date":"2019-01-09T10:14:47.000Z","updated":"2019-01-09T10:15:42.426Z","comments":true,"path":"2019/01/09/C-数据库工具开发（十）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（十）/","excerpt":"","text":"C#数据库工具开发（十）问题（07/24-07/25）1. 如何实现一个页面关闭触发上级页面的响应？问题背景：我有一个页面显示某个数据库中所有表名和表结构，在此页面可以打开另一个修改或创建新表的页面，完成后，我想立即在显示页面刷新，让刚刚修改或生成的表也能出现在列表中。解决方法：由于修改添加页面是在显示页面生成的： 12formxml = new FormXMLExecute(&quot;*Oracle*&quot;, filePath.Text);formxml.Show(); 我们只需要在创建formxml时添加一个页面关闭事件即可： 123formxml = new FormXMLExecute(&quot;*Oracle*&quot;, filePath.Text);formxml.FormClosing += new FormClosingEventHandler(this.FromXMLExecute_FormClosing);formxml.Show(); 在页面关闭事件中： 1234private void FromXMLExecute_FormClosing(object sender, FormClosingEventArgs e)&#123; //Do your stuff here.&#125; 实现想要完成的功能（如刷新页面等） 2. DataGridViewCheckBox的响应事件问题背景：想要实现点击DataGridViewCheckBox后，刷新页面解决方法：这个的即时响应和DataGridViewTextBox或DataGridViewComboBox相比简单很多，能直接用现有事件 1234567private void dataXML_CellContentClick(object sender, DataGridViewCellEventArgs e)&#123; if (e.ColumnIndex == 3 &amp;&amp; e.RowIndex != -1) &#123; //Do your stuff here. &#125;&#125; 唯一需要注意的和之前提到的一样：用单元格EditedFormattedValue属性而不是Value属性。 3. 如何查询某个表中所有设置了索引的字段？Oracle：​ 1select a.column_name from all_ind_columns a, all_indexes b where a.index_name=b.index_name and a.table_name = upper(&apos;&quot;+tableName+&quot;&apos;) order by a.table_name&quot;; SQLServer： 1&quot;USE &quot; + DBName+&quot; ;SELECT colname=d.name FROM sysindexes a JOIN sysindexkeys b ON a.id=b.id AND a.indid=b.indid JOIN sysobjects c ON b.id=c.id JOIN syscolumns d ON b.id=d.id AND b.colid=d.colid WHERE a.indid NOT IN(0,255) AND c.name=&apos;&quot;+tableName+&quot;&apos;&quot;; 3.1 更好的查询表中所有索引以及对应列名的sql查询语句1234567891011121314151617use GMP_BF;SELECTtab.name AS [表名],idx.name AS [索引名称],col.name AS [列名]FROMsys.indexes idxJOIN sys.index_columns idxCol ON (idx.object_id = idxCol.object_id AND idx.index_id = idxCol.index_id )JOIN sys.tables tab ON (idx.object_id = tab.object_id)JOIN sys.columns col ON (idx.object_id = col.object_id AND idxCol.column_id = col.column_id)WHERE tab.name=&apos;TEST2&apos;;","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（九）","slug":"C-数据库工具开发（九）","date":"2019-01-09T10:13:27.000Z","updated":"2019-01-09T10:14:35.202Z","comments":true,"path":"2019/01/09/C-数据库工具开发（九）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（九）/","excerpt":"","text":"C#数据库工具开发（九）问题（07/20）1. 如何实现DataGridView更改Cell值实时同步（像TextBox的效果）？具体实现： 123456789101112131415161718192021222324252627private void dataXML_EditingControlShowing(object sender, DataGridViewEditingControlShowingEventArgs e) &#123; if (e.Control.GetType().Equals(typeof(DataGridViewComboBoxEditingControl)))//cell为类ComboBox时 &#123; e.CellStyle.BackColor = Color.FromName(&quot;window&quot;); DataGridViewComboBoxEditingControl editingControl = e.Control as DataGridViewComboBoxEditingControl; editingControl.SelectedIndexChanged += new EventHandler(EditingTB_TypeChanged); &#125; else if (e.Control.GetType().Equals(typeof(DataGridViewTextBoxEditingControl)))//cell为类TextBox时 &#123; e.CellStyle.BackColor = Color.FromName(&quot;window&quot;); DataGridViewTextBoxEditingControl editingControl = e.Control as DataGridViewTextBoxEditingControl; editingControl.TextChanged += new EventHandler(EditingTB_LengthChanged); &#125; &#125; private void EditingTB_TypeChanged(object sender,EventArgs e) &#123; //添加操作 &#125; private void EditingTB_LengthChanged(object sender,EventArgs e) &#123; //添加操作 &#125; 参考：DataGridView的单元格内容即时更新方法注意点：要用dataGridView1.CurrentCell.EditedFormattedValue而不是dataGridView1.CurrentCell.Value 2. string删除空格三种方式：​ string trim = Regex.Replace( text, @”\\s”, “” ); 1234567string trim = text.Replace( &quot; &quot;, &quot;&quot; ); trim = trim.Replace( &quot;\\r&quot;, &quot;&quot; ); trim = trim.Replace( &quot;\\n&quot;, &quot;&quot; ); trim = trim.Replace( &quot;\\t&quot;, &quot;&quot; ); string text = &quot; My test\\nstring\\r\\n is\\t quite long &quot;; string trim = text.Trim(); 3. 获取系统时间DateTime.Now.ToString(&quot;f&quot;);//不显示秒 参考：C#获取当前系统时间 4. 导出文件不能立即在目标目录显示文件解决方法：将包含savefiledialog的窗体显示从showdialog改为show 5. 如何实现DataGridViewTextBox自动把小写转化为大写？同样用到EditingControlShowing这个事件，另外在DataGridViewTextBox中只需要设置某一列的CharacterCasing为Upper就行。具体实现​ 12345678910111213DataGridView dgv = (DataGridView)sender; if (e.Control is DataGridViewTextBoxEditingControl) &#123; DataGridViewTextBoxEditingControl editingControl = (DataGridViewTextBoxEditingControl)e.Control; if (dgv.CurrentCell.OwningColumn.Name == &quot;fieldName&quot;) &#123; editingControl.CharacterCasing = CharacterCasing.Upper; &#125; else &#123; editingControl.CharacterCasing = CharacterCasing.Normal; &#125; &#125;","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（八）","slug":"C-数据库工具开发（八）","date":"2019-01-09T10:11:14.000Z","updated":"2019-01-09T10:13:00.858Z","comments":true,"path":"2019/01/09/C-数据库工具开发（八）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（八）/","excerpt":"","text":"C#数据库工具开发（八）问题（07/19）1. 如何实现拖拽文件到textbox获取文件路径？利用textbox两个事件：dragenter和dragdrop具体实现 1234567891011private void filePath_DragEnter(object sender, DragEventArgs e) &#123; if (e.Data.GetDataPresent(DataFormats.FileDrop)) &#123; e.Effect = DragDropEffects.Link; &#125; else &#123; e.Effect = DragDropEffects.None; &#125; &#125; 12345private void filePath_DragDrop(object sender, DragEventArgs e)&#123;string path = ((System.Array)e.Data.GetData(DataFormats.FileDrop)).GetValue(0).ToString(); filePath.Text = path;&#125; 2. 数据库如何增删改字段？只考虑SQLServer和Oracle，增加和删除字段可用相同sql语句,修改字段略有不同：增加：sql = @&quot;use &quot; + DBName + &quot;; ALTER TABLE &quot; + tableName + &quot; ADD &quot; + fieldName + &quot; &quot; + fieldType + &quot;(&quot; + fieldLength + &quot;);&quot;;删除：sql = @&quot;use &quot; + DBName + &quot;; ALTER TABLE &quot; + tableName + &quot; DROP COLUMN &quot; + fieldName + &quot;;&quot;;修改：SQLSerer：sql = @&quot;use &quot; + DBName + &quot;; ALTER TABLE &quot; + tableName + &quot; ALTER COLUMN &quot; + fieldName + &quot; &quot; + fieldType + &quot;(&quot; + fieldLength + &quot;);&quot;;Oracle:sql = @&quot;ALTER TABLE &quot; + tableName + &quot; modify(&quot; + fieldName + &quot; &quot; + fieldType + &quot;(&quot; + fieldLength + &quot;))&quot;; 3. 如何导出文件？使用SaveFileDialog控件具体实现： 123456789101112131415161718192021222324252627SaveFileDialog saveFileDialog1 = new SaveFileDialog(); saveFileDialog1.Filter = &quot;TXT|*.txt&quot;; saveFileDialog1.Title = &quot;选择导出sql记录的存储路径&quot;; saveFileDialog1.ShowDialog(); // If the file name is not an empty string open it for saving. if (saveFileDialog1.FileName != &quot;&quot;) &#123; // Saves the Image via a FileStream created by the OpenFile method. System.IO.FileStream fs = (System.IO.FileStream)saveFileDialog1.OpenFile(); // Saves the Image in the appropriate ImageFormat based upon the // File type selected in the dialog box. // NOTE that the FilterIndex property is one-based. StreamWriter sw = new StreamWriter(fs); foreach(string result in sqlcommands) &#123; sw.WriteLine(result); &#125; //清空缓冲区 sw.Flush(); //关闭流 sw.Close(); fs.Close(); &#125; 4. 如何给DataGridView增加行号123456789101112131415private void dataXML_RowPostPaint(object sender, DataGridViewRowPostPaintEventArgs e) &#123; var grid = sender as DataGridView; var rowIdx = (e.RowIndex + 1).ToString(); var centerFormat = new StringFormat() &#123; // right alignment might actually make more sense for numbers Alignment = StringAlignment.Center, LineAlignment = StringAlignment.Center &#125;; var headerBounds = new Rectangle(e.RowBounds.Left, e.RowBounds.Top, grid.RowHeadersWidth, e.RowBounds.Height); e.Graphics.DrawString(rowIdx, this.Font, SystemBrushes.ControlText, headerBounds, centerFormat); &#125;","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（七）","slug":"C-数据库工具开发（七）","date":"2019-01-09T10:10:02.000Z","updated":"2019-01-09T10:11:01.501Z","comments":true,"path":"2019/01/09/C-数据库工具开发（七）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（七）/","excerpt":"","text":"C#数据库工具开发（七）问题（07/18）1. 返回登录界面程序入口是登录界面，登录成功后隐藏登陆界面，显示主界面。现在想要实现点击主界面的按钮，返回登录界面。 思路一：登录成功后，hide登录界面，new主界面。点击back按钮，hide主界面，show登陆界面。再次点击登陆，更新（reload）主界面有两个问题，第一为了防止之后反复创建新的主界面，我把主界面先作为登陆界面属性创建，在login按钮事件中，只是添加参数，将其显示出来。可以增加一个静态变量isShown表示主界面是hide还是show。问题在于，主界面的load方法只在一开始调用，要想办法实现主界面的重新加载。第二，主界面hide之后如何重新show登录界面。已知能用委托实现。 思路二：登录成功后，hide登陆界面，new主界面。点击back按钮，close主界面，show登录界面。再次点击登录，新建(new)主界面同样有两个问题，第二，我想保留当主界面close时，整个程序exit这个特性，所以我在FormMainOrcl_FormClosed事件中，有Application.Exit();，但是form.close()方法，也会引起这个事件的响应，这就导致点击back按钮后，整个程序都退出了。第二，与思路一第二点一致 目前暂时能想到的解决方案：不保留主界面close，程序exit这个设定，程序只有在登陆界面退出时才退出。 改进的实现思路二的方案：在主界面添加变量justback，默认false，若点击back按钮，将justback设为true，在formclosed事件中判断justback，可以跳过程序退出。对于第二点，不用委托，更简单的实现方法在登录界面中 1234this.Hide();FormMainTableShow formMain = new FormMainTableShow();formMain.Tag = this;formMain.Show(); 在主界面中 123FormLogin login = (FormLogin)this.Tag;login.Show();this.Close(); 2. 设置16进制颜色值例子：Color color=ColorTranslator.FromHtml(&quot;#CE76D1&quot;); 3. 调用资源文件例子：XElement root = XElement.Parse(Resources.ResourceManager.GetObject(&quot;XMLTypeOracle&quot;) as string);","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（六）","slug":"C-数据库工具开发（六）","date":"2019-01-09T10:08:59.000Z","updated":"2019-01-09T10:09:50.961Z","comments":true,"path":"2019/01/09/C-数据库工具开发（六）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（六）/","excerpt":"","text":"C#数据库工具开发（六）问题（07/17）1. 两个list的互相比较背景：我要比较两个DataGridView中多列值，可转变为两列list的互相比较 我的简单实现：用多次foreach循环，设置一个标签find=false；找到改为ture；实现查找两个lists中有哪些不同项。这样做能在循环中找到不同项和差项时，直接进行操作。可能存在问题是对于大量数据效率低，好在我这里只要比较数据库某个表中的字段名称，类型和长度。 其他实现：C# Linq获取两个List或数组的差集交集这样做的话，要先把DataGridView中的列存入list，linq取到差集后，再在DataGridView中定位差集中的元素，再进行操作。好处是linq在普通方法实现list比较时，效率高，对大量数据也适用。考虑之后学习linq，尝试实现。 2. CHARACTER_MAXIMUM_LENGTH返回值为空string length = (reader.IsDBNull(2)) ? &quot;&quot;: Convert.ToString(reader.GetInt32(2));sqlserver数据库中，CHARACTER_MAXIMUM_LENGTH查询结果为空，但是返回值不能用reader.GetInt32(2)==null来判断。原因是数据库中的null和字符串中的null是不同类型的值，所以要用IsDBNULL来判断。","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（五）","slug":"C-数据库工具开发（五）","date":"2019-01-09T10:07:59.000Z","updated":"2019-01-09T10:08:48.627Z","comments":true,"path":"2019/01/09/C-数据库工具开发（五）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（五）/","excerpt":"","text":"C#数据库工具开发（五）问题（07/16）1. xml.load()方法引发web exception未处理：远程服务器返回错误： ( 503 ) 服务器不可用异常解决方法： 尝试从XHTML文件中删除 DOCTYPE，可能你有指向外部DTD的链接。 doc.XmlResolver = null;//this忽略 DTD 2. sqlDataReader未关闭引发错误之前是直接拿sqlDataReader作返回值，但是sqlDataReader需要及时关闭，不然会导致二次调用同一方法引起异常。好的写法是：把sqlDataReader读到的数据存入dataTable中，关闭sqlDataReader，返回dataTable。","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（四）","slug":"C-数据库工具开发（四）","date":"2019-01-09T10:06:56.000Z","updated":"2019-01-09T10:07:48.365Z","comments":true,"path":"2019/01/09/C-数据库工具开发（四）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（四）/","excerpt":"","text":"C#数据库工具开发（四）问题（07/13）1. SQL查询某个表中所有字段名和字段类型SQLServer： 1string sql = @&quot;USE &quot; + DBName+ &quot;; select COLUMN_NAME,DATA_TYPE,CHARACTER_MAXIMUM_LENGTH,IS_NULLABLE from INFORMATION_SCHEMA.COLUMNS t where t.TABLE_NAME = &apos;&quot; + TableName+&quot;&apos;;&quot;; Oracle: 1string sql = @&quot;select column_name, data_type from user_tab_columns where table_name = &apos;&quot;+TableName+&quot;&apos;&quot;; 2. Linq to XML解析半闭合标签的XML文件有问题看（五）linq需要学习 3. XML Document System.Net.WebException异常在XmlDocument doc = new XmlDocument();doc.Load(path);之间加断点调试会引发上述异常。正常调试没问题。 4. C#string操作常用方法split：按字符分割返回一个string数组substring：获取部分字符串","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（三）","slug":"C-数据库工具开发（三）","date":"2019-01-09T10:05:47.000Z","updated":"2019-01-09T10:06:42.728Z","comments":true,"path":"2019/01/09/C-数据库工具开发（三）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（三）/","excerpt":"","text":"C#数据库工具开发（三）问题（07/11-07/12）1. 在实现ConfigerManager时，把实现都放在了登陆界面的事件函数中，没能很好的分离功能（待解决）虽然尝试了把这部分功能分离出来，但是最多把保存登陆信息和伴随用户选择更改登陆信息这两部分放到Configer工具类中，后者要用至少4个引用参数来为窗口中的控件提供Text值。而对于登录界面默认加载最近登录信息的功能，则需要更多参数来实习，考虑了一下又改回之前的实现方案。 2. 连接oracle服务器时，提示System.ComponentModel.Win32Exception: 安全包中没有可用的凭证异常。应该是安全认证方面的问题，解决方法是：win10用户退出微软登录账号，改用本地账号。不理解是为什么。 3. ORA-00911:无效字符连接成功后执行Oracle的sql语句，报错信息包含这样的错误。解决方法是：去掉sql语句结束的;分号。分号对与SQL Server的语句执行无影响。","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（二）","slug":"C-数据库工具开发（二）","date":"2019-01-09T10:03:17.000Z","updated":"2019-01-09T10:05:30.063Z","comments":true,"path":"2019/01/09/C-数据库工具开发（二）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（二）/","excerpt":"","text":"C#数据库工具开发（二）问题（07/09-/07/11）1. 数据库连接的开关，需要确认连接状态为了避免之后执行sql查询等操作时反复连接数据库，我把数据库连接打开和关闭分成两个方法，在登录成功时打开连接，一直到程序结束前断开连接。同时为了避免多次打开同一连接，需要在打开前先确认连接状态。 2. 执行SQL语句是忽略关键字GO问题发生在使用SQL语句进入特定数据库时。虽然在实际数据库中可以使用，但用C#连接的SQL server不识别GO。解决方法也很简单，use 数据库名之后不加GO，加;就行。更好的解决方法：处理批量sql语句ps：记录一种查询服务器中所有数据库 和 两种查询特定数据库中所有表的SQL语句：查数据库：Select Name FROM Master.dbo.SysDatabases ORDER BY Name;查表法一：select name from sysobjects where xtype=&#39;U&#39; order by name;查表法二：SELECT table_name FROM information_schema.tables WHERE table_type = &#39;base table&#39;详细1详细2 3. 存储sql执行语句结果的两种方式法一用SqlDataAdapter 123DataSet ds = new DataSet();SqlDataAdapter sAdapter = new SqlDataAdapter(sql, sqlConnection);sAdapter.Fill(ds); 法二用SqlDataReaderSqlDataReader sRead = cmd.ExecuteReader();这两种方法的主要区别 4. 查询结果如何在主窗口正确显示？最开始使用的ListView控件，通过添加listviewitem显示字段。具体方法如下： 12345ListViewItem li = new ListViewItem(); li.SubItems.Clear(); li.SubItems[0].Text = reader[&quot;name&quot;].ToString(); li += new EventHandler(this.dbItem_DoubleClick); DBList.Items.Add(li); 这种方法问题在于，我想实现点击item（字段）显示对应的表名或表结构，但是很难为item添加事件。解决措施：换用DataGridView控件，好处在于:第一，这个控件本来就是为数据库显示服务的，获得DataSet之后用dataView.DataSource = ds.Tables[0].DefaultView;就可以显示完整表单。第二，通过CurrentCellChanged事件就可以很方便实现点击显示对应表单的效果。","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"C#数据库工具开发（一）","slug":"C-数据库工具开发（一）","date":"2019-01-09T09:59:45.000Z","updated":"2019-01-10T22:24:16.084Z","comments":true,"path":"2019/01/09/C-数据库工具开发（一）/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/C-数据库工具开发（一）/","excerpt":"","text":"C#数据库工具开发（一）源码查询我的Github：DBTool 开发日程 2019/07/09-/07/11sql server数据库连接+登录界面主界面+表单查询和显示 07/11-07/12登录配置文件oracle数据库连接 07/13-07/13读取保存数据库字段属性读取保存xml解析数据部分实现利用xml解析数据同步数据库（添加表）为主界面添加控件 07/13-07/13部分实现xml字段到sql字段映射xml导入配置页面部分实现利用xml解析数据同步数据库 07/16-07/16sql server和oracle数据库连接重构（sqlDataReader改用）xml导入创建新表部分实现xml与DB字段比较 07/17-07/17为比较页面（xml执行页面）添加字段长度项优化xml与DB字段比较用配置文件实现XML中字段类型映射界面优化 07/18-07/18增加logo增加数据库检索将SQL和Oracle显示table界面合二为一，删除SQL显示table界面中显示数据库的表（该功能与数据库检索重复)将字符串映射文件加入资源中 07/19-07/19更换logo，调整窗体增加拖拽文件直接加载功能优化字符串映射功能，避免bug对比界面自动刷新,优化显示增加同步数据库功能增加导出sql语句功能 07/20-07/20优化对比界面更改字段事件优化导出sql语句功能，避免线程卡死添加xml显示界面手动添加或删除字段并刷新比对的功能 07/24-07/24优化添加表完成后字段页面同步刷新优化添加表完成后导出sql语句优化添加表完成后表显示页面刷新修复修改字段不显示的bug新增特性返回表显示页面自动定位到最新改动的table 07/25-07/27添加索引列，新增设置索引功能增加索引同步功能（包括索引的增加、删除）重写数据库同步xml部分，优化索引的建立删除，使其能像其他字段一样简单使用xml执行界面添加用户误操作的警告和提示（如，用户添加字段名相同的行） 07/30-08/01优化对比界面(更好的对比显示，实现左右页面同步滚动）简化用户操作(现在不用点击就可以选到鼠标指定行，删除操作也更方便）更改logo 08/01-08/03添加单行同步与撤销操作功能 主要构成 DBconnection：SQLServer数据库连接工具类主要功能：配置连接信息；打开、关闭数据库连接；执行sql语句获得结果（以ShowDatabaseList方法为例，用sql语句查询服务器中所有数据库名，将该结果存入sRead供前端窗口调用显示） FormLogin：登录窗口主要功能：获取连接信息更新： 保存连接信息（记住密码） 检索数据库（用于选择登入那个数据库） FormMainTableShow：主窗口主要功能：主要逻辑业务的展示和执行界面，包含各种响应事件（第一阶段后可查看连接到远程数据库中所有表格）更新： 改为只用来展示数据库中所有表名和显示表信息 提供选择xml文件的入口 ConfigerManager：登陆信息实体类主要功能：方便实现存储登录记录实现写在FormLogin各种事件中 DBconnnectionOracle：Oracle数据库连接工具类主要功能：与DBconnection相似 FormXMLExecute：主要功能窗口主要功能：解析显示xml表结构，提供添加或同步数据库表/表结构的功能,提供修改xml列表实时验证两表差异性的功能 MappingTool：映射java类型到数据库的字段类型的工具类主要功能：解析保存映射信息的xml，将java类型，转换成保存数据库字段类型和对应默认字段长度的Dictionary。 XMLParsing：解析提供表结构的xml的工具类主要功能：将xml保存的表结构，解析出表名和字段名，字段类型 ParsedInfo：xml信息的实体类主要功能：保存xml解析出来的表结构信息 DBmodify：执行增删改数据库字段、增删索引的工具类 RowRecord:记录DGV中行信息的实体类主要功能：保存对xml显示部分增删改之前的行信息，用于实现撤销操作 参考页面 关于数据库表结构","categories":[],"tags":[{"name":"C#实战","slug":"C-实战","permalink":"https://xiaotong1996.github.io/tags/C-实战/"}]},{"title":"深入理解C#（十六）：Lambda表达式和表达树","slug":"深入理解C-（十六）：Lambda表达式和表达树","date":"2019-01-09T09:56:26.000Z","updated":"2019-01-09T09:56:58.712Z","comments":true,"path":"2019/01/09/深入理解C-（十六）：Lambda表达式和表达树/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（十六）：Lambda表达式和表达树/","excerpt":"","text":"深入理解C#（十六）*第九章（C# 3：Lambda表达式和表达树）lambda=λ 作为委托的lambda表达式Func&lt;…&gt;委托类型简介.NET3.5的System命名空间中，有5个泛型Func委托类型。每个委托签名都获取0~4个参数，其类型使用类型参数来指定。最后一个类型参数用作每种情况下的返回类型。例如：Func&lt;string,double,int&gt;等价于public delegate int SomeDelegate(string arg1,double arg2) 转换成lambda表达式用匿名方法来创建委托实例 123Func&lt;string,int&gt; returnLength;returnLength=delegate(string text)&#123;return text.Length;&#125;;Console.WriteLine(returnLength(&quot;Hello&quot;)); Lambda表达式最冗长的形式是：(显示类型的参数列表）=》{语句}例子： 1234Func&lt;string, int&gt; returnLength;returnLength = (string text) =&gt; &#123; return text.Length; &#125;;Console.WriteLine(returnLength(&quot;Hello&quot;)); Lambda表达式有着和匿名方法控制返回语句一样的规则：不能从Lambda表达式返回void类型 使用单一表达式作为主体大多数情况可以用一个表达式来表示整个主体，该表达式的值是Lambda的结果 1（string text)=&gt;text.Length 隐式类型的参数列表编译器能推断出参数类型，可以不用显示声明参数类型，注意：隐式和显示类型参数不能一起用。此外要是有out或ref参数，只能使用显示参数。 1(text)=&gt;text.Length 单一参数的快捷语法如果lambda表达式只需要一个参数，且那个参数可以隐式指定类型，可以省略圆括号 1text=&gt;text.Length 现在，例子简化成： 1234 Func&lt;string, int&gt; returnLength;returnLength = text =&gt; text.Length;Console.WriteLine(returnLength(&quot;Hello&quot;)); 高阶函数Lambda表达式主体可以包含另一个Lambda表达式，另外，Lambda表达式的参数可以是另一个委托 使用List和事件的简单例子列表的过滤、排序和操作List的FindAll方法，获取一个Predicate,并返回一个新列表，包含原始列表中与谓词匹配的所有元素。Sort方法获取一个Comparison,并相应地对列表进行排序。ForEach方法获取一个Action,并对每个元素执行特定行为。 123456789101112131415161718192021222324252627282930var films = new List&lt;Film&gt;&#123; new Film &#123;Name=&quot;Jaws&quot;, Year=1975&#125;, new Film &#123;Name=&quot;Singing in the Rain&quot;, Year=1952&#125;, new Film &#123;Name=&quot;Some like it Hot&quot;, Year=1959&#125;, new Film &#123;Name=&quot;The Wizard of Oz&quot;, Year=1939&#125;, new Film &#123;Name=&quot;It&apos;s a Wonderful Life&quot;, Year=1946&#125;, new Film &#123;Name=&quot;American Beauty&quot;, Year=1999&#125;, new Film &#123;Name=&quot;High Fidelity&quot;, Year=2000&#125;, new Film &#123;Name=&quot;The Usual Suspects&quot;, Year=1995&#125;&#125;;Action&lt;Film&gt; print = film =&gt; Console.WriteLine(&quot;Name=&#123;0&#125;, Year=&#123;1&#125;&quot;, film.Name, film.Year);// Note: extra lines added for clarity when runningConsole.WriteLine(&quot;All films&quot;);films.ForEach(print);Console.WriteLine();Console.WriteLine(&quot;Oldies&quot;);films.FindAll(film =&gt; film.Year &lt; 1960) .ForEach(print);Console.WriteLine();Console.WriteLine(&quot;Sorted&quot;);films.Sort((f1, f2) =&gt; f1.Name.CompareTo(f2.Name));films.ForEach(print);Console.Read(); 创建委托实例,用来打印列表中的项，因为之后会使用三次，所以用变量print来保存，而不用每次都单独使用一个Lambda表达式。它可以打印一个film类型，通过foreach就能打印整个列表。Action&lt;Film&gt; print = film =&gt; Console.WriteLine(&quot;Name={0}, Year={1}&quot;, film.Name, film.Year); 1`films.ForEach(print);` 在事件处理程序中进行记录123456789101112131415161718192021222324252627static void Log(string title, object sender, EventArgs e)&#123; Console.WriteLine(&quot;Event: &#123;0&#125;&quot;, title); Console.WriteLine(&quot; Sender: &#123;0&#125;&quot;, sender); Console.WriteLine(&quot; Arguments: &#123;0&#125;&quot;, e.GetType()); foreach (PropertyDescriptor prop in TypeDescriptor.GetProperties(e)) &#123; string name = prop.DisplayName; object value = prop.GetValue(e); Console.WriteLine(&quot; &#123;0&#125;=&#123;1&#125;&quot;, name, value); &#125;&#125;static void Main()&#123; Button button = new Button(); button.Text = &quot;Click me&quot;; button.Click += (src, e) =&gt; Log(&quot;Click&quot;, src, e); button.KeyPress += (src, e) =&gt; Log(&quot;KeyPress&quot;, src, e); button.MouseClick += (src, e) =&gt; Log(&quot;MouseClick&quot;, src, e); Form form = new Form(); form.AutoSize = true; form.Controls.Add(button); Application.Run(form);&#125; 表达式树以编程方式构建表达式树，编译并执行1234567Expression firstArg = Expression.Constant(2);Expression secondArg = Expression.Constant(3);Expression add = Expression.Add(firstArg, secondArg);Func&lt;int&gt; compiled = Expression.Lambda&lt;Func&lt;int&gt;&gt;(add).Compile();Console.WriteLine(compiled());Console.Read(); 将C# Lambda表达式转换成表达式树123Expression&lt;Func&lt;int&gt;&gt; return5 = () =&gt; 5;Func&lt;int&gt; compiled = return5.Compile();Console.WriteLine(compiled()); （）=》 5是Lambda表达式","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（十五）：智能编译器","slug":"深入理解C-（十五）：智能编译器","date":"2019-01-09T09:55:42.000Z","updated":"2019-01-09T09:56:04.804Z","comments":true,"path":"2019/01/09/深入理解C-（十五）：智能编译器/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（十五）：智能编译器/","excerpt":"","text":"深入理解C#（十五）*第八章（C# 3：用智能的编译器来防错） 自动实现的属性简化普通属性的代码普通属性：可读/可写并将值存储到一个非常直观的私有变量中的属性。 1public string Name&#123;get;set;&#125; 仍然可以为取值和赋值方法指定不同的访问权限。 静态自动属性：取值方法是共有的，赋值方法是私有的，且赋值方法只能在类型初始化程序中使用。 定义struct时，使用自动属性，需要显式地调用无参构造函数 12345678public struct Foo&#123; public int Value&#123;get;private set;&#125; public Foo(int value):this() &#123; this.Value=value; &#125;&#125; 自动属性仍有几个小问题： 没办法在声明时，设定初始的默认值 没法把它们设定成真正的只读属性（使用私有赋值方法来解决） 隐式类型的局部变量使用var声明局部变量var并没有把C#变成动态类型或者弱类型的语言，只是类型由编译器推断编译器获取初始化表达式在编译时的类型，并使变量也具有那种类型。 隐式类型的限制只有在一下情况能使用： 局部变量，不是静态字段和实例字段 声明的同时被初始化 初始化表达式不是方法组和匿名函数 初始化表达式不是null 语句中之声明了一个变量 初始化表达式不包含正在声明的变量 对于第三点，显示声明变量是可以的，如：var starter = (ThreadStart)delegate(){ Console.WriteLine();}对于null也可以做强制类型转换，但是无意义。 最常见应用：用方法调用的结果来初始化一个变量。 隐式类型的优缺点优点：增强可读性，改变代码重心缺点：类型不明确 简化的初始化定义示例类型new Person{Name=&quot;Jon&quot;,Age=36} 为嵌入对象设置属性1234Person tom=new Person(&quot;Tom&quot;)&#123;Age=9,Home=&#123;Country=&quot;UK&quot;,Town=&quot;Reading&quot;&#125;&#125;; 集合初始化程序 使用集合初始化程序来创建新集合List&lt;string&gt; names=new List{ &quot;Holly&quot;,&quot;Jon&quot;,&quot;Tom&quot;};任何实现了IEnumerable类型，只要它为初始化列表中出现的每个元素都提供了一个恰当的公共的Add方法，就可以使用这个特性。 在其他对象初始化程序中填充集合 隐式类型的数组对于void MyMethod(string[] names)C#3 这样使用：MyMethod(new[] {&quot;Holly&quot;,&quot;Jon&quot;,&quot;Tom&quot;}); 匿名类型实例：使用匿名类型，填充数组 123456789101112131415var family = new[]&#123; new &#123; Name = &quot;Holly&quot;, Age = 37 &#125;, new &#123; Name = &quot;Jon&quot;, Age = 36 &#125;, new &#123; Name = &quot;Tom&quot;, Age = 9 &#125;, new &#123; Name = &quot;Robin&quot;, Age = 6 &#125;, new &#123; Name = &quot;William&quot;, Age = 6 &#125;&#125;;int totalAge = 0;foreach (var person in family)&#123; totalAge += person.Age;&#125;Console.WriteLine(&quot;Total age: &#123;0&#125;&quot;, totalAge); family中所有人具有相同的类型，否则编译器无法推断出何时类型。 匿名类型的成员 一个获取所有初始值的构造函数 共有的只读属性 属性的私有只读字段 重写的Equals、GethashCode和ToString 投影初始化程序实际使用时，往往希望从别的对象复制属性用以新建一个新的对象。 例如：new { Name=person.Name,IsAdult=(person.Age&gt;=18)}C# 3支持一种简化的语法：如果不指定属性名称，而只指定用于求指的表达式，它会使用表达式的最后一个部分作为名称，前提是它只是一个简单字段或属性。应用：new { person.Name, IsAdult=(Person.Age&gt;=18)}","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（十四）：其他特性","slug":"深入理解C-（十四）：其他特性","date":"2019-01-09T09:54:09.000Z","updated":"2019-01-09T09:54:32.790Z","comments":true,"path":"2019/01/09/深入理解C-（十四）：其他特性/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（十四）：其他特性/","excerpt":"","text":"深入理解C#（十四）*第七章（C# 2：其他特性）分部类型，静态类，独立的取值方法，命名空间别名，Pragma指令，固定大小的缓冲区，InternalsVisibleToAttribute（友元程序集） 分部类型在多个文件中创建一个类型创建分部类型，只需要加上partial关键字。编译器实际上是在编译之前把所有源文件合并在一起。（这就是为什么C#文件名和类名可以不一致了，同样一个class Example，可以用分部类型，写多个Example1/2/…cs文件 举例： 123456789 partial class Example&lt;TFirst, TSecond&gt; : IEquatable&lt;string&gt; where TFirst : class&#123; public bool Equals(string other) &#123; return false; &#125;&#125; 在这个文件中声明接口和类型参数约束 1234567 partial class Example&lt;TFirst, TSecond&gt; : EventArgs, IDisposable&#123; public void Dispose() &#123; &#125;&#125; 在这个文件中声明基类和接口 分布类型的使用分布类型的用途： 主要联接设计器和其他代码生成器 辅助进行重构 单元测试 C# 3的分部方法分部方法的声明与抽象方法相同:使用partial修饰符无须实现，在实际的实现部分也要partial修饰符。分部方法可以不被实现，这些未被实现的分部方法的调用会被编译器移除。由于方法可能不存在，分部方法返回类型必须为void，且不能获取out参数。必须是私有的 静态类型独立的取值方法/赋值方法属性访问器举例：​ 123456string name;public string Name&#123; get&#123;return name;&#125; private set&#123; name=value;&#125;&#125; Name属性对于其他所有类型都是只读的，但在类型内部能用属性语法设置。大部分的默认访问修饰符是私有的，但对于取值/赋值方法，访问修饰符和属性本身整体上保持一致另外不能把属性设为私有，但把取值方法设为公有 命名空间别名限定的命名控件别名C# 1例子：​ 1234567891011121314151617using System;using System.ComponentModel;using WebForms = System.Web.UI.WebControls;using WinForms = System.Windows.Forms;namespace Chapter07&#123;[Description(&quot;Listing 7.05&quot;)]class SimpleAliases&#123; static void Main() &#123; Console.WriteLine (typeof (WinForms.Button)); Console.WriteLine (typeof (WebForms.Button)); &#125;&#125;&#125; 若有一个类也叫WinForms，那编译器该如何区分？C# 2改进： 123456789101112131415161718192021using System;using System.ComponentModel;using WebForms = System.Web.UI.WebControls;using WinForms = System.Windows.Forms;namespace Chapter07&#123;[Description(&quot;Listing 7.06&quot;)]class DoubleColonForAliases&#123; class WinForms &#123; &#125; static void Main() &#123; Console.WriteLine (typeof (WinForms::Button)); Console.WriteLine (typeof (WebForms::Button)); &#125;&#125;&#125; 引入“::“来区分命名空间和类型 全局命名空间别名无法为命名空间层级的根或全局命名空间定义别名。可以使用global:: 外部别名pragma指令pragma指令是一个由#pragma开头的代码行所表示的预处理指令，它后面能包含任何文本。 警告pragma举例：例如我们使用了一个从未使用的变量，但想要忽略编译器警告 123#pragma warning disable 0169int x;#pragma warning restore 0169 校验和pragma非安全代码中固定大小的缓冲区把内部成员暴露给选定的程序集","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（十三）：迭代器","slug":"深入理解C-（十三）：迭代器","date":"2019-01-09T09:53:26.000Z","updated":"2019-01-09T09:53:48.114Z","comments":true,"path":"2019/01/09/深入理解C-（十三）：迭代器/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（十三）：迭代器/","excerpt":"","text":"深入理解C#（十三）*第六章（C# 2：实现迭代器的捷径） 知识简介迭代器模式：行为模式的一种范例，允许访问一个数据项序列中的所有元素，而不用关心序列的类型。能有效构建一个数据管道。(数据项序列进入数据管道后，经过一系列不同的转换或过滤后再从另一端出来）行为模式：一种简化对象之间通信的设计模式 迭代器模式通过IEnumerator和IEnumerable接口以及它们的泛型等价物来封装。若某个类型实现了IEnumerable接口，就意味着它可以被迭代访问。 难点在于怎么自建迭代器 C# 2：利用yield语句简化迭代器利用C# 2和yield return来迭代实例集合： 123456public IEnumerator GetEnumerator()&#123; for(int index=0;index&lt;values.Length;index++) &#123; yield return values[(index+startingPoint)%values.Length]; &#125;&#125; 这是一个实现迭代器块的方法，这个方法被声明为返回一个IEnumerator接口，所以就只能使用迭代器块来实现返回类型为IEnumerable、IEnumerator等的方法。如果方法声明的返回类型是非泛型接口，那么迭代器块的生成类型(yield type)是object，否则就是泛型接口的类型参数。如：方法声明返回IEnumerable,就会得到string类型的生成类型。在迭代器块中存在try/catch或try/finally代码块时，不能在try和finally中使用yield return编写迭代器块代码实际上是在请求编译器创建一个状态机当编译器看到迭代器块时，会为状态机创建一个嵌套类型，来正确记录块中的位置，以及局部变量（包括参数）的值。这个状态机实现一下功能： 必须具有某个初始状态 每次调用MoveNext，提供下一个值之前（执行到yield return语句之前），执行GetEnumerator方法中的代码 使用Current属性时，返回生成的上一个值 知道何时完成生成值的操作，以便MoveNext返回false 迭代器的工作流程 在第一次调用MoveNext之前，CreateEnumerable不会被调用 所有工作在调用MoveNext时就完成了，获取Current的值，不执行任何代码 在yield return的位置，代码就停止执行，在下一次调用MoveNext时又继续执行 在一个方法中的不同地方可以编写多个yield return语句 代码不会在最后的yield return处结束，而是通过返回false的MoveNext调用来结束 进一步了解yield return语句临时推出了方法，知道再次调用MoveNext后继续执行，根本没有检查finally代码块的行为。迭代器块不能实现具有ref或out参数的方法yield break结束迭代器的执行,类似于普通方法中的return语句finally在迭代器块中常用于释放资源，通常与using语句配合使用 迭代器示例迭代时刻表中的日期C# 1 123for(DataTime day=timetable.StartDate; day&lt;=timetable.EndDate; day=day.AddDays(1)) C# 2​ foreach(DateTime day in timetable.DateRange)想要手动实现迭代器很麻烦，但用迭代器块就很方便。为表示时刻表的类添加一个属性： 123456789101112public IEnumerable&lt;DateTime&gt; dateRange&#123; get &#123; for(DateTime day=StartDate； day&lt;=EndDate; day=day.AddDays(1)) &#123; yield return day; &#125; &#125;&#125; 迭代文件中的行在.NET 4中，框架提供了reader.ReadLines来实现,如何自己轻松实现？C# 1 12345678using(TextReader reader=File.OpenText(filename))&#123; string line; while((line=reader.ReadLine()) != null) &#123; //针对line进行操作 &#125;&#125; 获取TextReader 管理TextReader的生命周期（using） 迭代TextReader.ReadLine返回的行 对这些行处理 生命周期管理和迭代机制都是样板代码，有两种方法改进。一。使用委托，编写一个工具方法，将阅读器和委托作为参数，为文件中的每一行调用该委托，最后关闭阅读器。二。使用迭代器一次返回文件中的一行，如下 12345678910111213141516public static IEnumerable&lt;string&gt; ReadLines(string filename) &#123; using (TextReader reader = File.OpenText(filename)) &#123; string line; while ((line = reader.ReadLine()) != null) &#123; yield return line; &#125; &#125; &#125;foreach (string line in ReadLines(@&quot;文件路径&quot;)) &#123; Console.WriteLine(line); &#125; 进一步改进：如果我们想从网络流中读取文本或使用UTF-8以外的编码格式，最简单的想法是重新修改方法签名，使其接受一个TextReader。但这个方案很糟糕，问题是，如果在第一次调用MoveNext（）之前发生了异常，就没有机会清理了。另外，若GetEnumerate人（）被调用两次，但它们使用相同的阅读器。 12345static IEnumerable&lt;String&gt; ReadLines（Func &lt;TextReader&gt; provider)&#123; using (TextReader reader=provider()) &#123; 。。。 使用迭代器块和谓词对进行延迟过滤看过linq后回来重看 CCR实现伪同步代码CCR（Concurrency and Coordination Runtime，并发和协调运行时）看完异步开发回来看 ​","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（十二）：匿名方法","slug":"深入理解C-（十二）：匿名方法","date":"2019-01-09T09:52:44.000Z","updated":"2019-01-09T09:53:05.878Z","comments":true,"path":"2019/01/09/深入理解C-（十二）：匿名方法/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（十二）：匿名方法/","excerpt":"","text":"深入理解C#（十二）*第五章（C# 2：进入快速通道的委托（下））匿名方法 使用匿名方法的内联委托操作C# 1中的问题：用特定签名来实现委托是很常见的情况。有时只需要一个委托来做一件很简单的事，但是必须创建一个完整的新方法。 匿名方法允许指定一个内联委托实例的操作，作为创建委托实例表达式的一部分。 简单的匿名方法实例：处理一个参数.NET 2.0有一个泛型委托类型Action,它的签名如下：public delegate void Action&lt;T&gt;(T obj)Action就是对T的一个实例执行某些操作。如Action可以反转字符串并打印出来，Action可以打印传给它的那个数的平方根，Action&lt;IList&gt;可以计算出传给它的所有数的平均值并打印。实例： 123456Action&lt;string&gt; printReverse = delegate (string text)&#123;char[] chars = text.ToCharArray();Array.Reverse(chars);Console.WriteLine(new string(chars));&#125;; 匿名方法的语法：delegate关键字，参数，代码块（定义对委托实例的操作）匿名方法的结果是一个委托实例，和调用普通方法一样调用委托。 1printReverse(&quot;hello world&quot;); 逆变性不适用于匿名方法：必须指定和委托类型完全匹配的参数类型 匿名方法的是实现，是在IL中为源代码中断每个匿名方法创建一个方法 一个更精简的极端例子：体现匿名方法的一般用法，即作为传给另一个方法的参数使用。 12345678List&lt;int&gt; x = new List&lt;int&gt;();x.Add(5);x.Add(10);x.Add(15);x.Add(20);x.Add(25);x.ForEach(delegate (int n) &#123; Console.WriteLine(Math.Sqrt(n)); &#125;); 匿名方法的返回值12345Predicate&lt;int&gt; isEven = delegate (int x) &#123; return x % 2 == 0; &#125;;Console.WriteLine(isEven(1));Console.WriteLine(isEven(4)); 没有必要再声明一个返回类型，因为编译器会检查是否所有可能返回值都兼容于委托类型声明的返回类型。 忽略委托参数12345678910111213141516 class IgnoredParametersAnonymousMethods&#123; static void Main() &#123; Button button = new Button(); button.Text = &quot;Click me&quot;; button.Click += delegate &#123; Console.WriteLine(&quot;LogPlain&quot;); &#125;; button.KeyPress += delegate &#123; Console.WriteLine(&quot;LogKey&quot;); &#125;; button.MouseClick += delegate &#123; Console.WriteLine(&quot;LogMouse&quot;); &#125;; Form form = new Form(); form.AutoSize = true; form.Controls.Add(button); Application.Run(form); &#125;&#125; 一般写法：button.Click+=delegate(object sender,EventArgs e){...} 匿名方法中的捕获变量匿名方法外部对变量的更改在匿名方法内部是可见的，反之亦然。 12345678910111213141516171819static void Main()&#123;string captured = &quot;before x is created&quot;;MethodInvoker x = delegate&#123; Console.WriteLine(captured); captured = &quot;changed by x&quot;;&#125;;captured = &quot;directly before x is invoked&quot;;x();Console.WriteLine(captured);captured = &quot;before second invocation&quot;;x();Console.Read();&#125; 创建委托实例不会导致执行在整个方法中，我们使用的始终是同一个captured变量 捕获变量的实际用处能简化避免专门创建一些类来存储一个委托需要处理的信息（除了作为参数传递信息之外） 1234List&lt;Person&gt; FindAllYoungerThan(List&lt;Person&gt; people,int limit)&#123; return people.FinaAll(delegate(Person person)&#123; return person.Age&lt;limit;&#125;);&#125; 我们在委托实例内部捕获了limit参数，若不支持捕获变量，就不能使用作为参数传递的limit 捕获变量的延长生存期对于一个捕获变量，只要还有任何委托实例在引用它，它就会一直存在 局部变量实例化每声明一次局部变量，它就被实例化一次。 捕获变量的使用规则和小结 只在复杂情况下使用 捕获有for或foreach语句声明的变量之前，思考委托是否需要在循环迭代结束后延续，不是则在循环内另建一个变量来复制想要的值。 若创建多个委托实例，且捕获了变量，思考是否希望它们捕捉同一个变量 如果捕获的变量不发生改变，无需担心","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（十一）：改进的委托","slug":"深入理解C-（十一）：改进的委托","date":"2019-01-09T09:51:56.000Z","updated":"2019-01-09T09:52:22.000Z","comments":true,"path":"2019/01/09/深入理解C-（十一）：改进的委托/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（十一）：改进的委托/","excerpt":"","text":"深入理解C#（十一）*第五章（C# 2：进入快速通道的委托（上）） 回顾C# 1中我们的做法总是先定义事件/委托实际要处理的方法，如： 1234static void LogKeyEvent(object sender, KeyPressEventArgs e) &#123; Console.WriteLine(&quot;LogKey&quot;); &#125; 然后new一个新的事件/委托实例，把这个方法加到委托列表中，如：​ 1button.KeyPress += new KeyPressEventHandler(LogKeyEvent); 我们总是要把委托实例实际执行的代码做参数穿给委托实例，这样绕弯子会使代码难以阅读，且使得类中填充了大量只用于委托的方法。 方法组转换C# 2支持从方法组到一个兼容委托类型的隐式转换。方法组（method group）其实就是一个方法名，可以选择添加一个目标，也就是说和C# 1中创建委托实例使用的表达式相同（含义不同，一个是类型加参数，一个是方法组）。新的隐式转换：​ 1button.KeyPress+=LogkeyEvent; 一个创建线程的代码： 1Thread t=new Thread(MyMethod); 为什么表达式如LogKeyEvent属于方法组，因为如果有重载的话，可能不止一个方法适用。隐式转换会将一个方法组转换为具有兼容签名的任意委托类型。假定有以下两个方法签名： 12void MyMethod()void MyMethod(object sender,EventArgs e) 那么在向一个ThreadStart或EventHandler赋值时，都可以将MyMethod作为方法组使用： 12ThreadStart x=MyMethod;EventHandler y=MyMethod； 对于本身已重载成可以获取一个ThreadStart或EventHandler的方法，不能把它作为方法的参数使用。同样，不能利用隐式方法组转换来转换成普通的System.Delegate类型。可用辅助方法、强制转换或中间变量来解决。 协变性和逆变性委托参数的逆变性举例说明： 123public delegate void EventHandler(object sender,EventArgs e)public delegate void KeyPressEventHandler(object sender, KeyPressEventArgs e)public delegate void MouseEventHandler(object sender,MouseEventArgs e) 有三个委托类型的签名：KeyPressEventArgs和MouseEventArgs都是从EventArgs派生利用方法组转换和委托逆变性： 123456789101112131415161718static void LogPlainEvent(object sender, EventArgs e)&#123; Console.WriteLine (&quot;An event occurred&quot;);&#125;static void Main()&#123; Button button = new Button(); button.Text = &quot;Click me&quot;; button.Click += LogPlainEvent; button.KeyPress += LogPlainEvent; button.MouseClick += LogPlainEvent; Form form = new Form(); form.AutoSize = true; form.Controls.Add(button); Application.Run(form);&#125; 用一个事件处理方法来处理所有事件。 关于事件处理方法的参数说明：第一个参数是object类型，代表事件来源；第二个参数则负责携带与事件有关的任何额外信息 在有委托参数协变性后，我们可以使用一个具有EventHandler签名的方法，作为符合约定的所有委托类型的操作。 委托返回类型的协变性举例：首先声明一个委托类型 1delegate Stream StreamFactory(); 然后声明一个方法返回一个特定的流类型。 123456789static MemoryStream GenerateSampleData()&#123; byte[] buffer = new byte[16]; for (int i = 0; i &lt; buffer.Length; i++) &#123; buffer[i] = (byte)i; &#125; return new MemoryStream(buffer);&#125; 利用协变性转换方法组 123456789101112131415static void Main()&#123; StreamFactory factory = GenerateSampleData; using (Stream stream = factory()) //调用委托 &#123; int data; while ((data = stream.ReadByte()) != -1) &#123; Console.WriteLine(data); &#125; &#125; Console.Read();&#125; 注意：委托的返回类型是stream,但声明的方法的返回类型是MemoryStream。StreamFactory factory = GenerateSampleData;这句话用到了方法组的转换，并利用返回类型的协变性来允许GenerateSampleData用于StreamFactory，等到调用委托实例时，实际返回的是委托声明的类型，也就是说返回类型已从MemoryStream协变成stream 利用协变性和逆变性，还可以基于一个委托实例来构造另一个委托实例。 12EventHandler general=new EventHandler(HandleEvent);KeyPressEventHandler key=new KeyPressEventHandler(general); 不兼容的风险可能发生在派生类中。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（十）：可空类型","slug":"深入理解C-（十）：可空类型","date":"2019-01-09T09:50:43.000Z","updated":"2019-01-09T09:51:24.884Z","comments":true,"path":"2019/01/09/深入理解C-（十）：可空类型/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（十）：可空类型/","excerpt":"","text":"深入理解C#（十）*第四章（C# 2：可空类型） C# 1中表示空值的模式 魔值：牺牲一个值来表示空值（DBNull.Value表示数据库返回null的情况，这个魔值表示所有类型的空值） 引用包装类型：直接用object作为变量类型，并根据需要进行装箱和拆箱 额外的布尔标志：使用一个普通的值类型的值，同时使用另一个布尔标志来表示值是“真正”存在还是被忽略。要么在代码中维护两个单独的变量，要么将值和标志封装到另一个值类型中。 System.Nullable&lt;T&gt;和System.NullableNullable&lt;T&gt;是一个有着值类型约束的泛型类型。T的类型称为可空类型的基础类型(underlying type)。Nullable&lt;T&gt;有两个重要属性：HasValue和Value。就是采用上面第三种实现模式。Nullable&lt;T&gt;仍为值类型，值将直接包含一个bool和一个int，而不是其他对象的引用Nullable&lt;T&gt;引入一个名为GetValueOrDefault的新方法。存在值就返回值否则返回默认值/自己指定的返回值。Nullable&lt;T&gt;覆盖了其他方法：GetHashCode,ToString和Equals。GetHashCode在没有值时返回0，ToString在没有值时返回空字符串再次强调Nullable&lt;T&gt;是一个结构（值类型),如果把它转换成引用类型，需要对它装箱调用first.Equals(second)的具体规则：​ first没有值，second为null，相等 first没有值，second不为null，不相等 first有值，second为null，不相等 否则，若first的值等于second，相等 System.Nullable类是一个静态类，只包含静态方法。提供三个有用方法： 123public static int Compare&lt;T&gt;(Nullable&lt;T&gt; n1,Nullable&lt;T&gt; n2)public static bool Equals&lt;T&gt;(Nullable&lt;T&gt; n1,Nullable&lt;T&gt; n2)public static Type GetUnderlyingType(Type nullableType) Compare使用Comparer.Default来比较两个基础值，Equals使用EqualityComparer.Default。空值与空值相等，小于其他所有值。第三个方法如果参数是一个可空类型，方法就返回它的基础类型；否则返回null。 C# 2为可空类型提供的语法糖？修饰符Nullable&lt;byte&gt;与byte?可相互转换 使用null进行赋值和比较可空转换和操作符如果一个非可空的值类型支持一个操作符或一种转换，且那个操作符或转换只涉及其他非可空的值类型时，那么对应可空的值类型也支持同样的操作符或转换。举例：int=》long，int？=》long？具体细节待看 可空逻辑对可空类型使用as操作符在C# 2之前，as只能用于引用类型。在C# 2中，也可以用于可空类型。 空合并操作符（？？）first？？second 对first进行求值； 如结果非空，该结果就是表达式的结果 否则求second的值，其结果为整个表达式的结果这个操作符还可用于可空值类型+引用类型这个操作符是右结合的 用法案例：假设有一个在线订购系统，有billing address（账单寄送地址），contact address（联系地址），以及shipping address（送货地址）等，任何用户都必须有一个billing address，但contact address是可选的。对于一个订单来说，送货地址也是可选的，默认为billing address。遇到送货问题，要找联系人时。C# 1实现：​ 123456789Address contact=user.ContactAddress;if(contact==null)&#123; contact=order.ShippingAddress; if(contact==null) &#123; contact=user.BillingAddress; &#125;&#125; C# 2改进： 123Address contact=user.ContactAddress?? order.ShippingAddress?? user.BilllingAddress; 可空类型的新奇用法尝试一个不使用输出参数的操作输出参数的常规用法：用一个返回值来判断一个操作是否成功，并用一个输出参数来返回真正的结果。返回引用类型的方法经常使用这样一种模式：失败时返回null，成功是返回非空值。但是，假如在方法执行成功的前提下，null也是一个有效的返回值，这样就不行了。 1234567ArrayList list=hash[key];if(list==null)&#123; list=new ArrayList(); hash[key]=list;&#125;list.Add(newItem); 假设HashTable和Dictionary&lt;Tkey,TValue&gt;可以获取一个委托，每次查找到一个不存在的键时就调用这个委托来添加一个新值。使用这个模式适用这种情况。使用可空类型，能将这种模式扩展至值类型。 具体实例： 1public static bool TryParse(string s, out Int32 result); 这个int的方法的传统用法如下： 12345678910int result; if (int.TryParse(&quot;Not valid&quot;, out result))&#123; Console.WriteLine(&quot;Parsed to &#123;0&#125;&quot;, result);&#125;else&#123; Console.WriteLine(&quot;Couldn&apos;t parse&quot;);&#125;Console.Read(); 如果我们用可空类型： class NullableTryParse ​ {​ static int? TryParse(string data)​ {​ int ret;​ if (int.TryParse(data, out ret))​ {​ return ret;​ }​ else​ {​ return null;​ }​ } 12345678910111213 static void Main() &#123; int? parsed = TryParse(&quot;Not valid&quot;); if (parsed != null) &#123; Console.WriteLine(&quot;Parsed to &#123;0&#125;&quot;, parsed.Value); &#125; else &#123; Console.WriteLine(&quot;Couldn&apos;t parse&quot;); &#125; &#125;&#125; 这样做的好处是它将返回值与解析是否成功封装在一个变量中，还把做和测试分离了。还有一个好处是可以和空合并操作符配合使用。小结一下：上述模式的要点在于：先定义并获取方法返回值（做），再判断返回值（测试）。如返回值是引用类型，我们可以通过判断是否为null，很容易实现这个模式，但若是值类型，就不好办了（除非我们定义一个特殊值，但这样会导致语义不明，就像魔数一样），所以就用到了可空类型，这样我们也能像使用引用类型一样，使用值类型。更好的做法：在.NET 4中包含了Tuple类型，使用元祖可以使返回值含义更明确。 空合并操作符简化比较问题背景：假设要写一个电子商务网站，且有一个产品列表。希望按流行度，价格，名称依次排序。C# 1的实现： 1234567891011121314public int Compare(Product first,Product second)&#123; int ret=second.Popularity.CompareTo(first.Popularity); if( ret !=0) &#123; return ret; &#125; ret=first.Price.CompareTo(second.Price); if(ret ！=0） &#123; return ret； &#125; return first.Name.CompareTo(second.Name);&#125; 我们往往这样写Compare方法。但若是属性返回为null，我们在比较前还要先判断非空，这样代码就太复杂了。我们可以用空合并操作符来简化代码。 C# 2 ？？操作符实现： 12345678910111213141516171819202122232425262728293031public static class PartialComparer&#123; public static int? Compare&lt;T&gt;(T first, T second) &#123; return Compare(Comparer&lt;T&gt;.Default, first, second); &#125; public static int? Compare&lt;T&gt;(IComparer&lt;T&gt; comparer,T first,T second) &#123; int ret = comparer.Compare(first, second); return ret == 0 ? new int?() : ret; &#125; public static int? ReferenceCompare&lt;T&gt;(T first, T second) where T : class &#123; return first == second ? 0 : first == null ? -1 : second == null ? 1 : new int?(); &#125; public static bool? ReferenceEquals&lt;T&gt;(T first, T second) where T : class &#123; return first == second ? true : first == null ? false : second == null ? false : new bool?(); &#125;&#125; 先实现一个用于比较的辅助类。可注意ReferenceCompare方法中的条件操作符用法。现在可以重写Compare方法： 123456789public int Compare(Product first, Product second) &#123; return PartialComparer.ReferenceCompare(first, second) ?? // Reverse comparison of popularity to sort descending PartialComparer.Compare(second.Popularity, first.Popularity) ?? PartialComparer.Compare(first.Price, second.Price) ?? PartialComparer.Compare(first.Name, second.Name) ?? 0; &#125; 最后的0指明前面所有比较都通过，这两个Product相等。也可用Comparer&lt;string&gt;.Default.Compare(first.Name,second.Name)作比较。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（九）：泛型","slug":"深入理解C-（九）：泛型","date":"2019-01-09T09:50:00.000Z","updated":"2019-01-09T09:50:23.456Z","comments":true,"path":"2019/01/09/深入理解C-（九）：泛型/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（九）：泛型/","excerpt":"","text":"深入理解C#（九）*第三章（C# 2：泛型实现参数化类型） 理解泛型类型和方法泛型方法的类型推断例子： 123static List&lt;T&gt; MakeList&lt;T&gt;(T first,T second)...List&lt;string&gt; list=MakeList&lt;string&gt;(&quot;Line 1&quot;,&quot;Line 2&quot;); 使用编译器的类型推断： 1List&lt;string&gt; list=MakeList(&quot;Line 1&quot;,&quot;Line 2&quot;); 类型约束如List等，所有类型参数都可以指定为任意类型，它们未被约束。我们想制定规则，从而判断哪些是泛型类型或泛型方法呢能接受的有效类型实参。用约束来实现。约束放在泛型方法或泛型类型声明的末尾，有上下文关键字where引入。 引用类型约束确保使用的类型实参是引用类型：必须是第一个约束struct RefSample&lt;T&gt; where T:class以这种方式约束一个类型参数后，可以使用==和！=来比较引用（包括null） 值类型约束确保使用的类型实参是值类型:class ValSample&lt;T&gt; where T:structbr&gt;设定值类型约束后，不允许使用==和！=进行比较。以上两种约束比较少用，后两者更有用。 构造函数类型约束检查类型实参是否有一个可用于创建类型实力的无参构造函数。必须是最后一个约束。public T CreateInstance() where T : new() { return new T(); }在使用工厂风格的设计模式时，这个约束非常有用。 转换类型约束指定另一个类型，类型实参必须可以通过一致性、引用或装箱隐式地转换为该类型。还可以规定一个类型实参必须可以转换为另一个类型实参。这个约束意味着“在类型参数的实例上使用指定类型的成员” 实现泛型假装T是一个真正的类型名称。额外要注意： 默认值表达式：例子：Dictionary&lt;TKey,TValue&gt;有一个TryGetValue方法：用一个输出参数来接受你打算获取的值，用boolean返回值显示是否成功。这意味着方法必须用TValue类型的值来填充输出参数。C# 2提供了默认值表达式(default value expression)。例子：以泛型方式将一个给定的值和默认值进行比较 class DefaultValueComparison {​ static int CompareToDefault(T value)​ where T : IComparable​ {​ return value.CompareTo(default(T));​ } 12345678static void Main()&#123; Console.WriteLine(CompareToDefault(&quot;x&quot;)); Console.WriteLine(CompareToDefault(10)); Console.WriteLine(CompareToDefault(0)); Console.WriteLine(CompareToDefault(-10)); Console.WriteLine(CompareToDefault(DateTime.MinValue));&#125; } 这个泛型方法规定了只能使用实现了IComparable接口的类型，这样才能为传入的值调用CompareTo（T） 类型推断只能用于泛型方法，有一个泛型类型，其中不包含任何泛型方法，怎么实现类型推断？Pair&lt;int,string&gt; pair=new Pair&lt;int,string&gt;(10,&quot;value&quot;);解决方法是使用包含泛型方法的非泛型辅助类。​ 123456789public static class Pair&#123; public static Pair&lt;T1,T2&gt; Of&lt;T1,T2&gt;(T1 first,T2 second) &#123; return new Pair&lt;T1,T2&gt;(first,second); &#125;&#125;Pair&lt;int,string&gt; pair=Pair.Of(10,&quot;value&quot;); 等到第七章再回看 直接比较如果一个类型参数是未约束的（即没有对其应用约束），那么只能在该类型的值与null比较时才能使用==和！=操作符。不能直接比较两个T类型的值。如果一个类型参数被约束成值类型，就完全不能为它使用==和！=。如果被约束成引用类型，具体比较将完全取决于类型参数被约束成什么类型。 高级泛型静态字段和静态构造函数每个封闭类型都有它自己的静态字段集同样的规则也适用于静态初始化程序和静态构造函数。 JIT(just in time即时)编译器如何处理泛型暂略 泛型迭代对集合执行的最常见操作之一是便利（迭代）所有元素。最简单的办法使用foreach语句。当需要为自己的某个类型实现迭代时，由于IEnumerable扩展了旧的IEnumerable接口，所以要实现两个不同方法：IEnumerator GetEnumerator();IEnumerator GetRnumerator(); 反射和泛型反射的一切都是围绕“检查对象及其类型”展开的。typeof可通过两种方式作用于泛型类型。一种方式是获取泛型类型定义，另一种方式是获取特定的已构造类型。typeof(Dictionary&lt;,&gt;)或typeof(Dictionary&lt;string,X&gt;) 获取泛型和已构造Type对象的各种方式​ 12345678910111213141516string listTypeName = &quot;System.Collections.Generic.List`1&quot;;Type defByName = Type.GetType(listTypeName);Type closedByName = Type.GetType(listTypeName + &quot;[System.String]&quot;);Type closedByMethod = defByName.MakeGenericType(typeof(string));Type closedByTypeof = typeof(List&lt;string&gt;);Console.WriteLine(closedByMethod == closedByName);Console.WriteLine(closedByName == closedByTypeof);Type defByTypeof = typeof(List&lt;&gt;);Type defByMethod = closedByName.GetGenericTypeDefinition();Console.WriteLine(defByMethod == defByName);Console.WriteLine(defByName == defByTypeof); 反射泛型方法 12345678910111213public static void PrintTypeParameter&lt;T&gt;()&#123;Console.WriteLine(typeof(T));&#125;static void Main()&#123;Type type = typeof(GenericMethodReflection);MethodInfo definition = type.GetMethod(&quot;PrintTypeParameter&quot;);MethodInfo constructed;constructed = definition.MakeGenericMethod(typeof(string));constructed.Invoke(null, null);&#125; 获取泛型方法定义 使用MakeGenericMethod返回一个已构造的泛型方法。 后去已构造的方法后，就可以调用了。 泛型在C#和其他语言中的一些限制为什么不能将List转换成List?泛型是不变的，但为什么数组是协变的？为了支持从JAVA中编译来的代码，因为Java有协变数组。 使用泛型辅助类解决逆变性缺乏问题 缺乏操作符约束或者数值约束解决方法： 表达式树，第九章 C# 4的动态特性，14章有例子 为什么泛型只限于类型（包括类、结构、委托和接口）和方法? 缺乏泛型属性、索引器和其他成员类型 第三章小结泛型的三个优点： 编译时的类型安全性 性能 代码的表现力IDE和编译器能提前验证代码 值类型性能上获益最大。在强类型的泛型API中，不再需要装箱和拆箱。使用泛型，代码能更清楚地表达其意图。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（八）：类型系统","slug":"深入理解C-（八）：类型系统","date":"2019-01-09T09:49:01.000Z","updated":"2019-01-09T09:49:34.394Z","comments":true,"path":"2019/01/09/深入理解C-（八）：类型系统/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（八）：类型系统/","excerpt":"","text":"深入理解C#（八）*第二章（C# 类型系统）C# 1的类型系统是静态的、显示的和安全的 静态：描述表达式的编译时类型，使用不变的数据来分析哪些操作可用。 C# 1的类型系统何时不够用.NET 1.1内建了三种集合类型： 数组–强类型–内建到语言和运行时中 System.Collections命名空间中的弱类型集合 System.Collections.Specialized命名空间中的强类型集合 引用类型的数组支持协变（covariance），只要元素的类型之间允许转换，就能隐式将一种数组类型转换成另一种 方法覆盖和接口实现不允许协变性/逆变性参数类型的逆变性：使用一个放宽限制的签名如：void Process(object x) 值类型和引用类型类是引用类型；结构是值类型数组是引用类型；枚举是值类型委托类型是引用类型；接口类型是引用类型，但可由值类型实现 变量存储 变量的值在它声明时的位置存储 局部变量的值总是存储在栈（stack）中（C# 1中完全成立，高级版本可能存在堆中） 实例变量的值总是存储在实例本身存储的地方 引用类型实例总是存储在堆（heap）中，静态变量也是。 关于引用传递和值传递无论是引用传递还是值传递，永远不会传递对象本身。详见Parameter passing in C# 关于装箱和拆箱 对于引用类型的变量，它的值永远是一个引用 对于值类型的变量，它的值永远是该值类型的一个值 int i=5;object o=i;int j=(int) o; 第二行，发生了装箱操作：运行时在堆上创建一个包含值（5）的对象，o的值是对该新对象的一个引用。该对象的值是原始值的一个副本，改变i不会改变箱内的值。 第三行，执行相反操作，拆箱。必须告诉编译器将object拆箱成什么类型。 装箱什么时候方式？为一个类型的值调用ToString、Equals或GetHashCode方法时，如果该类型没有覆盖这些方法，也发生装箱。另外，将值作为接口表达式使用时也会发生装箱。 太过频繁的装拆箱会增大程序的操作开销，还会创建数量众多的对象，加重垃圾回收器的负担。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（七）：委托","slug":"深入理解C-（七）：委托","date":"2019-01-09T09:47:56.000Z","updated":"2019-01-09T09:48:28.588Z","comments":true,"path":"2019/01/09/深入理解C-（七）：委托/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（七）：委托/","excerpt":"","text":"深入理解C#（七）*第二章（C# 1的核心基础）委托，类型系统的特征，值/引用类型 委托（delegate） 类似于C语言的函数指针 不指定一个要执行的行为，将这个行为用某种方式“包含在一个对象中” 1. 委托的构成 声明委托类型 必须有一个方法包含了要执行的代码 必须创建一个委托实例 必须调用invoke委托实例​namespace Chapter02​ {​ //声明委托类型​ delegate void StringProcessor(string input);​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Person&#123;string name;public Person(string name)&#123;this.name = name;&#125;//声明兼容的实例方法public void Say(string message)&#123;Console.WriteLine(&quot;&#123;0&#125; says: &#123;1&#125;&quot;, name, message);&#125;&#125;class Background&#123;//声明兼容发静态方法public static void Note(string note)&#123;Console.WriteLine(&quot;(&#123;0&#125;)&quot;, note);&#125;&#125;[Description(&quot;Listing 2.1&quot;)]class SimpleDelegateUse&#123;static void Main()&#123;Person jon = new Person(&quot;Jon&quot;);Person tom = new Person(&quot;Tom&quot;);//创建三个委托实例StringProcessor jonsVoice, tomsVoice, background;jonsVoice = new StringProcessor(jon.Say);tomsVoice = new StringProcessor(tom.Say);background = new StringProcessor(Background.Note);//调用委托实例jonsVoice(&quot;Hello, son.&quot;);tomsVoice.Invoke(&quot;Hello, Daddy!&quot;);background(&quot;An airplane flies past.&quot;);&#125;&#125;&#125; 具体步骤： 声明一个委托类型。 找到或写一个方法，具有和委托类型相同的签名，并能做我们想做的事情。 创建委托实例，指定在调用委托实例时，执行该方法。（创建委托实例，取决于操作使用实例方法还是静态方法。具体做法就是new一个我们声明的委托类型，把任意匹配的方法，作为参数传入） 调用委托实例，可以显示用Invoke方法调用，也可用简化语句直接调用。 类比：委托就像提前请律师打官司，声明委托类型就像指明要处理那种类型的案件，找到或写一个方法就像找到一个满足要求的律师，创建委托实例就像和律师签订协议，在需要时调用委托实例，就像遇上官司了，就要请律师出门解决。所以实际执行的方法是律师在做，委托只是提前签好协定，这样我们就可以在任何有需求的时候解决问题。 合并和删除委托实际使用时，委托实例往往有一个操作列表（invocation list）与之关联。Combine负责将两个委托实例的调用列表连接到一起，Remove负责从一个委托实例中删除另一个实例的调用列表。一般使用+和+=操作符代替Combine。注意： 委托和string一样是不易变的。Combine和String.Concat很像，合并现有实例来形成新的实例。可用-和-=简写Remove操作注意：若委托的签名有一个非void的返回类型，则Invoke的返回值是最后一个操作的返回值。除非使用GetInvocationList获取操作列表时，都显示调用某个委托，否则只能看到最后一个操作的返回值。注意：如果调用列表中断任何操作爆出一个异常，都会组织执行后续操作。 事件的简单讨论基本思想：让代码在发生某事时作出响应。注意：事件不是委托类型的字段，但C#允许使用字段风格的时间（field-like event）可以将事件看作类似属性的东西。两者都声明具有一种特定的类型，对于事件来说，是一个委托类型。(即：事件之于委托，就像属性之于字段）使用属性，实际是在调用方法。实现属性，可在方法中添加别的功能（校验机制之类）。同样订阅或取消订阅事件，实际是在调用（add和remove方法）既然能用委托实现为什么还要事件？和属性类似，事件添加了一个封装层，实现发布/订阅模式。Delegates and Events 字段风格的事件，只需要一个声明。编译器将声明转换成一个具有默认add/remove实现的事件和一个私有委托类型的字段。表面上调用一个事件，实际调用存储在字段中的委托实例。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（六）：大致了解-异步代码","slug":"深入理解C-（六）：大致了解-异步代码","date":"2019-01-09T09:45:12.000Z","updated":"2019-01-09T09:45:52.075Z","comments":true,"path":"2019/01/09/深入理解C-（六）：大致了解-异步代码/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（六）：大致了解-异步代码/","excerpt":"","text":"深入理解C#（六）*第一章（大致了解C#各个版本的特性：异步代码） C# 5特性：异步函数可以用它来中断代码执行，而不阻塞线程。 Windows Forms中有两条规范： 不能阻塞UI线程 不能在任何其他线程中访问UI元素 private async void CheckProduct(object sender, EventArgs e)​ {​ try​ {​ // Only permit one lookup at a time​ productCheckButton.Enabled = false;​ statusLabel.Text = “Checking…”;​ nameValue.Text = “”;​ priceValue.Text = “”;​ stockValue.Text = “”; 123456789101112131415161718192021222324 string id = idInput.Text; Task&lt;Product&gt; productLookup = directory.LookupProductAsync(id); Task&lt;int&gt; stockLookup = warehouse.LookupStockLevelAsync(id); Product product = await productLookup; if (product == null) &#123; statusLabel.Text = &quot;Product not found&quot;; // We don&apos;t care about the result of the stock check return; &#125; nameValue.Text = product.Name; priceValue.Text = product.Price.ToString(&quot;c&quot;); int stock = await stockLookup; stockValue.Text = stock.ToString(); statusLabel.Text = &quot;Ready&quot;; &#125; finally &#123; // However we finish this method, allow another lookup productCheckButton.Enabled = true; &#125;&#125; 新的语法：方法的async修饰符和两个await表达式 说明：现在产品目录和库存中查询产品详细信息和当前库存。等待（await）直到找到产品信息，如果目录中没有条目与给定ID对应，就退出。否则，将产品名称和价格显示在UI元素上，然后再等待获得库存信息并显示。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（五）：大致了解-COM和动态类型","slug":"深入理解C-（五）：大致了解-COM和动态类型","date":"2019-01-09T09:44:17.000Z","updated":"2019-01-09T09:44:49.652Z","comments":true,"path":"2019/01/09/深入理解C-（五）：大致了解-COM和动态类型/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（五）：大致了解-COM和动态类型/","excerpt":"","text":"深入理解C#（五）*第一章（大致了解C#各个版本的特性：COM和动态类型） C# 4特性：互操作性包括：处理旧的COM技术和在DLR（Dynamic Language Runtime，动态语言运行时）上执行全新动态语言。 简化COM互操作用COM控制让数据出现在Excel中例子： 1234567891011121314var app = new Application &#123; Visible = false &#125;;Workbook workbook = app.Workbooks.Add();Worksheet worksheet = app.ActiveSheet;int row = 1;foreach (var product in Product.GetSampleProducts().Where(p =&gt; p.Price != null))&#123;worksheet.Cells[row, 1].Value = product.Name;worksheet.Cells[row, 2].Value = product.Price;row++;&#125;workbook.SaveAs(Filename: &quot;demo.xls&quot;,FileFormat: XlFileFormat.xlWorkbookNormal);app.Application.Quit(); 与动态语言互操作问题：产品能通过WEb服务访问，但只能用Python代码。Web服务使用了Python特性来构建结果，没有声明我们要访问的属性类型。但要我们指定类型，怎么办？ 使用新的类型dynamic可以将dynamic类型隐式转换为其他类型 例子：从IronPython中获取产品列表并打印出来。 1234567ScriptEngine engine = Python.CreateEngine();ScriptScope scope = engine.ExecuteFile(@&quot;CSharp4\\FindProducts.py&quot;);dynamic products = scope.GetVariable(&quot;products&quot;);foreach (dynamic product in products)&#123;Console.WriteLine(&quot;&#123;0&#125;: &#123;1&#125;&quot;, product.ProductName, product.Price);&#125; products和product为动态类型，编译器允许我们对产品列表迭代打印，但是它不确保是否能执行成功。如果有错误，只有执行时才会知道失败。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（四）：大致了解-LINQ简介","slug":"深入理解C-（四）：大致了解-LINQ简介","date":"2019-01-09T09:43:28.000Z","updated":"2019-01-09T09:43:54.230Z","comments":true,"path":"2019/01/09/深入理解C-（四）：大致了解-LINQ简介/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（四）：大致了解-LINQ简介/","excerpt":"","text":"深入理解C#（四）*第一章（大致了解C#各个版本的特性：LINQ简介） LINQ简介LINQ（Language Integrated Query，语言集成查询）用于简化查询 查询表达式和进程内查询例子：查询所有供应商和对应产品，先连接产品和供应商，再按价格筛选，然后按先供应商名再产品名的优先级排序，最后打印每个供应商名称和产品名称 123456789101112131415List&lt;ProductWithSupplierID&gt; products = ProductWithSupplierID.GetSampleProducts();List&lt;Supplier&gt; suppliers = Supplier.GetSampleSuppliers();var filtered = from p in products join s in suppliers on p.SupplierID equals s.SupplierID where p.Price &gt; 10 orderby s.Name, p.Name select new &#123; SupplierName = s.Name, ProductName = p.Name &#125;;foreach (var v in filtered)&#123; Console.WriteLine(&quot;Supplier=&#123;0&#125;; Product=&#123;1&#125;&quot;,v.SupplierName, v.ProductName);&#125; 特性：隐式类型局部变量（implicitly typed local variable）使用var关键字说明，编译器根据变量的初始值推断其类型 LINQ to XML例子： 12345678910111213141516171819XDocument doc = XDocument.Load(&quot;data.xml&quot;);var filtered = from p in doc.Descendants(&quot;Product&quot;) join s in doc.Descendants(&quot;Supplier&quot;) on (int)p.Attribute(&quot;SupplierID&quot;) equals (int)s.Attribute(&quot;SupplierID&quot;) where (decimal)p.Attribute(&quot;Price&quot;) &gt; 10 orderby (string)s.Attribute(&quot;Name&quot;), (string)p.Attribute(&quot;Name&quot;) select new &#123; SupplierName = (string)s.Attribute(&quot;Name&quot;), ProductName = (string)p.Attribute(&quot;Name&quot;) &#125;;foreach (var v in filtered)&#123; Console.WriteLine(&quot;Supplier=&#123;0&#125;; Product=&#123;1&#125;&quot;, v.SupplierName, v.ProductName);&#125;&#125; LINQ to SQL例子： 123456789101112131415161718using (LinqDemoDataContext db = new LinqDemoDataContext()) &#123; var filtered = from p in db.Products join s in db.Suppliers on p.SupplierID equals s.SupplierID where p.Price &gt; 10 orderby s.Name, p.Name select new &#123; SupplierName = s.Name, ProductName = p.Name &#125;; foreach (var v in filtered) &#123; Console.WriteLine(&quot;Supplier=&#123;0&#125;; Product=&#123;1&#125;&quot;, v.SupplierName, v.ProductName); &#125; &#125; 虽然查询是用C#代码来表示的，但却是用SQL执行。实际发出一个数据库请求，被转化为SQL查询。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（三）：大致了解-处理未知数据","slug":"深入理解C-（三）：大致了解-处理未知数据","date":"2019-01-09T09:42:23.000Z","updated":"2019-01-09T09:43:00.268Z","comments":true,"path":"2019/01/09/深入理解C-（三）：大致了解-处理未知数据/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（三）：大致了解-处理未知数据/","excerpt":"","text":"深入理解C#（三）*第一章（大致了解C#各个版本的特性：处理未知数据） 表示未知的值类型问题描述：decimal表示产品价格，是值类型，若某个产品价格未知，该如何表示？（若是引用类型，可用null表示） C# 1解决方案： 给decimal建一个引用类型包装器 用一个单独的bool标志，表示价格是否已知 使用一个魔数（magic value）来表示，如decimal.MinValue C# 2:Nullable结构，提供一些语法糖来简化。例子： 123456decimal? price;public decimal? Price&#123; get&#123;return price;&#125; private set&#123;price=value;&#125;&#125; Price=null;null现在表示“没有其他数据的任意可空类型的一个特殊值”所有引用类型和基于Nullable的类型为可空类型与null值作比较，结果总是false 可选参数和默认值问题描述：对一个方法或构造函数，有时我们会自己设定参数，这时往往需要重构来减少参数量，并设置我们的默认值。有什么方法能简化？ C#4：可选参数和默认值：例子： 12345public Product(string name,decimal? price=null)&#123; this.name=name; this.price=price;&#125; 这里对于可空类型的参数price，我们设定他为可选参数，默认值为null，这样我们就不需要重载这个构造函数，但我们依然能使用形如：Product p=new Product(&quot;Unreleased product&quot;);这样的方式构造一个Product实例，因为price被设定有默认值null。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（二）：大致了解-排序和过滤","slug":"深入理解C-（二）：大致了解-排序和过滤","date":"2019-01-09T09:41:23.000Z","updated":"2019-01-09T09:42:04.742Z","comments":true,"path":"2019/01/09/深入理解C-（二）：大致了解-排序和过滤/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（二）：大致了解-排序和过滤/","excerpt":"","text":"深入理解C#（二）*第一章（大致了解C#各个版本的特性：排序和过滤） 按字母顺序打印产品列表按名称排序，找出最贵的产品这里只摘录C# 3的实现方法 Lambda表达式使用Comparison进行排序123456List&lt;Product&gt; products=Product.GetSampleProducts(); products.Sort((x,y)=&gt;x.Name.CompareTo(y));foreach(Product product in products)&#123; Console.WriteLine(product);&#125; 使用一个扩展方法对List进行排序12345List&lt;Product&gt; products=Product.GetSampleProducts();foreach(Product product in products.OrderBy(p=&gt;p.Name))&#123; Console.WriteLine(product);&#125; 查询集合C# 1需要循环，测试每个元素，操作符合条件的元素（这里是打印元素） C# 2测试和打印分开 1234567List&lt;Product&gt; products=Product.GetSampleProducts();Predicate&lt;Product&gt; test=delegate(Product p) &#123; return p.Price&gt;10m;&#125;;List&lt;Product&gt; matches=products.FinaAll(test);Action&lt;Product&gt; print=Console.WriteLine;matces.ForEach(print); 用FinaAll和ForEach分解问题另一个版本： 123List&lt;Product&gt; products=Product.GetSampleProducts();products.FindAll(delegate(Product p)&#123;return p.Price&gt;10;&#125;&#125;. .ForEach(Console.WriteLine); C# 3用Lambda表达式来测试 12345List&lt;Product&gt; products=Product.GetSampleProducts();foreach(Product product in products.Where(p=&gt;p.Price&gt;10))&#123; Console.WriteLine(product);&#125; 小结 C# 1，传统方法 C# 2, 匿名方法：有助于问题的分离性（将测试和打印分开） C# 3， Lambda表达式：增强了可读性","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"深入理解C#（一）：大致了解-数据类型","slug":"深入理解C-（一）：大致了解-数据类型","date":"2019-01-09T09:39:12.000Z","updated":"2019-01-09T09:40:47.054Z","comments":true,"path":"2019/01/09/深入理解C-（一）：大致了解-数据类型/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/09/深入理解C-（一）：大致了解-数据类型/","excerpt":"","text":"深入理解C#（一）*第一章（大致了解C#各个版本的特性：数据类型） 产品/名称/价格的例子C# 1实现1234567891011121314151617181920212223242526public class Product&#123;string name;public string Name&#123; get &#123; return name;&#125; &#125;decimal price;public decimal Price &#123; get &#123; return price; &#125;&#125;public Product(string name,decimal price)&#123; this.name=name; this.price = price;&#125;public static ArrayList GetSample()&#123; ArrayList list = new ArrayList(); list.Add(new Prodect(&quot;west side&quot;,9.99m)); list.Add(new Prodect(&quot;Assassins&quot;,14.99m)); return list;&#125;public override string ToString()&#123; return string.Format(&quot;&#123;0&#125;: &#123;1&#125;&quot;,name,price);&#125; 存在以下问题： ArrayList 没有 提供 与其 内部 内容 有关 的 编译 时 信息。 不慎 在 GetSampleProducts 创建 的 列表 中 添加 一个 字符串 是 完全 有可能 的， 而 编译器 对此 没有 任何 反应。(例如list.Add(&quot;this is a string&quot;);编译器不能发现错误） 代码 中为 属性 提供 了 公共 的 取值 方法， 这 意味着 如果 添加 对应 的 赋值 方法， 那么 赋值 方法 也 必须 是 公共 的。 用于 创建 属性 和 变量 的 代码 很复杂—— 封装 一个 字符串 和 一个 十进制 数 应该 是一 个 十分 简单 的 任务， 不该 这么 复杂。 C# 2实现123456public class Product&#123;string name;public string Name&#123; get &#123; return name;&#125; private set &#123; name=value;&#125; } ​ 123456789101112131415161718192021decimal price;public decimal Price &#123; get &#123; return price; &#125;&#125;public Product(string name,decimal price)&#123; this.name=name; this.price = price;&#125;public static List GetSample()&#123; List&lt;Product&gt; list = new List(); list.Add(new Prodect(&quot;west side&quot;,9.99m)); list.Add(new Prodect(&quot;Assassins&quot;,14.99m)); return list;&#125;public override string ToString()&#123; return string.Format(&quot;&#123;0&#125;: &#123;1&#125;&quot;,name,price);&#125; C# 2提出泛型List list = new List();且属性拥有私有赋值方法 private set { name=value;} 这样就解决了C# 1中前两个问题 C# 3实现特性1：自动实现的属性和简化的初始化 123public class Product&#123;public string Name&#123; get; private set; } ​ 12345678910111213141516171819202122public decimal Price &#123; get; private set; &#125;public Product(string name,decimal price)&#123; Name=name; Price = price;&#125;Product() &#123;&#125;public static List GetSample()&#123; return new List&#123; new Prodect&#123; Name=”West Side&quot;,Price=9.99m&#125;, new Prodect&#123;Name=&quot;Assassins&quot;, Price=14.99m&#125; &#125;;&#125;public override string ToString()&#123; return string.Format(&quot;&#123;0&#125;: &#123;1&#125;&quot;,Name,Price);&#125; 用属性代替变量，删除了所有与变量关联的代码，在类中处处使用属性，增强了一致性。有一个私有的无参构造函数，用于基于属性的初始化。 C# 4实现为了移除易变形,使用只读属性在调 用 构造 函数 时 指定 实 参 的 名称，关于只读属性 readonly是一个用于以下三种上下文的修饰符： 在字段定义中：readonly表示这个字段的实例化只能发生在变量声明时在所属类的构造器中 在只读段落（readonly struct）中：为一个struct加上readonly表示这个struct是不变的（immutable）。 在方法返回ref readonly中，表示这个方法返回一个reference，这个ref不可写 using System.Collections.Generic;​ public class Product​ {​ readonly string name;​ public string Name{ get { return name;} } 1234567891011121314151617181920212223readonly decimal price; public decimal Price &#123; get&#123;return price;&#125; &#125;public Product(string name,decimal price)&#123; this.name=name; this.price = price;&#125;Product() &#123;&#125;public static List GetSample()&#123; return new List&#123; new Prodect&#123; name:&quot;West Side&quot;,price:9.99m&#125;, new Prodect&#123;name:&quot;Assassins&quot;, price:14.99m&#125; &#125;;&#125;public override string ToString()&#123; return string.Format(&quot;&#123;0&#125;: &#123;1&#125;&quot;,name,price);&#125; 指定实参名称的好处是：在方法或构造函数包含多个参数时，使代码更清楚。另外可以不按顺序添加参数，而按照名称添加。这是C# 4为每个方法或构造函数自动添加的，直接使用。 小结一下：除了用到readonly的时候，大部分时候选用C# 3的属性自动实现的特性，隐藏变量，在方法中始终使用属性，保持一致性。对于拥有多个复杂参数的函数或构造函数，用命名实参来调用方法。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"C#review补档","slug":"C-review","date":"2019-01-08T22:21:25.000Z","updated":"2019-01-08T22:36:09.860Z","comments":true,"path":"2019/01/08/C-review/","link":"","permalink":"https://xiaotong1996.github.io/2019/01/08/C-review/","excerpt":"","text":"C#回顾与java明显不同 WriteLine() 文件名可以不同于类的名称 动态（Dynamic）类型您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。 声明动态类型的语法：dynamic &lt;variable_name&gt; = value; 指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。 常量是使用 const 关键字来定义的 ? : 运算符我们已经在前面的章节中讲解了 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下：Exp1 ? Exp2 : Exp3; for(;;) 结构来表示一个无限循环。 return 语句可用于只从函数中返回一个值。但是，可以使用 输出参数 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。 关键字 out 在 C# 中，使用 ref 关键字声明引用参数。 数组：double[] balance = new double[10]; foreach (int j in n ) C# 参数数组:params 关键字 当声明一个方法时，您不能确定要传递给函数作为参数的参数数目在使用数组作为形参时，C# 提供了 params 关键字，使调用数组为形参的方法时，既可以传递数组实参，也可以只传递一组数组。params 的使用格式为：public 返回类型 方法名称( params 类型名称[] 数组名称 ) C# 中的析构函数类的 析构函数 是类的一个特殊的成员函数，当类的对象超出范围时执行。析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。 注意点 C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\\）当作普通字符对待，比如：string str = @&quot;C:\\Windows&quot;;等价于：string str = &quot;C:\\\\Windows&quot;; Console.ReadLine() 只接受字符串格式的数据。 可空类型：在处理数据库和其他包含可能未赋值的元素的数据类型时，将 null 赋值给数值类型或布尔型的功能特别有用：&lt; data_type&gt; ? &lt;variable_name&gt; = null; 我们可以使用 static 关键字把类成员定义为静态的。当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本。关键字 static 意味着类中只有一个该成员的实例。 您也可以把一个成员函数声明为 static。这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在。 抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。 待详细看 namespace命名空间:using System;命名空间的设计目的是为了提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。 可空类型 多维数组和交错数组:C# 支持多维数组。多维数组又称为矩形数组。交错数组是数组的数组。 Array 类是 C# 中所有数组的基类，它是在 System 命名空间中定义。Array 类提供了各种用于数组的属性和方法。直接调用array中的方法能实现数组的逆转和排序等 结构在 C# 中，结构是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。struct 关键字用于创建结构。 动态多态性 委托（delegate)C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。 委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 System.Delegate 类。","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://xiaotong1996.github.io/tags/C/"}]},{"title":"2018-7-26-JavaEE-WEB-2","slug":"2018-7-26-JavaEE-WEB-2","date":"2018-07-26T21:01:27.000Z","updated":"2019-01-08T22:07:06.220Z","comments":true,"path":"2018/07/26/2018-7-26-JavaEE-WEB-2/","link":"","permalink":"https://xiaotong1996.github.io/2018/07/26/2018-7-26-JavaEE-WEB-2/","excerpt":"","text":"JAVA EE WEB学习（二）创建第一个Servlet Servlet作用 直接处理和响应用户请求 将处理工作委托给应用中其他部分的类 WEB容器会有一个或多个Servlet，用于处理JSP、显示目录列表、访问静态资源 继承的servlet类 继承HttpServlet 接收HttpServletRequest和HttpServletResponse参数 简单例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Demo3 extends HttpServlet &#123; private static final String DEFAULT_USER=&quot;Guest&quot;; /** * Constructor of the object. */ public Demo3() &#123; super(); &#125; /** * Destruction of the servlet. &lt;br&gt; */ public void destroy() &#123; super.destroy(); // Just puts &quot;destroy&quot; string in log // Put your code here System.out.println(this.getServletInfo()); System.out.println(&quot;fin&quot;); &#125; /** * The doGet method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to get. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String user =request.getParameter(&quot;user&quot;); if(user==null) &#123; user=Demo3.DEFAULT_USER; &#125; response.setContentType(&quot;text/html&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); PrintWriter out = response.getWriter(); out.append(&quot;&lt;!DOCTYPE HTML&gt;\\r\\n&quot;) .append(&quot;&lt;HTML&gt;\\r\\n&quot;) .append(&quot; &lt;HEAD&gt;\\r\\n&quot;) .append(&quot; &lt;TITLE&gt;A Servlet&lt;/TITLE&gt;\\r\\n&quot;) .append(&quot; &lt;/HEAD&gt;\\r\\n&quot;) .append(&quot; &lt;BODY&gt;\\r\\n&quot;) .append(&quot; Hello, &quot;).append(user).append(&quot;!&lt;br/&gt;&lt;br/&gt;\\r\\n&quot;) .append(&quot; &lt;form action=\\&quot;demo3\\&quot; method=\\&quot;POST\\&quot;&gt;\\r\\n&quot;) .append(&quot; Enter your name:&lt;br/&gt;\\r\\n&quot;) .append(&quot; &lt;input type=\\&quot;text\\&quot; name=\\&quot;user\\&quot;/&gt;&lt;br/&gt;\\r\\n&quot;) .append(&quot; &lt;input type=\\&quot;submit\\&quot; value=\\&quot;Submit\\&quot;/&gt;\\r\\n&quot;) .append(&quot; &lt;/form&gt;\\r\\n&quot;) .append(&quot; &lt;/BODY&gt;\\r\\n&quot;) .append(&quot;&lt;/HTML&gt;\\r\\n&quot;); &#125; /** * The doPost method of the servlet. &lt;br&gt; * * This method is called when a form has its tag value method equals to post. * * @param request the request send by the client to the server * @param response the response send by the server to the client * @throws ServletException if an error occurred * @throws IOException if an error occurred */ public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125; /** * Initialization of the servlet. &lt;br&gt; * * @throws ServletException if an error occurs */ public void init() throws ServletException &#123; // Put your code here System.out.println(&quot;start&quot;); System.out.println(this.getServletName()); &#125;&#125; 注意点 init方法在构造完成之后，响应第一个请求之前调用 调用init方法时，Servlet中所有属性都已设置完，提供了对ServletConfig和SercletContext对象的访问。 可以使用init方法读取属性文件或使用JDBC连接数据库 destory方法在Servlet不再接受请求之后立即调用，即web应用程序被停止或卸载，或Web容器关闭时。因此：应该使用destory方法清理servlet持有的资源 配置可部署的Servlet 在web.xml中部署，一般IDE会在创建时自动部署。 12345&lt;servlet&gt; ..... ..... &lt;load-on-startup&gt;x&lt;/load-on-startup&gt;&lt;/servlet&gt; Servlet按照x大小顺序启动，越小优先级越高。 将Servlet映射到URL&lt;servlet-name&gt;对应&lt;url-pattern&gt;一个servlet可以映射到多个url 了解doGet、doPost和其他方法HttpServletRequest 功能：从客户端发送的请求中获取参数。参数有两种形式：查询参数和请求正文（post请求）。查询参数在HTTP请求的第一行数据中如GET /index.jsp?id=412&amp;category=Books HTTP/1.1中有两个查询参数:id和category 或 作为post变量保存在请求正文中 获取请求参数：方法getParameter返回参数单个值，或多个参数第一个值；getParameterValues返回参数值的数组；getParameterMap返回包含所有参数名值对；getparameterNames返回所有可用参数的名字的枚举。后两种方法一般用于遍历所有请求参数。 确定与请求内容相关的信息：getContentType返回请求的内容类型；getContentLength返回请求正文长度。 读取请求的内容：getInputStream读二进制格式；BufferedReader读基于字符编码。不要在同一请求上同时使用这两种方法；不要在含post变量的请求上使用这些方法 获取请求特有的数据getRequestURL：返回完整URL；getRequestURI：返回服务器路径；getServletPath：只返回Servlet映射的URL; HttpServletResponse 功能：提供了对响应中与HTTP协议相关属性的访问。可用于：设置响应头、编写相应正文、重定向请求、设置HTTP状态码等 编写响应正文：将内容输出到响应正文中。getOutputStream和getWritter都可以向响应中输出数据。不要对同一响应对象同时使用这两种方法。 设置内容类型或编码格式：使用setContentType和setCharacterEncoding方法。必须放在getWritter方法之前，否则返回到writer使用容器默认编码。 设置头和其他响应属性：暂略 使用初始化参数配置应用程序使用上下文初始化参数 在web.xml文件中用&lt;context-param&gt;标签声明上下文初始化参数 在&lt;servlet&gt;外部 在Servlet代码中获得和使用这些参数：先获得servletcontext（getServletContext），用这个实例的getInitParameter方法，参数为param-name可得到param-value。 使用servlet初始化参数 将&lt;init-param&gt;添加到&lt;servlet&gt;内部 在Servlet代码中获得和使用这些参数：先获得ServletConfig（getServletConfig），用这个实例的getInitParameter方法，参数为param-name可得到param-value。 通常用这种方式改变数据库服务器的IP地址 通过表单上传文件","categories":[],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://xiaotong1996.github.io/tags/JavaEE/"}]},{"title":"2018-7-25-JavaEE-WEB-1","slug":"2018-7-25-JavaEE-WEB-1","date":"2018-07-25T21:01:27.000Z","updated":"2019-01-08T22:10:15.207Z","comments":true,"path":"2018/07/25/2018-7-25-JavaEE-WEB-1/","link":"","permalink":"https://xiaotong1996.github.io/2018/07/25/2018-7-25-JavaEE-WEB-1/","excerpt":"","text":"JAVA EE WEB学习（一）基本结构 Servlet等 servlet：接收响应HTTP请求 过滤器：拦截发送给servlet的请求，用于：数据格式化，对返回的数据压缩、认证和授权 监听器：通知代码多种事件，如：程序启动、关闭，HTTP会话创建和销毁 JavaServer Pages/JSP：创建图形用户界面 目录结构和归档文件WAR Java归档文件：JAR Java EE WEB归档文件：WAR ) 部署描述符 用于描述Web应用程序的元数据，为服务器部署和运行Web应用程序提供指令。 来自于/WEB-INF/web.xml 包含Servlet、监听器和过滤器的定义+HTTP会话、JSP和应用程序的配置选项。 可用注解配置Web应用程序 类加载器架构（ClassLoader) Java SE 平台中，java.*类加载到根类加载器-&gt;JRE中的扩展JAR加载到扩展类加载器-&gt;其他所有类加载到Class Loader 双亲优先类加载委托模式：低级别加载器申请加载一个类时，将委托不断向上传递至根加载器，确认成功。未能找到，则从自己的JAR文件和目录中尝试加载。 Java EE WEb中，使用子女优先类加载委托模式：公共的服务器类加载器给每个WEB应用程序分配一个自由的相互隔离的类加载器。在自己无法加载某个类时，请求它的父类加载器帮助加载。","categories":[],"tags":[{"name":"JavaEE","slug":"JavaEE","permalink":"https://xiaotong1996.github.io/tags/JavaEE/"}]},{"title":"Java POI开发小结","slug":"2018-07-02-Apache-POI","date":"2018-07-02T09:38:03.000Z","updated":"2019-01-10T22:13:35.362Z","comments":true,"path":"2018/07/02/2018-07-02-Apache-POI/","link":"","permalink":"https://xiaotong1996.github.io/2018/07/02/2018-07-02-Apache-POI/","excerpt":"","text":"关于POI以及一些想法Apache POI是Apache软件基金会提供的100％开源库。大多数中小规模的应用程序开发主要依赖于Apache POI（HSSF+ XSSF）。它支持Excel 库的所有基本功能; 然而，呈现和文本提取是它的主要特点。 官网链接 Java Excelapi有很多，除了Apahce POI，网上教程较多的Jexcel等。虽然没有使用过其他java excelapi，就本人使用Apahce POI开发感受和其他人的提醒，能用VB操作excel就尽量不要用java了。 Apache POI提供的基本功能，简单的读写ｅｘｃｅｌ文档没有问题，但是没有实现复制单元格(cell)，复制电子表格(Sheet)等功能（也有可能提供了但我没找到，毕竟没有很详细地完整看完官方Guide）。学习基本功能和了解POI实现机制，可以看上面官网链接或易百中文教程。 我在下面会列出一些我在开发时自己编写的ＰＯＩ工具类中一些常用函数，具体代码可以在我的GitHub JavaPOI项目中找到。 代码实现获取有效行数123456789101112131415161718192021222324/******************************************************** * function : count the number of valid rows in a given sheet * ******************************************************* * parameters: * wb : workbook which contains the sheet we want * indexSheet : the index of the sheet in the xb (start from 0) *************************************************************** */ public static int getSheetRowNumber(XSSFWorkbook wb,int indexSheet) &#123; XSSFSheet sheet=wb.getSheetAt(indexSheet); int count=0; int begin = sheet.getFirstRowNum(); int end = sheet.getLastRowNum(); for (int i = begin; i &lt;= end; i++) &#123; if (null == sheet.getRow(i)|| getCellValue(sheet.getRow(i).getCell(0)) == \"\" || null==sheet.getRow(i).getCell(0)) &#123; continue; &#125; else count++; &#125; return count; &#125; 列编号(ABC…)与数字(123…)的转换1234567891011121314151617181920212223242526272829303132333435363738/********************************************************** * Excel column index begin 1 * @param colStr * @param length * @return **********************************************************/ public static int excelColStrToNum(String colStr, int length) &#123; int num = 0; int result = 0; for(int i = 0; i &lt; length; i++) &#123; char ch = colStr.charAt(length - i - 1); num = (int)(ch - 'A' + 1) ; num *= Math.pow(26, i); result += num; &#125; return result; &#125; /** * Excel column index begin 1 * @param columnIndex * @return */ public static String excelColIndexToStr(int columnIndex) &#123; if (columnIndex &lt;= 0) &#123; return null; &#125; String columnStr = \"\"; columnIndex--; do &#123; if (columnStr.length() &gt; 0) &#123; columnIndex--; &#125; columnStr = ((char) (columnIndex % 26 + (int) 'A')) + columnStr; columnIndex = (int) ((columnIndex - columnIndex % 26) / 26); &#125; while (columnIndex &gt; 0); return columnStr; &#125; 在不同工作簿(workbook)间，复制一个区域的单元格并保留格式，设置行宽12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/******************************************************** * function : copy a part of cells in different workbooks * ******************************************************* * @param: * xbIn : the resource workbook * xbOut : the destination workbook * indexSheetIn : the index of the sheet in the xbIn (start from 0) * indexSheetOut : the index of the sheet in the xbOut (start from 0) * rowInStart : the number of the first row that we need in the indexSheetIn ( start from 1 ) * rowInEnd : the number of the last row that we need in the indexSheetIn ( start from 1 ) * colInStart : the number of the first column that we need in the indexSheetIn ( start from 1, represent A in the sheet ) * colInEnd : the number of the last column that we need in the indexSheetIn ( start from 1, represent A in the sheet ) * rowOutStart : the number of the first row that we want to put cells in the indexSheetOut ( start from 1 ) * colOutStart : the number of the first column that we want to put cells in the indexSheetOut ( start from 1, represent A in the sheet ) * *******************************************************/ public static boolean copyCells(XSSFWorkbook wbIn,XSSFWorkbook wbOut,int indexSheetIn,int indexSheetOut, int rowInStart,int colInStart,int rowInEnd,int colINEnd,int rowOutStart,int colOutStart ) &#123; XSSFSheet sheetIn=wbIn.getSheetAt(indexSheetIn); XSSFRow rowIn; XSSFCell cellIn; XSSFCellStyle cellStyleIn; String cellInValue; XSSFSheet sheetOut=wbOut.getSheetAt(indexSheetOut); XSSFRow rowOut; XSSFCell cellOut; XSSFCellStyle cellStyleOut; int rowNum=rowInEnd-rowInStart; int colNum=colINEnd-colInStart; for(int i=0;i&lt;rowNum+1;i++) &#123; rowIn=sheetIn.getRow(rowInStart+i-1); rowOut = sheetOut.createRow(rowOutStart+i-1); //set the copied row&apos;s height rowOut.setHeight(rowIn.getHeight()); for(int j=0;j&lt;colNum+1;j++) &#123; cellIn=rowIn.getCell(colInStart+j-1); if(cellIn!=null) &#123; cellInValue=getCellValue(cellIn); cellOut=rowOut.createCell(colOutStart+j-1); cellStyleIn=cellIn.getCellStyle(); cellStyleOut=wbOut.createCellStyle(); cellStyleOut.cloneStyleFrom(cellStyleIn); cellOut.setCellStyle(cellStyleOut); cellOut.setCellValue(cellInValue); &#125; &#125; &#125; //in order to deal with merged regions java.util.List&lt;CellRangeAddress&gt; regions=sheetIn.getMergedRegions(); for(CellRangeAddress cellRangeAddress : regions) &#123; if(cellRangeAddress.getFirstColumn()&gt;=colInStart-1&amp;&amp; cellRangeAddress.getLastColumn()&lt;=colINEnd-1&amp;&amp; cellRangeAddress.getFirstRow()&gt;=rowInStart-1&amp;&amp; cellRangeAddress.getLastRow()&lt;=rowInEnd-1) &#123; int diffrow=rowOutStart-rowInStart; int diffcol=colOutStart-colInStart; int firstRow=cellRangeAddress.getFirstRow()+diffrow; int firstCol=cellRangeAddress.getFirstColumn()+diffcol; int lastRow=firstRow+cellRangeAddress.getLastRow()-cellRangeAddress.getFirstRow(); int lastCol=firstCol+cellRangeAddress.getLastColumn()-cellRangeAddress.getFirstColumn(); CellRangeAddress cellRangeAddressNew=new CellRangeAddress(firstRow, lastRow, firstCol, lastCol); sheetOut.addMergedRegion(cellRangeAddressNew); &#125; &#125; //set the copied column&apos;s width for(int columnIndex=colInStart-1;columnIndex&lt;=colINEnd-1;columnIndex++) &#123; int width=sheetIn.getColumnWidth(columnIndex); sheetOut.setColumnWidth(columnIndex, width); &#125; return true; &#125; 需要注意的 在linux环境下，使用LibreOffice Calc，虽然在给每个电子表格(sheet)命名时，无论代码中还是软件中，名称可以包含空格或特殊字符，但用apahce poi获取sheet名时，只会读到空格或特殊符号之前的部分。我的解决方法是在创建每个sheet时统一用横杠(-)代替空格和特殊字符。 对于合并单元格(merged region)，好的做法是在同一个函数中先把该表中所有要合并的单元格存到cellRangeAddress列表中，再进行复制之类的操作，避免在多个函数反复添加合并单元格。 自动设置列宽方法autoSizeColumn，对于合并单元格不能很好适用，建议还是自己设置。 在设置格式时，LibreOffice Calc中形如=$表名.单元格编号。但在java POI中形式为cell.setcellformula(表名!单元格编号)","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://xiaotong1996.github.io/tags/Java/"},{"name":"Apache POI","slug":"Apache-POI","permalink":"https://xiaotong1996.github.io/tags/Apache-POI/"}]},{"title":"WEB学习-HTML和CSS入门","slug":"2018-02-20-WEB-learning","date":"2018-02-19T23:00:00.000Z","updated":"2019-01-08T21:49:29.807Z","comments":true,"path":"2018/02/20/2018-02-20-WEB-learning/","link":"","permalink":"https://xiaotong1996.github.io/2018/02/20/2018-02-20-WEB-learning/","excerpt":"","text":"目录{:toc} WEB项目文件结构 常用网页框架设计 1个100%页面宽度的行类(.row) 占页面1/12-12/12的列类(.col-n)n为1-12的数字CSS类前有. flex 为了让行中列元素并排显示，需要给row加上display:flex 关于flex，查看flex,flexbox,flex-wrap 负空间（space） margin 外边距 padding 内边距 加上后缀-top -right -left -bottom具体设置border 边框 溢出 overflow:auto; 响应例子：@media only screen and (max-width:500px) and (orientation:landscape) @media实现页面响应 only‘用于兼容旧式浏览器 screen指示这个响应用于所有显示设备print用于响应当用户要打印页面时 and加上条件 orientation指的是手机方向：landscape mode横向，portrait mode纵向 浏览器兼容在head中添加normalize.css样式表，该表格google搜索下载 占位图片 &lt;img src=&quot;http://placehold.it/nxn&quot; &lt;img src=&quot;http://placekitten.com/n/n&quot; 字体 在Google Fonts中找到字体 在html的head中加入链接&lt;link href=&quot;https://fonts.googleapis.com/css?family=Roboto&quot; rel=&quot;stylesheet&quot;&gt; 在css中为需要使用该字体的元素添加font-family: &#39;Roboto&#39;, sans-serif;","categories":[],"tags":[{"name":"WEB入门","slug":"WEB入门","permalink":"https://xiaotong1996.github.io/tags/WEB入门/"}]},{"title":"WEB学习-Bootstrap框架学习","slug":"2018-02-21-WEB-Bootstrap-learning","date":"2018-02-19T23:00:00.000Z","updated":"2019-01-08T21:51:18.151Z","comments":true,"path":"2018/02/20/2018-02-21-WEB-Bootstrap-learning/","link":"","permalink":"https://xiaotong1996.github.io/2018/02/20/2018-02-21-WEB-Bootstrap-learning/","excerpt":"","text":"[TOC] Grid system(网格系统) 每一行rows应放在.container(fixed-width)或.container-fluid(full-width)中 使用rows来创建水平列组(groupes of columns) 内容放在column中，column是rows的子类 Chrome开发者工具ctrl+shift+i 应用框架要将 bootstrap CSS 应用于 bootstrap-prestructure.html 文件，需要：将 bootstrap-prestructure.html 文件移至你的 bootstrap 目录。打开 HTML 文件，在母体元素下方的 head 元素中添加一条指向 bootstrap CSS 文件的链接：&lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.min.css&quot;&gt; 保存修改要将你在开发者工具中对 HTML 所做的更改保存至你的 HTML 文件，只需右键单击或 ctrl + 单击 元素，然后选择“复制为 HTML”，然后用复制的文本替换你文件中的 HTML。 响应式页面响应式图片加上class=&quot;img-responsive&quot; alt=&quot;Responsive image&quot; Bootstrap排版文字对齐加上class=&quot;text-left&quot;表示左对齐文字装换加上class=&quot;text-uppercase&quot;将文字变为大写可添加在文字类型如h1，h3，最好是直接添加在包含他们的div上 自定义CSS在/css文件夹下添加style.css文件从大到小对网页中的元素添加定制","categories":[],"tags":[{"name":"WEB入门","slug":"WEB入门","permalink":"https://xiaotong1996.github.io/tags/WEB入门/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://xiaotong1996.github.io/tags/Bootstrap/"}]},{"title":"Git 学习","slug":"2018-02-06-Git-learning","date":"2018-02-05T23:00:00.000Z","updated":"2019-01-08T21:43:39.022Z","comments":true,"path":"2018/02/06/2018-02-06-Git-learning/","link":"","permalink":"https://xiaotong1996.github.io/2018/02/06/2018-02-06-Git-learning/","excerpt":"","text":"目录{:toc} 基础以在GitLab上创建一个project为例 1. SSH秘钥生成SSH秘钥指令：$ ssh-keygen -t rsa -C &quot;votre.email@telecom-sudparis.eu&quot; -b 4096保存在$HOME/.ssh/id_rsa.pub将获得的SSH秘钥填入GitLab网站SSH秘钥用于GitLab网站识别Unix账号 2. 创建project并添加合作者命名规则：课程+年份+创作者给合作者Master权限 3. 克隆project到本地git clone git@gitlab.tem-tsp:votreprenom.votrenom/votrenomdeproject.git 4. 查看git状态git status 5. 创建第一个文件README.md并提交 git add README.md git commit -m &quot;注释&quot; git push origin master 其他合作者git pull origin git add：i） git add . 或 git add --all 提交所有修改 git commit：i） git commit后会生产一个hash码，用于标记此次commit操作 git push：i） git push默认将master上传ii）origin是远程仓库名，master是分支名 git pull：i）当有其他人想master分支推送了更新，则服务器上的master向前推进，本地的Master落后服务器版本，需要运行 git fetch来同步本地并用git merge合并，或直接用git pull。git pull=git fetch + git merge 分支操作branch 1. 创建分支git checkout -b module1 i） 创建并转到module1分支ii）git checkout 分支名 转到已存在的分支 2. 查看分支git branch i）一般而言，Master分支是默认创建的。但若是在项目一开始，即项目为空时，创建分支，会丢失master分支。 3. 在分支上进行操作 与在基础部分操作相同 在每个分支上做的add,commit操作是独立的 4. 查看日志 git log --graph --oneline --decorate 使用工具gitg/gitk 5. 合并（Fusion）分支 转到Mastergit checkout master git merge --no-ff moudle1 -m &quot;Merge branch &#39;modele1&#39;&quot; i) 有--no-ff则moudle1会保留，没有则不保留module1分支 冲突conflict设置冲突管理工具git config merge.tool meld 冲突前提分支module1和Master中有同一个文件，且分别在不同分支修改了文件，并做了add commit操作。做第二次commit时冲突发送。 解决方法：用git mergetool调用meld，查看修改冲突的地方，修改保存后会生成很多不必要的文件用rm 文件名.文件类型.* 文件名_* *~删除这些文件。 Git-flowGit-flow原则 两条长期分支master只保留官方的，实用的代码版本develop在这个分支进行开发，只有想正式对外发布且经过确认，才会和Master合并。 新建develop分支：git checkout -b develop master 将develop分支发布到Master分支：git checkout Master​ `git merge --no-ff develop ` 创建release(预发布)分支当要进行develop分支和Master合并时，先从develop分支上创建一个release分支，加上标签（tag)用于标记新的版本。建议创建一个release分支，这个分支里commit只用于修改bugs。 在develop的子分支（feature分支）上编码只有子分支状态满足，develop上的合并操作才会执行 hotfix当master上发现bug，就在master上引出一个hotfix分支。这个分支有两个作用： 为Master提供一个新版本 为develop修复整个project的bug 注意：release,feature和hotfix分支都是临时分支，使用完后，应该删除，使代码库的常设分支始终只有Master和Deve。 Git-flow例子 在本地建立工作文件夹，初始化库 123456mkdir exercice-git-flow cd exercice-git-flow git init touch README.md git add README.md git commit -m &quot;commit initial&quot; 新建develop分支git checkout -b develop 新建feature分支，以功能名命名git checkout -b navire1 在这个分支中写一个文本文档 123gedit navire.txt git add navire.txt git commit -m &quot;navire version 1` 修改和二次提交为navire.txt中加入新的几行 123gedit navire.txt git add navire.txt git commit -m &quot;navire version 2&quot; 现在我们已经实现了一定功能，合并这个分支和develop 12git checkout develop git merge --no-ff navire1 -m &quot;Merge branch &apos;navire1&apos; into develop&quot; 假设经过多次3-5，我们已经实现了很多功能，想把develop和master合并 12git checkout master git merge --no-ff develop -m &quot;commit release 1.0&quot; 因为这是一个正式版本，我们加上标签taggit tag -a v1.0 -m &quot;release 1.0&quot; 版本控制=有待完成=","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://xiaotong1996.github.io/tags/Git/"}]},{"title":"Vim学习（一）","slug":"2018-02-05-Vim-learning-1","date":"2018-02-04T23:00:00.000Z","updated":"2019-01-08T21:43:08.602Z","comments":true,"path":"2018/02/05/2018-02-05-Vim-learning-1/","link":"","permalink":"https://xiaotong1996.github.io/2018/02/05/2018-02-05-Vim-learning-1/","excerpt":"","text":"目录{:toc} vim学习Part 112345- i → Insert 模式，按 ESC 回到 ormal 模式.- x → 删当前光标所在的一个字符。- :wq → 存盘 + 退出 (:w 存盘, :q 退出) （注：:w 后可以跟文件名）- dd → 删除当前行，并把删除的行存到剪贴板里- p → 粘贴剪贴板 Part 2 插入模式 a → 在光标后插入 o → 在当前行后插入一个新行 O → 在当前行前插入一个新行 cw → 替换从光标所在位置后到一个单词结尾的字符 简单的移动光标 0 → 数字零，到行头 ^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等） $ → 到本行行尾 g_ → 到本行最后一个不是blank字符的位置。 /pattern → 搜索 pattern 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个） 拷贝/粘贴 P → 粘贴;p是表示在当前位置之后，P表示在当前位置之前 yy → 拷贝当前行当行于 ddP;y -&gt; 拷贝 Undo/Redo u → undo C-r → redo 打开/保存/退出/改变文件(Buffer) :e &lt;path/to/file&gt; → 打开一个文件 :w → 存盘 :saveas &lt;path/to/file&gt; → 另存为 &lt;path/to/file&gt; :x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车) :q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。 :bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。 Part 3 vim的重复 . 小数点，重复上一条命令 N加命令，重复N次 光标移动 数字加G，到第N行 gg，到第一行 G，到最后一行 w，到下个词开k移动到与当前光标相匹配的词（×是下一个，#是上一个） 组合命令（开始位置+命令+结束位置） 0y$; 拷贝本行，+p粘贴 能与光标移动联动的还有 d，删除 v，可视化选择 gU，变大写 gu，变小写 其他 Part 4 当前行上移动光标 0，到行头 ^，到本行的第一个非blank字符 $，到行尾 f字符，到下一个字符处 t字符，到符号前的第一个字符 3fa，到本行第三次出现的a处 F和T，与f和t相似，方向相反 dt符号，删除符号前的所有内容 可视化选择v,V J，把所有行连在一起 &lt;和&gt;,左右缩进 =，自动缩进 选中行后，$到最后，a插入字符，Esc为每行添加字符 分屏 ：split，创建分屏 ctrl-w，切屏","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"https://xiaotong1996.github.io/tags/vim/"}]},{"title":"Markdown 学习","slug":"2018-01-27-Markdown-learning","date":"2018-01-26T23:00:00.000Z","updated":"2019-01-08T21:41:43.413Z","comments":true,"path":"2018/01/27/2018-01-27-Markdown-learning/","link":"","permalink":"https://xiaotong1996.github.io/2018/01/27/2018-01-27-Markdown-learning/","excerpt":"","text":"目录{:toc} Markdown 学习一个好的Markdown学习网站 注释comment\\ 标题Header# 加空格实现 句段Sentence/Paragraph 换行 行末加两个空格 \\ 符号Punctuation Charcaters *倾斜* -或+ 列表 >引用 字符实体 tab 预格式化 分隔符Horizontal Rules-– 三个减号或星号或下划线需隔开上一行 文本格式Text Styling 星号（*）或下划线（_）包围的文字将会显示斜体 ex: 倾斜 两个星号（**）或下划线（__）包围的需要特别强调的文字将会加粗 ex: 加粗 两个等号（equalsigns：\\=）包围来突出高亮显示。ex: ==高亮== 使用两个加号（plus sign：+）来标记下划线。ex：++下划线++ 两个波浪符号（two wavy line:~~）包围来给文本添加删除线。ex: 删除线 脚标 Script标准 Markdown 不支持脚标，只能通过内嵌 HTML 的\\&lt;sup>和\\&lt;sub>标签来实现。 脚标两边加上\\&lt; &gt; ex: 2^10^ 脚标两边加上~ ~ ex: H~2~o 链接Hyperlink 文字 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要用尖括号包起来的文字， Markdown 就会自动把它转化成链接。如果你还想要加上链接的 title ，只要在网址后面用双引号把 title 文字包起来即可。 [text](url”解释“) ex: 链接 先定义参考refid：[text][refid]再定义refid所指：[refid]:URL 图片 插入图片 需要在链接文字方括号之前添加一个感叹号（exclamation mark：!），其语法格式 ![alt_text](url) 其中alt_text可以置空 Markdown中的段落（包括图片）默认顶格左对齐，若要将图片居中，可以直接内嵌 HTML 的 标签，设置align=”middle”。如果还不行，可以尝试封裹一层 div 设置 style=”text-align:center” 实现 图片链接 我们在 Markdown 图片标记外面再嵌套一层即可建立图片超链接，点击图片即可跳转到链接地址。图片链接的格式看起来大概是这样的:[![](img_url)](ref_url) 锚点inner link 书签Bookmark 先定义锚点id：bookmark_text 再定义一个id为auchor_id的对象（这里以为例）：auchor_text 脚注Footnote 先在需要脚注的单词（terminology）后面添 加 [^Footnote] ： terminology[^Footnote] 再在文末 glossary 区域定义脚注（添加注解）： [^Footnote]：explanatory notes 引用BlockquoteMarkdown 标记区块引用是使用类似 email 的引用方式，在断好的行前加上 &gt; （more than or greater than sign）： 代码Code 行内代码Inline CodeUse the printf() function.(此处使用了反斜杠转义) 代码块Code Blocks 可使用预格式化引用语法格式。Preformatted Code Block在句段的行首插入1个 tab 或4个空格，则表示代码块。 [Fenced Code Block]在句段行首和行末用三个反引号换行闭包，并在行首三个反引号后添加 YAML 语言标识。 列表List 无序列表Unordered List无序列表（unordered, bulleted）项目的行首使用星号（或加号，或减号）加空格作为列表标记list markers 有序列表Ordered List有序列表（ordered / numbered）项目的行首则使用数字接一个英文句点标记（use numbers followed by periods） 扩展支持把列表变成带勾选框的任务列表，只需要在列表标记后添加[ ]标记☐表示unchecked，在中括号中填写x（[x]）标记☑︎表示checked（filled）。 表格TableYou can create tables by assembling a list of words and dividing them with hyphens - (for the first row), and then separating each column with a pipe | (vertical bar): t1 t2 t11 t12 t21 t22","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://xiaotong1996.github.io/tags/Markdown/"}]}]}