[{"title":"C#review补档","url":"/2019/01/08/C-review/","content":"\n# C#回顾\n\n## 与java明显不同\n\n1. WriteLine()\n2. 文件名可以不同于类的名称\n3. 动态（Dynamic）类型\n   您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。 声明动态类型的语法：`dynamic <variable_name> = value;`\n4. 指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。\n5. 常量是使用 const 关键字来定义的\n6. ? : 运算符\n   我们已经在前面的章节中讲解了 条件运算符 ? :，可以用来替代 if...else 语句。它的一般形式如下：`Exp1 ? Exp2 : Exp3;`\n7. for(;;) 结构来表示一个无限循环。\n8. return 语句可用于只从函数中返回一个值。但是，可以使用 输出参数 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。 关键字 out\n9. 在 C# 中，使用 ref 关键字声明引用参数。\n10. 数组：`double[] balance = new double[10];`\n11. foreach (int j in n )\n12. C# 参数数组:params 关键字 当声明一个方法时，您不能确定要传递给函数作为参数的参数数目\n    在使用数组作为形参时，C# 提供了 params 关键字，使调用数组为形参的方法时，既可以传递数组实参，也可以只传递一组数组。params 的使用格式为：`public 返回类型 方法名称( params 类型名称[] 数组名称 )`\n13. C# 中的析构函数\n    类的 析构函数 是类的一个特殊的成员函数，当类的对象超出范围时执行。\n    析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。\n    析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。\n\n## 注意点\n\n1. C# string 字符串的前面可以加 @（称作\"逐字字符串\"）将转义字符（\\）当作普通字符对待，比如：`string str = @\"C:\\Windows\";`等价于：`string str = \"C:\\\\Windows\";`\n2. Console.ReadLine() 只接受字符串格式的数据。\n3. 可空类型：在处理数据库和其他包含可能未赋值的元素的数据类型时，将 null 赋值给数值类型或布尔型的功能特别有用：`< data_type> ? <variable_name> = null;`\n4. 我们可以使用 static 关键字把类成员定义为静态的。当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本。\n   关键字 static 意味着类中只有一个该成员的实例。\n5. 您也可以把一个成员函数声明为 static。这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在。\n6. 抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。\n\n## 待详细看\n\n1. [namespace命名空间](https://www.w3cschool.cn/csharp/csharp-namespace.html):using System;命名空间的设计目的是为了提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。\n2. [可空类型](https://www.w3cschool.cn/csharp/csharp-nullable.html)\n3. [多维数组和交错数组](https://www.w3cschool.cn/csharp/csharp-multi-dimensional-arrays.html):C# 支持多维数组。多维数组又称为矩形数组。交错数组是数组的数组。\n4. [Array 类](https://www.w3cschool.cn/csharp/csharp-array-class.html)是 C# 中所有数组的基类，它是在 System 命名空间中定义。Array 类提供了各种用于数组的属性和方法。*直接调用array中的方法能实现数组的逆转和排序等*\n5. [结构](https://www.w3cschool.cn/csharp/csharp-struct.html)在 C# 中，结构是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。struct 关键字用于创建结构。\n6. [动态多态性](https://www.w3cschool.cn/csharp/csharp-polymorphism.html)\n\n## 委托（delegate)\n\nC# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。\n\n委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 System.Delegate 类。","tags":["C#"]},{"title":"2018-7-26-JavaEE-WEB-2","url":"/2018/07/26/2018-7-26-JavaEE-WEB-2/","content":"\n# JAVA EE WEB学习（二）\n\n**创建第一个Servlet**\n\n## Servlet作用\n\n1. 直接处理和响应用户请求\n2. 将处理工作委托给应用中其他部分的类\n3. WEB容器会有一个或多个Servlet，用于处理JSP、显示目录列表、访问静态资源\n\n## 继承的servlet类\n\n1. 继承HttpServlet\n2. 接收HttpServletRequest和HttpServletResponse参数\n\n## 简单例子\n\n```\npackage servlet;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class Demo3 extends HttpServlet {\n\tprivate static final String DEFAULT_USER=\"Guest\";\n\t/**\n\t * Constructor of the object.\n\t */\n\tpublic Demo3() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Destruction of the servlet. <br>\n\t */\n\tpublic void destroy() {\n\t\tsuper.destroy(); // Just puts \"destroy\" string in log\n\t\t// Put your code here\n\t\tSystem.out.println(this.getServletInfo());\n\t\tSystem.out.println(\"fin\");\n\n\t}\n\n\t/**\n\t * The doGet method of the servlet. <br>\n\t *\n\t * This method is called when a form has its tag value method equals to get.\n\t * \n\t * @param request the request send by the client to the server\n\t * @param response the response send by the server to the client\n\t * @throws ServletException if an error occurred\n\t * @throws IOException if an error occurred\n\t */\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tString user =request.getParameter(\"user\");\n\t\tif(user==null)\n\t\t{\n\t\t\tuser=Demo3.DEFAULT_USER;\n\t\t}\n\t\tresponse.setContentType(\"text/html\");\n\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\t\t\n\t\tPrintWriter out = response.getWriter();\n\t\tout.append(\"<!DOCTYPE HTML>\\r\\n\")\n\t\t   .append(\"<HTML>\\r\\n\")\n\t\t   .append(\"  <HEAD>\\r\\n\")\n\t\t   .append(\"    <TITLE>A Servlet</TITLE>\\r\\n\")\n\t\t   .append(\"  </HEAD>\\r\\n\")\n\t\t   .append(\"  <BODY>\\r\\n\")\n\t\t   .append(\"     Hello, \").append(user).append(\"!<br/><br/>\\r\\n\")\n\t\t   .append(\"     <form action=\\\"demo3\\\" method=\\\"POST\\\">\\r\\n\")\n\t\t   .append(\"       Enter your name:<br/>\\r\\n\")\n\t\t   .append(\"       <input type=\\\"text\\\" name=\\\"user\\\"/><br/>\\r\\n\")\n\t\t   .append(\"       <input type=\\\"submit\\\" value=\\\"Submit\\\"/>\\r\\n\")\n\t\t   .append(\"       </form>\\r\\n\")\n\t\t   .append(\"  </BODY>\\r\\n\")\n\t\t   .append(\"</HTML>\\r\\n\");\n\n\n\t}\n\n\t/**\n\t * The doPost method of the servlet. <br>\n\t *\n\t * This method is called when a form has its tag value method equals to post.\n\t * \n\t * @param request the request send by the client to the server\n\t * @param response the response send by the server to the client\n\t * @throws ServletException if an error occurred\n\t * @throws IOException if an error occurred\n\t */\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tthis.doGet(request, response);\n\t}\n\n\t/**\n\t * Initialization of the servlet. <br>\n\t *\n\t * @throws ServletException if an error occurs\n\t */\n\tpublic void init() throws ServletException {\n\t\t// Put your code here\n\t\tSystem.out.println(\"start\");\n\t\tSystem.out.println(this.getServletName());\n\t}\n\n}\n\n```\n\n**注意点**\n\n1. init方法在构造完成之后，响应第一个请求之前调用\n2. 调用init方法时，Servlet中所有属性都已设置完，提供了对ServletConfig和SercletContext对象的访问。\n3. 可以使用init方法读取属性文件或使用JDBC连接数据库\n4. destory方法在Servlet不再接受请求之后立即调用，即web应用程序被停止或卸载，或Web容器关闭时。因此：**应该使用destory方法清理servlet持有的资源**\n\n## 配置可部署的Servlet\n\n1. 在web.xml中部署，一般IDE会在创建时自动部署。\n2. \n\n```\n<servlet>\n\t.....\n\t.....\n\t<load-on-startup>x</load-on-startup>\n</servlet>\n```\n\nServlet按照x大小顺序启动，越小优先级越高。\n\n1. 将Servlet映射到URL\n   `<servlet-name>`对应`<url-pattern>`一个servlet可以映射到多个url\n\n## 了解doGet、doPost和其他方法\n\n### HttpServletRequest\n\n1. 功能：从客户端发送的请求中获取参数。参数有两种形式：查询参数和请求正文（post请求）。查询参数在HTTP请求的第一行数据中如`GET /index.jsp?id=412&category=Books HTTP/1.1`中有两个查询参数:id和category  或  作为post变量保存在请求正文中\n2. **获取请求参数：**方法getParameter返回参数单个值，或多个参数第一个值；getParameterValues返回参数值的数组；getParameterMap返回包含所有参数名值对；getparameterNames返回所有可用参数的名字的枚举。后两种方法一般用于遍历所有请求参数。\n3. **确定与请求内容相关的信息：**getContentType返回请求的内容类型；getContentLength返回请求正文长度。\n4. **读取请求的内容：**getInputStream读二进制格式；BufferedReader读基于字符编码。**不要在同一请求上同时使用这两种方法；不要在含post变量的请求上使用这些方法**\n5. **获取请求特有的数据**getRequestURL：返回完整URL；getRequestURI：返回服务器路径；getServletPath：只返回Servlet映射的URL;\n\n### HttpServletResponse\n\n1. 功能：提供了对响应中与HTTP协议相关属性的访问。可用于：设置响应头、编写相应正文、重定向请求、设置HTTP状态码等\n2. **编写响应正文：**将内容输出到响应正文中。getOutputStream和getWritter都可以向响应中输出数据。**不要对同一响应对象同时使用这两种方法。**\n3. **设置内容类型或编码格式：**使用setContentType和setCharacterEncoding方法。必须放在getWritter方法之前，否则返回到writer使用容器默认编码。\n4. **设置头和其他响应属性：**暂略\n\n## 使用初始化参数配置应用程序\n\n### 使用上下文初始化参数\n\n1. 在web.xml文件中用`<context-param>`标签声明上下文初始化参数 *在`<servlet>`外部*\n2. 在Servlet代码中获得和使用这些参数：先获得servletcontext（getServletContext），用这个实例的getInitParameter方法，参数为param-name可得到param-value。\n\n### 使用servlet初始化参数\n\n1. 将`<init-param>`添加到*`<servlet>`内部*\n2. 在Servlet代码中获得和使用这些参数：先获得ServletConfig（getServletConfig），用这个实例的getInitParameter方法，参数为param-name可得到param-value。\n3. **通常用这种方式改变数据库服务器的IP地址**\n\n## 通过表单上传文件","tags":["JavaEE"]},{"title":"2018-7-25-JavaEE-WEB-1","url":"/2018/07/25/2018-7-25-JavaEE-WEB-1/","content":"\n\n\n# JAVA EE WEB学习（一）\n\n**基本结构**\n\n## Servlet等\n\n1. servlet：接收响应HTTP请求\n2. 过滤器：拦截发送给servlet的请求，用于：数据格式化，对返回的数据压缩、认证和授权\n3. 监听器：通知代码多种事件，如：程序启动、关闭，HTTP会话创建和销毁\n4. JavaServer Pages/JSP：创建图形用户界面\n\n## 目录结构和归档文件WAR\n\n1. Java归档文件：JAR  Java EE WEB归档文件：WAR\n2. ![目录结构](/img/post/目录结构.png)\n3. ![目录结构2](/img/post/目录结构2.png))\n\n## 部署描述符\n\n1. 用于描述Web应用程序的元数据，为服务器部署和运行Web应用程序提供指令。\n2. 来自于/WEB-INF/web.xml\n3. 包含Servlet、监听器和过滤器的定义+HTTP会话、JSP和应用程序的配置选项。\n4. *可用注解配置Web应用程序*\n\n## 类加载器架构（ClassLoader)\n\n1. Java SE 平台中，java.*类加载到根类加载器->JRE中的扩展JAR加载到扩展类加载器->其他所有类加载到Class Loader\n2. 双亲优先类加载委托模式：低级别加载器申请加载一个类时，将委托不断向上传递至根加载器，确认成功。未能找到，则从自己的JAR文件和目录中尝试加载。\n3. Java EE WEb中，使用子女优先类加载委托模式：公共的服务器类加载器给每个WEB应用程序分配一个自由的相互隔离的类加载器。在自己无法加载某个类时，请求它的父类加载器帮助加载。\n\n","tags":["JavaEE"]},{"title":"WEB学习-HTML和CSS入门","url":"/2018/02/20/2018-02-20-WEB-learning/","content":"\n* 目录\n{:toc}\n\n# WEB项目文件结构\n![文件结构](/img/post/WEB-structure.png)\n\n# 常用网页框架设计\n- 1个100%页面宽度的行类(.row)\n- 占页面1/12-12/12的列类(.col-n)*n为1-12的数字*\n*CSS类前有.*\n\n# flex\n- 为了让行中列元素并排显示，需要给row加上`display:flex`\n- 关于flex，查看[flex](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex),[flexbox](https://segmentfault.com/a/1190000007550042),[flex-wrap](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-wrap)\n\n# 负空间（space）\n- margin 外边距\n- padding 内边距\n- 加上后缀`-top -right -left -bottom`具体设置\n*border 边框*\n\n# 溢出\n- `overflow:auto;`\n\n# 响应\n例子：\n`@media only screen and (max-width:500px) and (orientation:landscape)`\n- `@media`实现页面响应\n- `only‘`用于兼容旧式浏览器\n- `screen`指示这个响应用于所有显示设备\n*print用于响应当用户要打印页面时*\n- `and`加上条件\n- `orientation`指的是手机方向：landscape mode横向，portrait mode纵向\n\n# 浏览器兼容\n在head中添加normalize.css样式表，该表格google搜索下载\n\n# 占位图片\n- `<img src=\"http://placehold.it/nxn\"`\n- `<img src=\"http://placekitten.com/n/n\"`\n\n# 字体\n1. 在[Google Fonts](https://fonts.google.com/)中找到字体\n2. 在html的head中加入链接`<link href=\"https://fonts.googleapis.com/css?family=Roboto\" rel=\"stylesheet\">`\n3. 在css中为需要使用该字体的元素添加`font-family: 'Roboto', sans-serif;`\n\n\n","tags":["WEB入门"]},{"title":"WEB学习-Bootstrap框架学习","url":"/2018/02/20/2018-02-21-WEB-Bootstrap-learning/","content":"\n[TOC]\n\n# Grid system(网格系统)\n\n- 每一行rows应放在.container(fixed-width)或.container-fluid(full-width)中\n- 使用rows来创建水平列组(groupes of columns)\n- 内容放在column中，column是rows的子类\n\n# Chrome开发者工具\nctrl+shift+i\n\n# 应用框架\n要将 bootstrap CSS 应用于 bootstrap-prestructure.html 文件，需要：将 bootstrap-prestructure.html 文件移至你的 bootstrap 目录。打开 HTML 文件，在母体元素下方的 head 元素中添加一条指向 bootstrap CSS 文件的链接：\n`<link rel=\"stylesheet\" href=\"css/bootstrap.min.css\">`\n\n# 保存修改\n要将你在开发者工具中对 HTML 所做的更改保存至你的 HTML 文件，只需右键单击或 ctrl + 单击 <html> 元素，然后选择“复制为 HTML”，然后用复制的文本替换你文件中的 HTML。\n\n# 响应式页面\n响应式图片加上`class=\"img-responsive\" alt=\"Responsive image\"`\n\n# Bootstrap排版\n文字对齐加上`class=\"text-left\"`表示左对齐\n文字装换加上`class=\"text-uppercase\"`将文字变为大写\n*可添加在文字类型如h1，h3，最好是直接添加在包含他们的div上*\n\n# 自定义CSS\n在/css文件夹下添加style.css文件\n从大到小对网页中的元素添加定制","tags":["WEB入门","Bootstrap"]},{"title":"Git 学习","url":"/2018/02/06/2018-02-06-Git-learning/","content":"\n* 目录\n{:toc}\n\n# 基础\n*以在GitLab上创建一个project为例*\n\n## 1. SSH秘钥\n生成SSH秘钥指令：\n`$ ssh-keygen -t rsa -C \"votre.email@telecom-sudparis.eu\" -b 4096`\n保存在`$HOME/.ssh/id_rsa.pub`\n将获得的SSH秘钥填入GitLab网站\n**SSH秘钥用于GitLab网站识别Unix账号**\n\n## 2. 创建project并添加合作者\n命名规则：课程+年份+创作者\n*给合作者Master权限*\n\n## 3. 克隆project到本地\n`git clone git@gitlab.tem-tsp:votreprenom.votrenom/votrenomdeproject.git`\n\n## 4. 查看git状态\n`git status`\n\n## 5. 创建第一个文件README.md并提交\n1. `git add README.md`\n2. `git commit -m \"注释\"`\n3. `git push origin master`\n4. 其他合作者`git pull origin`\n\n- git add：\ni） `git add .` 或 `git add --all` 提交所有修改\n\n- git commit：\ni） `git commit`后会生产一个hash码，用于标记此次commit操作\n\n- git push：\ni） `git push`默认将master上传\nii）origin是远程仓库名，master是分支名\n\n- git pull：\ni）当有其他人想master分支推送了更新，则服务器上的master向前推进，本地的Master落后服务器版本，需要运行 `git fetch`来同步本地并用`git merge`合并，或直接用`git pull`。`git pull`=`git fetch` + `git merge`\n\n---\n\n# 分支操作\n*branch*\n\n## 1. 创建分支\n`git checkout -b module1`\n\ni） 创建并转到module1分支\nii）`git checkout 分支名` 转到已存在的分支\n\n## 2. 查看分支\n`git branch`\n\ni）一般而言，Master分支是默认创建的。\n**但若是在项目一开始，即项目为空时，创建分支，会丢失master分支。**\n\n## 3. 在分支上进行操作\n- 与在[基础部分](# 例子1-基础)操作相同\n- 在每个分支上做的add,commit操作是独立的\n\n## 4. 查看日志\n- `git log --graph --oneline --decorate`\n- 使用工具gitg/gitk\n\n## 5. 合并（Fusion）分支\n1. 转到Master`git checkout master`\n2. `git merge --no-ff moudle1 -m \"Merge branch 'modele1'\"`\n\ni)  有`--no-ff`则moudle1会保留，没有则不保留module1分支\n\n---\n\n# 冲突conflict\n\n## 设置冲突管理工具\n`git config merge.tool meld`\n\n## 冲突前提\n分支module1和Master中有同一个文件，且分别在不同分支修改了文件，并做了`add commit`操作。做第二次`commit`时冲突发送。\n\n解决方法：\n用`git mergetool`调用meld，查看修改冲突的地方，修改保存后会生成很多不必要的文件\n用`rm 文件名.文件类型.* 文件名_* *~`删除这些文件。\n\n---\n\n# Git-flow\n\n## Git-flow原则\n1. 两条长期分支\n**master**只保留官方的，实用的代码版本\n**develop**在这个分支进行开发，只有想正式对外发布且经过确认，才会和Master合并。\n- 新建develop分支：`git checkout -b develop master`\n- 将develop分支发布到Master分支：`git checkout Master`\n                             ​    `git merge --no-ff develop `\n2. 创建release(预发布)分支\n当要进行develop分支和Master合并时，先从develop分支上创建一个release分支，加上标签（tag)用于标记新的版本。\n*建议创建一个release分支，这个分支里commit只用于修改bugs。*\n\n3. 在develop的子分支（feature分支）上编码\n只有子分支状态满足，develop上的合并操作才会执行\n\n4. hotfix\n当master上发现bug，就在master上引出一个hotfix分支。\n这个分支有两个作用：\n1. 为Master提供一个新版本\n2. 为develop修复整个project的bug\n\n*注意：*release,feature和hotfix分支都是临时分支，使用完后，应该删除，使代码库的常设分支始终只有Master和Deve。\n\n![Git-flow图](/img/git/git-model.png)\n\n\n## Git-flow例子\n1. 在本地建立工作文件夹，初始化库\n\n```\nmkdir exercice-git-flow  \ncd exercice-git-flow  \ngit init  \ntouch README.md  \ngit add README.md  \ngit commit -m \"commit initial\"\n```\n\n2. 新建develop分支\n`git checkout -b develop`\n\n3. 新建feature分支，以功能名命名\n`git checkout -b navire1`\n\n4. 在这个分支中写一个文本文档\n\n```\ngedit navire.txt  \ngit add navire.txt  \ngit commit -m \"navire version 1`\n```\n\n5. 修改和二次提交\n为navire.txt中加入新的几行\n\n```\ngedit navire.txt  \ngit add navire.txt  \ngit commit -m \"navire version 2\"\n```\n\n现在我们已经实现了一定功能，合并这个分支和develop\n\n```\ngit checkout develop  \ngit merge --no-ff navire1 -m \"Merge branch 'navire1' into develop\"\n```\n\n6. 假设经过多次3-5，我们已经实现了很多功能，想把develop和master合并\n\n```\ngit checkout master  \ngit merge --no-ff develop -m \"commit release 1.0\"\n```\n\n因为这是一个正式版本，我们加上标签tag\n`git tag -a v1.0 -m \"release 1.0\"`\n\n# 版本控制\n=有待完成=\n","tags":["Git"]},{"title":"Vim学习（一）","url":"/2018/02/05/2018-02-05-Vim-learning-1/","content":"\n* 目录\n{:toc}\n\n# vim学习\n\n## Part 1\n```markdown\n- i → Insert 模式，按 ESC 回到 ormal 模式.\n- x → 删当前光标所在的一个字符。\n- :wq → 存盘 + 退出 (:w 存盘, :q 退出)   （注：:w 后可以跟文件名）\n- dd → 删除当前行，并把删除的行存到剪贴板里\n- p → 粘贴剪贴板\n```\n\n---\n\n## Part 2\n1. 插入模式\n\t- a → 在光标后插入\n\t- o → 在当前行后插入一个新行\n\t- O → 在当前行前插入一个新行\n\t- cw → 替换从光标所在位置后到一个单词结尾的字符\n2. 简单的移动光标\n\t- 0 → 数字零，到行头\n\t- ^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）\n\t- $ → 到本行行尾\n\t- g_ → 到本行最后一个不是blank字符的位置。\n\t- /pattern → 搜索 pattern 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个）\n3. 拷贝/粘贴 \n\t- P → 粘贴;p是表示在当前位置之后，P表示在当前位置之前\n\t- yy → 拷贝当前行当行于 ddP;y -> 拷贝\n4. Undo/Redo\n\t- u → undo\n\t- C-r → redo\n5. 打开/保存/退出/改变文件(Buffer)\n\t- :e <path/to/file> → 打开一个文件\n    - :w → 存盘\n    - :saveas <path/to/file> → 另存为 <path/to/file>\n    - :x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车)\n    - :q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。\n    - :bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。\n\n---\n\n## Part 3\n1. vim的重复\n\t- . 小数点，重复上一条命令\n\t- N加命令，重复N次\n2. 光标移动\n    - 数字加G，到第N行\n    - gg，到第一行\n    - G，到最后一行\n    - w，到下个词开k移动到与当前光标相匹配的词（×是下一个，#是上一个） \n3. 组合命令（开始位置+命令+结束位置）\n    - 0y$; 拷贝本行，+p粘贴\n    - 能与光标移动联动的还有\n\t\t- d，删除\n\t\t- v，可视化选择\n\t\t- gU，变大写\n\t\t- gu，变小写\n\t\t- 其他\n\n---\n\n## Part 4\n1. 当前行上移动光标\n\t- 0，到行头\n    - ^，到本行的第一个非blank字符\n    - $，到行尾\n    - f字符，到下一个字符处\n    - t字符，到符号前的第一个字符\n    - 3fa，到本行第三次出现的a处\n    - F和T，与f和t相似，方向相反 \n    - dt符号，删除符号前的所有内容\n2. 可视化选择v,V\n    - J，把所有行连在一起\n    - <和>,左右缩进\n    - =，自动缩进\n    - 选中行后，$到最后，a插入字符，Esc为每行添加字符\n3. 分屏\n    - ：split，创建分屏 \n    - ctrl-w，切屏\n","tags":["vim"]},{"title":"Markdown 学习","url":"/2018/01/27/2018-01-27-Markdown-learning/","content":"* 目录\n{:toc}\n\n# Markdown 学习\n[一个好的Markdown学习网站](http://xianbai.me/learn-md/index.html)\n\n## 注释comment\n\\<!-- 注释 -->\n\n---\n\n## 标题Header\n\\# 加空格实现\n\n---\n\n## 句段Sentence/Paragraph\n1. 换行 \n- 行末加两个空格 \n- \\<br>\n\n---\n\n## 符号Punctuation Charcaters\n- \\*倾斜* \n- \\-或+ 列表\n- \\>引用\n1. 字符实体\n    tab 预格式化 \n\n---\n\n## 分隔符Horizontal Rules\n\\--- 三个减号或星号或下划线需隔开上一行 \n\n---\n\n## 文本格式Text Styling\n- 星号（\\*）或下划线（\\_）包围的文字将会显示斜体 ex: *倾斜*\n- 两个星号（\\**）或下划线（\\__）包围的需要特别强调的文字将会加粗 ex: **加粗**\n- 两个等号（equalsigns：\\=）包围来突出高亮显示。ex: ==高亮==\n- 使用两个加号（plus sign：\\+）来标记下划线。\nex：++下划线++\n- 两个波浪符号（two wavy line:\\~~）包围来给文本添加删除线。ex: ~~删除线~~\n\n---\n\n## 脚标 Script\n标准 Markdown 不支持脚标，只能通过内嵌 HTML 的\\<sup\\>和\\<sub\\>标签来实现。\n* 脚标两边加上\\< > ex: 2^10^ \n* 脚标两边加上\\~ ~ ex: H~2~o\n\n---\n\n## 链接Hyperlink\n1. 文字\n- Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要用尖括号包起来的文字， Markdown 就会自动把它转化成链接。如果你还想要加上链接的 title ，只要在网址后面用双引号把 title 文字包起来即可。\n- \\[text\\]\\(url\"解释“\\) ex: [链接](href: \"this is a null ref\")\n- 先定义参考refid：\\[text]\\[refid]\n再定义refid所指：\\[refid]:URL\n2. 图片\n1. 插入图片\n- 需要在链接文字方括号之前添加一个感叹号（exclamation mark：!），其语法格式  \\!\\[alt_text](url) 其中alt_text可以置空    \n- Markdown中的段落（包括图片）默认顶格左对齐，若要将图片居中，可以直接内嵌 HTML 的 <img> 标签，设置align=\"middle\"。如果还不行，可以尝试封裹一层 div 设置 style=\"text-align:center\" 实现\n2. 图片链接\n- 我们在 Markdown 图片标记![]()外面再嵌套一层[]()即可建立图片超链接，点击图片即可跳转到链接地址。\n图片链接的格式看起来大概是这样的:\n\\[\\!\\[](img_url)](ref_url)\n\n---\n\n## 锚点inner link\n1. 书签Bookmark\n    先定义锚点id：<a href=\"#auchor_id\">bookmark_text</a>\n    再定义一个id为auchor_id的对象（这里以<p>为例）：<p id=\"auchor_id\">auchor_text</p>\n2. 脚注Footnote\n    先在需要脚注的单词（terminology）后面添 加 [^Footnote] ： terminology[^Footnote]\n    再在文末 glossary 区域定义脚注（添加注解）： [^Footnote]：explanatory notes\n\n---\n\n## 引用Blockquote\nMarkdown 标记区块引用是使用类似 email 的引用方式，在断好的行前加上 > （more than or greater than sign）：\n\n---\n\n## 代码Code\n1. 行内代码Inline Code\nUse the `printf()` function.(此处使用了反斜杠转义)\n2. 代码块Code Blocks\n- 可使用预格式化引用语法格式。Preformatted Code Block\n在句段的行首插入1个 tab 或4个空格，则表示代码块。\n- [Fenced Code Block]\n在句段行首和行末用三个反引号换行闭包，并在行首三个反引号后添加 YAML 语言标识。\n\n---\n\n## 列表List\n1. 无序列表Unordered List\n无序列表（unordered, bulleted）项目的行首使用星号（或加号，或减号）加空格作为列表标记list markers\n2. 有序列表Ordered List\n有序列表（ordered / numbered）项目的行首则使用数字接一个英文句点标记（use numbers followed by periods）\n3. 扩展支持把列表变成带勾选框的任务列表，只需要在列表标记后添加[ ]标记☐表示unchecked，在中括号中填写x（[x]）标记☑︎表示checked（filled）。\n\n---\n\n## 表格Table\nYou can create tables by assembling a list of words and dividing them with hyphens - (for the first row), and then separating each column with a pipe | (vertical bar):\n\n  t1 |  t2 \n --- | ---\n t11 | t12 \n t21 | t22 \n\n","tags":["Markdown"]}]