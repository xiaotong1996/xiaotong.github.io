[{"title":"C#数据库工具开发（十三）","url":"/2019/01/09/C-数据库工具开发（十三）/","content":"\n# C#数据库工具开发（十三）\n\n## 问题（08/01）\n\n单行同步，容易实现，只要判断选择的行状态做操作就行。\n如何撤销？用栈存储已执行的sql指令以及执行前的字段状态，对应每个指定，做反操作。\n\n做同步操作，全过程\n\n1. 根据差异同步DB\n2. 清空dblists\n3. 取更新后的dblists\n4. 用新的dblists填充dataDB\n5. 更新新的infolists\n6. 按照新的dblists顺序，对infolists排序，并删除已经选择去掉的项\n7. 用新的infolists填充dataxml\n8. 同步索引项","tags":["C#实战"]},{"title":"C#数据库工具开发（十二）","url":"/2019/01/09/C-数据库工具开发（十二）/","content":"\n# C#数据库工具开发（十二）\n\n## 问题（07/30）\n\n### 1. 如何实现同步两个DGV的滚动条\n\n```\nprivate void dataXML_Scroll(object sender, ScrollEventArgs e)       \n{               \nthis.dataDB.FirstDisplayedScrollingRowIndex = this.dataXML.FirstDisplayedScrollingRowIndex;\n}\n\nprivate void dataDB_Scroll(object sender, ScrollEventArgs e)\n{ \nthis.dataXML.FirstDisplayedScrollingRowIndex = this.dataDB.FirstDisplayedScrollingRowIndex; \n}\n```\n\n### 2. 如何实现一次删除DGV中的多行\n\n```\nforeach (DataGridViewRow row in dataXML.Rows)\n{\n    if((row.Cells[0].Value==null||row.Cells[0].Value.ToString()==\"\")&&row.Index!=dataXML.Rows.Count-1)\n    {\n        row.Selected = true;\n    }\n    else\n    {\n        row.Selected = false;\n    }\n}\nforeach (DataGridViewRow row in dataXML.SelectedRows)\n{\n    dataXML.Rows.Remove(row);\n}\n```\n\n在if条件中写要删除的行应该满足的条件，设置行被选中（利用Selected这个property），再删除选中的行。\n\n注意：不能用foreach每一行，加上判断，直接删除。因为每一次删除后，实际上Rows已经改变，循环不能遍历到所有满足条件的行。（先存行号，后删除的做法也一样，同理，每一次删除，行号已经改变）\n\n### 3. 避免事件无意间调用\n\n问题背景：我想要按下delete后，不删除这一行，只清空改行所有数据。想到的解决方法是在删除这一行后，在同一个index新建一行，但是总是出现各种问题。后来发现，因为我在`dataXML_RowsAdded`（行增加事件）中有完成其他功能，而实际上，我每次新建一行，都会触发这个事件，这就导致出现问题。<br>\n解决方法：设定一个bool标签deleting，在删除触发的方法中，设定deleting一开始为true，最后设回false，并在增加行触发的方法中，判断deleting的值，若为true则不执行任何操作。","tags":["C#实战"]},{"title":"C#数据库工具开发（十一）","url":"/2019/01/09/C-数据库工具开发（十一）/","content":"\n# C#数据库工具开发（十一）\n\n## 问题（07/26-07/27）\n\n### 1. 删除数据库中的一列，会自动删除与其关联的索引吗？\n\nMySQL是这样的，[详情](https://stackoverflow.com/questions/4341897/what-happens-if-i-drop-a-mysql-column-without-dropping-its-index-first)\n\nSQLServer经实践发现，必须先删除索引再删除列。因为索引依赖于列。\n\n### 2. 索引命名引起的异常\n\n问题背景：在新增索引时总是按照`表名_INDEX_数字`来给索引命名，数字是从0开始往上递增。问题在于，假设我们在test表中分别给三个字段添加了三个索引，即生成索引`TEST_INDEX_0/1/2`，那么如果我们删除了第一个索引`TEST_INDEX_0`，保留了索引`TEST_INDEX_1/2`，再次新建索引时，这个索引名字应该是0还是3结尾？而且我目前的实现，未考虑上述情况，只是在建立索引前查询表中索引数目，以这个数目作为新索引的结尾名，因此现在若创建一个新的索引会命名为`TEST_INDEX_2`，与表中已存在的索引冲突，发生异常。\n\n解决方案一：<br>\n每次删除一个索引，把它编号之后的索引编号减一，这涉及到索引的查找和修改。<br>\n`sp_rename 'tabName.old_indName','new_indName','INDEX'`\n\n解决方案二：<br>\n换一种命名方式：编号可用随机值<br>\n生成真随机数的方法：\n\n```\n public static string GenerateRandomCode(int length)\n    {\n        var result = new System.Text.StringBuilder();\n        for (var i = 0; i < length; i++)\n        {\n            var r = new Random(Guid.NewGuid().GetHashCode());\n            result.Append(r.Next(0, 10));\n        }\n        return result.ToString();\n    }\n```\n\n解决方案三：<br>\n不考虑名称的连续性，直接在最大值基础上往上加。\n\n### 3. 字段有索引时，不能修改字段类型\n\n解决方法：先删除索引，修改字段后，再新建索引。<br>\n这里会引起一个额外的问题：如何确认要修改的字段是否已存在索引。<br>\n有以下几种情况：<BR>\n\n1. 字段有索引，checkbox已勾选=>先删除索引，修改字段，再新建索引。\n2. 字段有索引，checkbox不勾选=>先删除索引，再修改字段\n3. 字段无索引，checkbox已勾选=>先修改字段，再添加索引\n4. 字段无索引，checkbox不勾选=>直接修改字段\n\n还有两种情况<BR>\n新增字段：先增加字段，根据checkbox值，选择是否添加索引。<BR>\n删除字段：先删除索引，再删除字段<BR>\n\n**此外，若只增删索引，则会重复修改字段操作。**<br>\n设定bool标识justindex，每次调用compareList（）方法时，确认行有差异，是否是因为只有索引列发生变化，如是则设为true，否则有其他引起行的差异则设为false。这样，在做同步操作前，先根据bool标识，获知引起行差异的原因，可省去没必要的修改字段操作。\n\n一共有八钟可能的操作<br>\n\n1. 只增加字段，不增加索引 OK\n2. 只修改字段，不增加索引 OK\n3. 不修改字段，增加索引 OK\n4. 不修改字段，删除索引 OK\n5. 既增加字段，又增加索引 OK\n6. 既修改字段，又增加索引 OK\n7. 既修改字段，又删除索引 OK\n8. 既删除字段，又删除索引 OK","tags":["C#实战"]},{"title":"C#数据库工具开发（十）","url":"/2019/01/09/C-数据库工具开发（十）/","content":"\n# C#数据库工具开发（十）\n\n## 问题（07/24-07/25）\n\n### 1. 如何实现一个页面关闭触发上级页面的响应？\n\n问题背景：我有一个页面显示某个数据库中所有表名和表结构，在此页面可以打开另一个修改或创建新表的页面，完成后，我想立即在显示页面刷新，让刚刚修改或生成的表也能出现在列表中。<br>\n解决方法：由于修改添加页面是在显示页面生成的：\n\n```\nformxml = new FormXMLExecute(\"*Oracle*\", filePath.Text);\nformxml.Show();\n```\n\n我们只需要在创建formxml时添加一个页面关闭事件即可：\n\n```\nformxml = new FormXMLExecute(\"*Oracle*\", filePath.Text);\nformxml.FormClosing += new FormClosingEventHandler(this.FromXMLExecute_FormClosing);\nformxml.Show();\n```\n\n在页面关闭事件中：\n\n```\nprivate void FromXMLExecute_FormClosing(object sender, FormClosingEventArgs e)\n{\n    //Do your stuff here.\n}\n```\n\n实现想要完成的功能（如刷新页面等）\n\n### 2. DataGridViewCheckBox的响应事件\n\n问题背景：想要实现点击DataGridViewCheckBox后，刷新页面\n解决方法：这个的即时响应和DataGridViewTextBox或DataGridViewComboBox相比简单很多，能直接用现有事件\n\n```\nprivate void dataXML_CellContentClick(object sender, DataGridViewCellEventArgs e)\n{\n    if (e.ColumnIndex == 3 && e.RowIndex != -1)\n    {\n        //Do your stuff here.\n    }\n}\n```\n\n唯一需要注意的和之前提到的一样：用单元格`EditedFormattedValue`属性而不是`Value`属性。\n\n### 3. 如何查询某个表中所有设置了索引的字段？\n\nOracle：\n​\t\n\n```\nselect a.column_name from all_ind_columns a, all_indexes b where a.index_name=b.index_name and a.table_name = upper('\"+tableName+\"') order by a.table_name\";\n```\n\nSQLServer：\n\n```\n\"USE \" + DBName+\" ;SELECT colname=d.name FROM   sysindexes  a  JOIN   sysindexkeys   b   ON   a.id=b.id   AND   a.indid=b.indid  JOIN   sysobjects   c   ON   b.id=c.id  JOIN   syscolumns   d   ON   b.id=d.id   AND   b.colid=d.colid  WHERE   a.indid   NOT IN(0,255)  AND   c.name='\"+tableName+\"'\";\n```\n\n### 3.1 更好的查询表中所有索引以及对应列名的sql查询语句\n\n```\nuse GMP_BF;\nSELECT\ntab.name AS [表名],\nidx.name AS [索引名称],\ncol.name AS [列名]\nFROM\nsys.indexes idx\nJOIN sys.index_columns idxCol \n  ON (idx.object_id = idxCol.object_id \n      AND idx.index_id = idxCol.index_id \n      )\nJOIN sys.tables tab\n  ON (idx.object_id = tab.object_id)\nJOIN sys.columns col\n  ON (idx.object_id = col.object_id\n      AND idxCol.column_id = col.column_id)\nWHERE tab.name='TEST2';\n```","tags":["C#实战"]},{"title":"C#数据库工具开发（九）","url":"/2019/01/09/C-数据库工具开发（九）/","content":"\n# C#数据库工具开发（九）\n\n## 问题（07/20）\n\n### 1. 如何实现DataGridView更改Cell值实时同步（像TextBox的效果）？\n\n具体实现：\n\n```\n\tprivate void dataXML_EditingControlShowing(object sender, DataGridViewEditingControlShowingEventArgs e)\n    {\n        if (e.Control.GetType().Equals(typeof(DataGridViewComboBoxEditingControl)))//cell为类ComboBox时\n        {\n            e.CellStyle.BackColor = Color.FromName(\"window\");\n            DataGridViewComboBoxEditingControl editingControl = e.Control as DataGridViewComboBoxEditingControl;\n            editingControl.SelectedIndexChanged += new EventHandler(EditingTB_TypeChanged);\n        }\n        else if (e.Control.GetType().Equals(typeof(DataGridViewTextBoxEditingControl)))//cell为类TextBox时\n        {\n            e.CellStyle.BackColor = Color.FromName(\"window\");\n            DataGridViewTextBoxEditingControl editingControl = e.Control as DataGridViewTextBoxEditingControl;\n            editingControl.TextChanged += new EventHandler(EditingTB_LengthChanged);\n        }\n        \n    }\n\n    private void EditingTB_TypeChanged(object sender,EventArgs e)\n    {\n\n        //添加操作\n    }\n\n    private void EditingTB_LengthChanged(object sender,EventArgs e)\n    {\n        //添加操作\n    }\n```\n\n参考：[DataGridView的单元格内容即时更新方法](https://blog.csdn.net/lllljz/article/details/7717730)<br>\n注意点：要用dataGridView1.CurrentCell.EditedFormattedValue而不是dataGridView1.CurrentCell.Value\n\n### 2. string删除空格\n\n三种方式：\n​\tstring trim = Regex.Replace( text, @\"\\s\", \"\" ); \n\n```\nstring trim = text.Replace( \" \", \"\" );  \ntrim = trim.Replace( \"\\r\", \"\" );  \ntrim = trim.Replace( \"\\n\", \"\" );  \ntrim = trim.Replace( \"\\t\", \"\" ); \n\nstring text = \"  My test\\nstring\\r\\n is\\t quite long  \";  \nstring trim = text.Trim(); \n```\n\n### 3. 获取系统时间\n\n`DateTime.Now.ToString(\"f\");//不显示秒`\n\n参考：[C#获取当前系统时间](https://blog.csdn.net/lingyb011/article/details/5946351)\n\n### 4. 导出文件不能立即在目标目录显示文件\n\n解决方法：将包含savefiledialog的窗体显示从showdialog改为show\n\n### 5. 如何实现DataGridViewTextBox自动把小写转化为大写？\n\n同样用到EditingControlShowing这个事件，另外在DataGridViewTextBox中只需要设置某一列的CharacterCasing为Upper就行。<br>\n具体实现\n​\t\n\n```\n DataGridView dgv = (DataGridView)sender;\n        if (e.Control is DataGridViewTextBoxEditingControl)\n        {\n            DataGridViewTextBoxEditingControl editingControl = (DataGridViewTextBoxEditingControl)e.Control;\n            if (dgv.CurrentCell.OwningColumn.Name == \"fieldName\")\n            {\n                editingControl.CharacterCasing = CharacterCasing.Upper;\n            }\n            else\n            {\n                editingControl.CharacterCasing = CharacterCasing.Normal;\n            }\n        }\n```\n\n","tags":["C#实战"]},{"title":"C#数据库工具开发（八）","url":"/2019/01/09/C-数据库工具开发（八）/","content":"\n# C#数据库工具开发（八）\n\n## 问题（07/19）\n\n### 1. 如何实现拖拽文件到textbox获取文件路径？\n\n利用textbox两个事件：dragenter和dragdrop\n具体实现\n\n```\n\tprivate void filePath_DragEnter(object sender, DragEventArgs e)\n    {\n        if (e.Data.GetDataPresent(DataFormats.FileDrop))\n        {\n            e.Effect = DragDropEffects.Link;\n        }\n        else\n        {\n            e.Effect = DragDropEffects.None;\n        }\n    }\n```\n\n```\nprivate void filePath_DragDrop(object sender, DragEventArgs e)\n{\nstring path = ((System.Array)e.Data.GetData(DataFormats.FileDrop)).GetValue(0).ToString();\n        filePath.Text = path;\n}\n```\n\n### 2. 数据库如何增删改字段？\n\n只考虑SQLServer和Oracle，增加和删除字段可用相同sql语句,修改字段略有不同：<br>\n增加：\n`sql = @\"use \" + DBName + \"; ALTER TABLE \" + tableName + \" ADD \" + fieldName + \" \" + fieldType + \"(\" + fieldLength + \");\";`<br>\n删除：\n`sql = @\"use \" + DBName + \"; ALTER TABLE \" + tableName + \"  DROP COLUMN \" + fieldName + \";\";`<br>\n修改：<br>\nSQLSerer：`sql = @\"use \" + DBName + \"; ALTER TABLE \" + tableName + \" ALTER COLUMN \" + fieldName + \" \" + fieldType + \"(\" + fieldLength + \");\";`<br>\nOracle:`sql = @\"ALTER TABLE \" + tableName + \" modify(\" + fieldName + \" \" + fieldType + \"(\" + fieldLength + \"))\";`\n\n### 3. 如何导出文件？\n\n使用SaveFileDialog控件<br>\n具体实现：\n\n```\n\t\tSaveFileDialog saveFileDialog1 = new SaveFileDialog();\n        saveFileDialog1.Filter = \"TXT|*.txt\";\n        saveFileDialog1.Title = \"选择导出sql记录的存储路径\";\n        saveFileDialog1.ShowDialog();\n\n        // If the file name is not an empty string open it for saving.  \n        if (saveFileDialog1.FileName != \"\")\n        {\n            // Saves the Image via a FileStream created by the OpenFile method.  \n            System.IO.FileStream fs =\n               (System.IO.FileStream)saveFileDialog1.OpenFile();\n            // Saves the Image in the appropriate ImageFormat based upon the  \n            // File type selected in the dialog box.  \n            // NOTE that the FilterIndex property is one-based.  \n            StreamWriter sw = new StreamWriter(fs);\n            foreach(string result in sqlcommands)\n            {\n                sw.WriteLine(result);\n            }\n\n            //清空缓冲区\n            sw.Flush();\n            //关闭流\n            sw.Close();\n            \n            fs.Close();\n        }\n```\n\n### 4. 如何给DataGridView增加行号\n\n```\nprivate void dataXML_RowPostPaint(object sender, DataGridViewRowPostPaintEventArgs e)\n    {\n        var grid = sender as DataGridView;\n        var rowIdx = (e.RowIndex + 1).ToString();\n\n        var centerFormat = new StringFormat()\n        {\n            // right alignment might actually make more sense for numbers\n            Alignment = StringAlignment.Center,\n            LineAlignment = StringAlignment.Center\n        };\n\n        var headerBounds = new Rectangle(e.RowBounds.Left, e.RowBounds.Top, grid.RowHeadersWidth, e.RowBounds.Height);\n        e.Graphics.DrawString(rowIdx, this.Font, SystemBrushes.ControlText, headerBounds, centerFormat);\n    }\n```","tags":["C#实战"]},{"title":"C#数据库工具开发（七）","url":"/2019/01/09/C-数据库工具开发（七）/","content":"\n# C#数据库工具开发（七）\n\n## 问题（07/18）\n\n### 1. 返回登录界面\n\n程序入口是登录界面，登录成功后隐藏登陆界面，显示主界面。现在想要实现点击主界面的按钮，返回登录界面。\n\n思路一：\n登录成功后，hide登录界面，new主界面。点击back按钮，hide主界面，show登陆界面。再次点击登陆，更新（reload）主界面<br>\n有两个问题，第一为了防止之后反复创建新的主界面，我把主界面先作为登陆界面属性创建，在login按钮事件中，只是添加参数，将其显示出来。可以增加一个静态变量isShown表示主界面是hide还是show。问题在于，主界面的load方法只在一开始调用，要想办法实现主界面的重新加载。<br>\n第二，主界面hide之后如何重新show登录界面。已知能用委托实现。\n\n思路二：\n登录成功后，hide登陆界面，new主界面。点击back按钮，close主界面，show登录界面。再次点击登录，新建(new)主界面<br>\n同样有两个问题，第二，我想保留当主界面close时，整个程序exit这个特性，所以我在FormMainOrcl_FormClosed事件中，有`Application.Exit();`，但是form.close()方法，也会引起这个事件的响应，这就导致点击back按钮后，整个程序都退出了。<br>\n第二，与思路一第二点一致\n\n目前暂时能想到的解决方案：<br>\n不保留主界面close，程序exit这个设定，程序只有在登陆界面退出时才退出。\n\n**改进的实现思路二的方案：**<br>\n在主界面添加变量justback，默认false，若点击back按钮，将justback设为true，在formclosed事件中判断justback，可以跳过程序退出。\n对于第二点，不用委托，更简单的实现方法\n在登录界面中\n\n```\nthis.Hide();\nFormMainTableShow formMain = new FormMainTableShow();\nformMain.Tag = this;\nformMain.Show();\n```\n\n在主界面中\n\n```\nFormLogin login = (FormLogin)this.Tag;\nlogin.Show();\nthis.Close();\n```\n\n### 2. 设置16进制颜色值\n\n例子：\n`Color color=ColorTranslator.FromHtml(\"#CE76D1\");`\n\n### 3. 调用资源文件\n\n例子：\n`XElement root = XElement.Parse(Resources.ResourceManager.GetObject(\"XMLTypeOracle\") as string);`","tags":["C#实战"]},{"title":"C#数据库工具开发（六）","url":"/2019/01/09/C-数据库工具开发（六）/","content":"\n# C#数据库工具开发（六）\n\n## 问题（07/17）\n\n### 1. 两个list的互相比较\n\n背景：我要比较两个DataGridView中多列值，可转变为两列list的互相比较<br>\n\n我的简单实现：<br>\n用多次foreach循环，设置一个标签find=false；找到改为ture；实现查找两个lists中有哪些不同项。<br>\n这样做能在循环中找到不同项和差项时，直接进行操作。可能存在问题是对于大量数据效率低，好在我这里只要比较数据库某个表中的字段名称，类型和长度。\n\n其他实现：<br>\n[C# Linq获取两个List或数组的差集交集](https://www.cnblogs.com/greatverve/archive/2012/03/29/csharp-list-linq-Intersection.html)<br>\n这样做的话，要先把DataGridView中的列存入list，linq取到差集后，再在DataGridView中定位差集中的元素，再进行操作。好处是linq在普通方法实现list比较时，效率高，对大量数据也适用。<br>\n*考虑之后学习linq，尝试实现。*\n\n### 2. CHARACTER_MAXIMUM_LENGTH返回值为空\n\n`string length = (reader.IsDBNull(2)) ?  \"\": Convert.ToString(reader.GetInt32(2));`<br>\nsqlserver数据库中，CHARACTER_MAXIMUM_LENGTH查询结果为空，但是返回值不能用reader.GetInt32(2)==null来判断。原因是数据库中的null和字符串中的null是不同类型的值，所以要用IsDBNULL来判断。","tags":["C#实战"]},{"title":"C#数据库工具开发（五）","url":"/2019/01/09/C-数据库工具开发（五）/","content":"\n# C#数据库工具开发（五）\n\n## 问题（07/16）\n\n### 1. `xml.load()`方法引发web exception未处理：远程服务器返回错误： ( 503 ) 服务器不可用异常\n\n解决方法：<br>\n\n1. 尝试从XHTML文件中删除 DOCTYPE，可能你有指向外部DTD的链接。<br>\n2. doc.XmlResolver = null;//this忽略 DTD\n\n### 2. sqlDataReader未关闭引发错误\n\n之前是直接拿sqlDataReader作返回值，但是sqlDataReader需要及时关闭，不然会导致二次调用同一方法引起异常。<br>\n好的写法是：把sqlDataReader读到的数据存入dataTable中，关闭sqlDataReader，返回dataTable。","tags":["C#实战"]},{"title":"C#数据库工具开发（四）","url":"/2019/01/09/C-数据库工具开发（四）/","content":"\n# C#数据库工具开发（四）\n\n## 问题（07/13）\n\n### 1. SQL查询某个表中所有字段名和字段类型\n\nSQLServer：<br>\n\n```\nstring sql = @\"USE \" + DBName+ \"; select COLUMN_NAME,DATA_TYPE,CHARACTER_MAXIMUM_LENGTH,IS_NULLABLE from INFORMATION_SCHEMA.COLUMNS t where t.TABLE_NAME =  '\" + TableName+\"';\";\n```\n\nOracle:<br>\n\n```\nstring sql = @\"select column_name, data_type from user_tab_columns where table_name = '\"+TableName+\"'\";\n```\n\n### 2. Linq to XML解析半闭合标签的XML文件有问题\n\n**看（五）**<br>\nlinq需要学习\n\n### 3. XML Document System.Net.WebException异常\n\n在`XmlDocument doc = new XmlDocument();doc.Load(path);`之间加断点调试会引发上述异常。正常调试没问题。\n\n### 4. C#string操作\n\n常用方法<br>\nsplit：按字符分割返回一个string数组<br>\nsubstring：获取部分字符串\n\n","tags":["C#实战"]},{"title":"C#数据库工具开发（三）","url":"/2019/01/09/C-数据库工具开发（三）/","content":"\n# C#数据库工具开发（三）\n\n## 问题（07/11-07/12）\n\n### 1. 在实现ConfigerManager时，把实现都放在了登陆界面的事件函数中，没能很好的分离功能（待解决）\n\n虽然尝试了把这部分功能分离出来，但是最多把保存登陆信息和伴随用户选择更改登陆信息这两部分放到Configer工具类中，后者要用至少4个引用参数来为窗口中的控件提供Text值。而对于登录界面默认加载最近登录信息的功能，则需要更多参数来实习，考虑了一下又改回之前的实现方案。\n\n### 2. 连接oracle服务器时，提示System.ComponentModel.Win32Exception: 安全包中没有可用的凭证异常。\n\n应该是安全认证方面的问题，解决方法是：win10用户退出微软登录账号，改用本地账号。不理解是为什么。\n\n### 3. ORA-00911:无效字符\n\n连接成功后执行Oracle的sql语句，报错信息包含这样的错误。解决方法是：去掉sql语句结束的`;`分号。分号对与SQL Server的语句执行无影响。","tags":["C#实战"]},{"title":"C#数据库工具开发（二）","url":"/2019/01/09/C-数据库工具开发（二）/","content":"\n# C#数据库工具开发（二）\n\n## 问题（07/09-/07/11）\n\n### 1. 数据库连接的开关，需要确认连接状态\n\n为了避免之后执行sql查询等操作时反复连接数据库，我把数据库连接打开和关闭分成两个方法，在登录成功时打开连接，一直到程序结束前断开连接。同时为了避免多次打开同一连接，需要在打开前先确认连接状态。\n\n### 2. 执行SQL语句是忽略关键字GO\n\n问题发生在使用SQL语句进入特定数据库时。虽然在实际数据库中可以使用，但用C#连接的SQL server不识别GO。\n解决方法也很简单，`use 数据库名`之后不加GO，加`;`就行。<br>\n更好的解决方法：[处理批量sql语句](http://jingpin.jikexueyuan.com/article/45383.html)<br>\nps：记录一种查询服务器中所有数据库 和 两种查询特定数据库中所有表的SQL语句：\n查数据库：`Select Name FROM Master.dbo.SysDatabases ORDER BY Name;`\n查表法一：`select name from sysobjects where xtype='U' order by name;`\n查表法二：`SELECT table_name FROM information_schema.tables WHERE table_type = 'base table'`\n[详细1](https://blog.csdn.net/u012643122/article/details/44039155#t5)\n[详细2](https://www.quora.com/What-is-the-SQL-query-to-find-all-table-names-present-in-a-database#)\n\n### 3. 存储sql执行语句结果的两种方式\n\n法一用SqlDataAdapter\n\n```\n\tDataSet ds = new DataSet();\n\tSqlDataAdapter sAdapter = new SqlDataAdapter(sql, sqlConnection);\n\tsAdapter.Fill(ds);\n```\n\n法二用SqlDataReader<br>\n`SqlDataReader sRead = cmd.ExecuteReader();`<br>\n这两种方法的[主要区别](https://www.cnblogs.com/carekee/articles/2094789.html)\n\n### 4. 查询结果如何在主窗口正确显示？\n\n最开始使用的ListView控件，通过添加listviewitem显示字段。具体方法如下：\n\n```\nListViewItem li = new ListViewItem();\n            li.SubItems.Clear();\n            li.SubItems[0].Text = reader[\"name\"].ToString();\n            li += new EventHandler(this.dbItem_DoubleClick);\n            DBList.Items.Add(li);\n```\n\n这种方法问题在于，我想实现点击item（字段）显示对应的表名或表结构，但是很难为item添加事件。<br>\n解决措施：\n换用DataGridView控件，好处在于:第一，这个控件本来就是为数据库显示服务的，获得DataSet之后用`dataView.DataSource = ds.Tables[0].DefaultView;`就可以显示完整表单。第二，通过CurrentCellChanged事件就可以很方便实现点击显示对应表单的效果。","tags":["C#实战"]},{"title":"C#数据库工具开发（一）","url":"/2019/01/09/C-数据库工具开发（一）/","content":"\n# C#数据库工具开发（一）\n\n## 开发日程\n\n1. 2019/07/09-/07/11</br>\n   sql server数据库连接+登录界面<br>\n   主界面+表单查询和显示\n2. 07/11-07/12</br>\n   登录配置文件<br>\n   oracle数据库连接\n3. 07/13-07/13<br>\n   读取保存数据库字段属性<br>\n   读取保存xml解析数据<br>\n   部分实现利用xml解析数据同步数据库（添加表）<br>\n   为主界面添加控件\n4. 07/13-07/13<br>\n   部分实现xml字段到sql字段映射<br>\n   xml导入配置页面<br>\n   部分实现利用xml解析数据同步数据库\n5. 07/16-07/16<br>\n   sql server和oracle数据库连接重构（sqlDataReader改用）<br>\n   xml导入创建新表<br>\n   部分实现xml与DB字段比较\n6. 07/17-07/17<br>\n   为比较页面（xml执行页面）添加字段长度项<br>\n   优化xml与DB字段比较<br>\n   用配置文件实现XML中字段类型映射<br>\n   界面优化\n7. 07/18-07/18<br>\n   增加logo<br>\n   增加数据库检索<br>\n   将SQL和Oracle显示table界面合二为一，删除SQL显示table界面中显示数据库的表（该功能与数据库检索重复)<br>\n   将字符串映射文件加入资源中\n8. 07/19-07/19<br>\n   更换logo，调整窗体<br>\n   增加拖拽文件直接加载功能<br>\n   优化字符串映射功能，避免bug<br>\n   对比界面自动刷新,优化显示<br>\n   增加同步数据库功能<br>\n   增加导出sql语句功能<br>\n9. 07/20-07/20<br>\n   优化对比界面更改字段事件<br>\n   优化导出sql语句功能，避免线程卡死<br>\n   添加xml显示界面手动添加或删除字段并刷新比对的功能\n10. 07/24-07/24<br>\n    优化添加表完成后字段页面同步刷新<br>\n    优化添加表完成后导出sql语句<br>\n    优化添加表完成后表显示页面刷新<br>\n    修复修改字段不显示的bug<br>\n    新增特性返回表显示页面自动定位到最新改动的table\n11. 07/25-07/27<br>\n    添加索引列，新增设置索引功能<br>\n    增加索引同步功能（包括索引的增加、删除）<br>\n    重写数据库同步xml部分，优化索引的建立删除，使其能像其他字段一样简单使用<br>\n    xml执行界面添加用户误操作的警告和提示（如，用户添加字段名相同的行）\n12. 07/30-08/01<br>\n    优化对比界面(更好的对比显示，实现左右页面同步滚动）<br>\n    简化用户操作(现在不用点击就可以选到鼠标指定行，删除操作也更方便）<br>\n    更改logo\n13. 08/01-08/03<br>\n    添加单行同步与撤销操作功能\n\n## 主要构成\n\n1. DBconnection：<br>\n   **SQLServer数据库连接工具类**<br>\n   主要功能：配置连接信息；打开、关闭数据库连接；执行sql语句获得结果（以ShowDatabaseList方法为例，用sql语句查询服务器中所有数据库名，将该结果存入sRead供前端窗口调用显示）\n2. FormLogin：<br>\n   **登录窗口**<br>\n   主要功能：获取连接信息\n   更新：\n   - 保存连接信息（记住密码）\n   - 检索数据库（用于选择登入那个数据库） \n3. FormMainTableShow：<br>\n   **主窗口**<br>\n   主要功能：主要逻辑业务的展示和执行界面，包含各种响应事件（第一阶段后可查看连接到远程数据库中所有表格）<br>\n   更新：\n   - 改为只用来展示数据库中所有表名和显示表信息\n   - 提供选择xml文件的入口\n4. ConfigerManager：<br>\n   **登陆信息实体类**<br>\n   主要功能：方便实现存储登录记录*实现写在FormLogin各种事件中*\n5. DBconnnectionOracle：<br>\n   **Oracle数据库连接工具类**<br>\n   主要功能：与DBconnection相似\n6. FormXMLExecute：<br>\n   **主要功能窗口**<br>\n   主要功能：解析显示xml表结构，提供添加或同步数据库表/表结构的功能,提供修改xml列表实时验证两表差异性的功能<br>\n7. MappingTool：<br>\n   **映射java类型到数据库的字段类型的工具类**\n   主要功能：解析保存映射信息的xml，将java类型，转换成保存数据库字段类型和对应默认字段长度的Dictionary。\n8. XMLParsing：<br>\n   **解析提供表结构的xml的工具类**<br>\n   主要功能：将xml保存的表结构，解析出表名和字段名，字段类型\n9. ParsedInfo：<br>\n   **xml信息的实体类**<br>\n   主要功能：保存xml解析出来的表结构信息\n10. DBmodify：<br>\n    **执行增删改数据库字段、增删索引的工具类**<br>\n11. RowRecord:<br>\n    **记录DGV中行信息的实体类**<br>\n    主要功能：保存对xml显示部分增删改之前的行信息，用于实现撤销操作\n\n\n\n## 参考页面\n\n1. [关于数据库表结构](https://www.xxling.com/blog/article/58.aspx)\n\n","tags":["C#实战"]},{"title":"深入理解C#（十六）：Lambda表达式和表达树","url":"/2019/01/09/深入理解C-（十六）：Lambda表达式和表达树/","content":"\n# 深入理解C#（十六）\n\n*第九章（C# 3：Lambda表达式和表达树）<br>\nlambda=λ\n\n## 作为委托的lambda表达式\n\n### Func<...>委托类型简介\n\n.NET3.5的System命名空间中，有5个泛型Func委托类型。\n每个委托签名都获取0~4个参数，其类型使用类型参数来指定。最后一个类型参数用作每种情况下的返回类型。<br>\n例如：Func<string,double,int>等价于`public delegate int SomeDelegate(string arg1,double arg2)`\n\n### 转换成lambda表达式\n\n用匿名方法来创建委托实例\n\n```\nFunc<string,int> returnLength;\nreturnLength=delegate(string text){return text.Length;};\nConsole.WriteLine(returnLength(\"Hello\"));\n```\n\nLambda表达式最冗长的形式是：<br>\n`(显示类型的参数列表）=》{语句}`\n例子：\n\n```\nFunc<string, int> returnLength;\nreturnLength = (string text) => { return text.Length; };\n\nConsole.WriteLine(returnLength(\"Hello\"));\n```\n\nLambda表达式有着和匿名方法控制返回语句一样的规则：不能从Lambda表达式返回void类型\n\n### 使用单一表达式作为主体\n\n大多数情况可以用一个表达式来表示整个主体，该表达式的值是Lambda的结果\n\n```\n（string text)=>text.Length\n```\n\n### 隐式类型的参数列表\n\n编译器能推断出参数类型，可以不用显示声明参数类型，**注意：**隐式和显示类型参数不能一起用。此外要是有out或ref参数，只能使用显示参数。\n\n```\n(text)=>text.Length\n```\n\n### 单一参数的快捷语法\n\n如果lambda表达式只需要一个参数，且那个参数可以隐式指定类型，可以省略圆括号\n\n```\ntext=>text.Length\n```\n\n现在，例子简化成：\n\n```\n Func<string, int> returnLength;\nreturnLength =  text =>  text.Length;\n\nConsole.WriteLine(returnLength(\"Hello\"));\n```\n\n*高阶函数*<br>\nLambda表达式主体可以包含另一个Lambda表达式，另外，Lambda表达式的参数可以是另一个委托\n\n## 使用List<T>和事件的简单例子\n\n### 列表的过滤、排序和操作\n\nList<T>的FindAll方法，获取一个Predicate<T>,并返回一个新列表，包含原始列表中与谓词匹配的所有元素。Sort方法获取一个Comparison<T>,并相应地对列表进行排序。ForEach方法获取一个Action<T>,并对每个元素执行特定行为。\n\n```\nvar films = new List<Film>\n{\n    new Film {Name=\"Jaws\", Year=1975},\n    new Film {Name=\"Singing in the Rain\", Year=1952},\n    new Film {Name=\"Some like it Hot\", Year=1959},\n    new Film {Name=\"The Wizard of Oz\", Year=1939},\n    new Film {Name=\"It's a Wonderful Life\", Year=1946},\n    new Film {Name=\"American Beauty\", Year=1999},\n    new Film {Name=\"High Fidelity\", Year=2000},\n    new Film {Name=\"The Usual Suspects\", Year=1995}\n};\n\nAction<Film> print =\n    film => Console.WriteLine(\"Name={0}, Year={1}\", film.Name, film.Year);\n\n// Note: extra lines added for clarity when running\nConsole.WriteLine(\"All films\");\nfilms.ForEach(print);\nConsole.WriteLine();\n\nConsole.WriteLine(\"Oldies\");\nfilms.FindAll(film => film.Year < 1960)\n     .ForEach(print);\nConsole.WriteLine();\n\nConsole.WriteLine(\"Sorted\");\nfilms.Sort((f1, f2) => f1.Name.CompareTo(f2.Name));\nfilms.ForEach(print);\n\nConsole.Read();\n```\n\n创建委托实例,用来打印列表中的项，因为之后会使用三次，所以用变量print来保存，而不用每次都单独使用一个Lambda表达式。它可以打印一个film类型，通过foreach就能打印整个列表。\n`Action<Film> print = film => Console.WriteLine(\"Name={0}, Year={1}\", film.Name, film.Year);`\n\n```\n`films.ForEach(print);`\n```\n\n### 在事件处理程序中进行记录\n\n```\nstatic void Log(string title, object sender, EventArgs e)\n{\n    Console.WriteLine(\"Event: {0}\", title);\n    Console.WriteLine(\"  Sender: {0}\", sender);\n    Console.WriteLine(\"  Arguments: {0}\", e.GetType());\n    foreach (PropertyDescriptor prop in\n             TypeDescriptor.GetProperties(e))\n    {\n        string name = prop.DisplayName;\n        object value = prop.GetValue(e);\n        Console.WriteLine(\"    {0}={1}\", name, value);\n    }\n}\n\nstatic void Main()\n{\n    Button button = new Button();\n    button.Text = \"Click me\";\n    button.Click += (src, e) => Log(\"Click\", src, e);\n    button.KeyPress += (src, e) => Log(\"KeyPress\", src, e);\n    button.MouseClick += (src, e) => Log(\"MouseClick\", src, e);\n\n    Form form = new Form();\n    form.AutoSize = true;\n    form.Controls.Add(button);\n    Application.Run(form);\n}\n```\n\n## 表达式树\n\n### 以编程方式构建表达式树，编译并执行\n\n```\nExpression firstArg = Expression.Constant(2);\nExpression secondArg = Expression.Constant(3);\nExpression add = Expression.Add(firstArg, secondArg);\n\nFunc<int> compiled = Expression.Lambda<Func<int>>(add).Compile();\nConsole.WriteLine(compiled());\nConsole.Read();\n```\n\n### 将C# Lambda表达式转换成表达式树\n\n```\nExpression<Func<int>> return5 = () => 5;\nFunc<int> compiled = return5.Compile();\nConsole.WriteLine(compiled());\n```\n\n（）=》 5是Lambda表达式","tags":["C#"]},{"title":"深入理解C#（十五）：智能编译器","url":"/2019/01/09/深入理解C-（十五）：智能编译器/","content":"\n# 深入理解C#（十五）\n\n*第八章（C# 3：用智能的编译器来防错）<br>\n\n## 自动实现的属性\n\n简化普通属性的代码<BR>\n普通属性：可读/可写并将值存储到一个非常直观的私有变量中的属性。\n\n```\npublic string Name{get;set;}\n```\n\n仍然可以为取值和赋值方法指定不同的访问权限。\n\n静态自动属性：取值方法是共有的，赋值方法是私有的，且赋值方法只能在类型初始化程序中使用。\n\n**定义struct时，使用自动属性，需要显式地调用无参构造函数**\n\n```\npublic struct Foo\n{\n\tpublic int Value{get;private set;}\n\tpublic Foo(int value):this()\n\t{\n\t\tthis.Value=value;\n\t}\n}\n```\n\n自动属性仍有几个小问题：\n\n1. 没办法在声明时，设定初始的默认值\n2. 没法把它们设定成真正的只读属性（使用私有赋值方法来解决）\n\n## 隐式类型的局部变量\n\n### 使用var声明局部变量\n\n**var并没有把C#变成动态类型或者弱类型的语言，只是类型由编译器推断**<br>\n编译器获取初始化表达式在编译时的类型，并使变量也具有那种类型。\n\n### 隐式类型的限制\n\n只有在一下情况能使用：\n\n- 局部变量，不是静态字段和实例字段\n- 声明的同时被初始化\n- 初始化表达式不是方法组和匿名函数\n- 初始化表达式不是null\n- 语句中之声明了一个变量\n- 初始化表达式不包含正在声明的变量\n\n对于第三点，显示声明变量是可以的，如：\n`var starter = (ThreadStart)delegate(){ Console.WriteLine();}`\n对于null也可以做强制类型转换，但是无意义。\n\n最常见应用：用方法调用的结果来初始化一个变量。\n\n### 隐式类型的优缺点\n\n优点：增强可读性，改变代码重心\n缺点：类型不明确\n\n## 简化的初始化\n\n### 定义示例类型\n\n`new Person{Name=\"Jon\",Age=36}`\n\n### 为嵌入对象设置属性\n\n```\nPerson tom=new Person(\"Tom\"){\nAge=9,\nHome={Country=\"UK\",Town=\"Reading\"}\n};\n```\n\n### 集合初始化程序\n\n1. 使用集合初始化程序来创建新集合\n   `List<string> names=new List{ \"Holly\",\"Jon\",\"Tom\"};`\n   任何实现了IEnumerable类型，只要它为初始化列表中出现的每个元素都提供了一个恰当的公共的Add方法，就可以使用这个特性。\n2. 在其他对象初始化程序中填充集合\n\n## 隐式类型的数组\n\n对于`void MyMethod(string[] names)`\nC#3 这样使用：<br>\n`MyMethod(new[] {\"Holly\",\"Jon\",\"Tom\"});`\n\n## 匿名类型\n\n实例：使用匿名类型，填充数组\n\n```\nvar family = new[]\n{\n    new { Name = \"Holly\", Age = 37 },\n    new { Name = \"Jon\", Age = 36 },\n    new { Name = \"Tom\", Age = 9 },\n    new { Name = \"Robin\", Age = 6 },\n    new { Name = \"William\", Age = 6 }\n};\n\nint totalAge = 0;\nforeach (var person in family)\n{\n    totalAge += person.Age;\n}\nConsole.WriteLine(\"Total age: {0}\", totalAge);\n```\n\nfamily中所有人具有相同的类型，否则编译器无法推断出何时类型。\n\n### 匿名类型的成员\n\n- 一个获取所有初始值的构造函数\n- 共有的只读属性\n- 属性的私有只读字段\n- 重写的Equals、GethashCode和ToString\n\n### 投影初始化程序\n\n实际使用时，往往希望从别的对象复制属性用以新建一个新的对象。 例如：`new { Name=person.Name,IsAdult=(person.Age>=18)}`\nC# 3支持一种简化的语法：如果不指定属性名称，而只指定用于求指的表达式，它会使用表达式的最后一个部分作为名称，前提是它只是一个简单字段或属性。<br>\n应用：`new { person.Name, IsAdult=(Person.Age>=18)}`","tags":["C#"]},{"title":"深入理解C#（十四）：其他特性","url":"/2019/01/09/深入理解C-（十四）：其他特性/","content":"\n# 深入理解C#（十四）\n\n*第七章（C# 2：其他特性）<br>\n**分部类型，静态类，独立的取值方法，命名空间别名，Pragma指令，固定大小的缓冲区，InternalsVisibleToAttribute（友元程序集）**\n\n## 分部类型\n\n### 在多个文件中创建一个类型\n\n创建分部类型，只需要加上partial关键字。编译器实际上是在编译之前把所有源文件合并在一起。（这就是为什么C#文件名和类名可以不一致了，同样一个class Example，可以用分部类型，写多个Example1/2/...cs文件\n\n举例：\n\n```\n partial class Example<TFirst, TSecond>\n    : IEquatable<string>\n    where TFirst : class\n{\n    public bool Equals(string other)\n    {\n        return false;\n    }\n}\n```\n\n在这个文件中声明接口和类型参数约束\n\n```\n partial class Example<TFirst, TSecond>\n    : EventArgs, IDisposable\n{\n    public void Dispose()\n    {\n    }\n}\n```\n\n在这个文件中声明基类和接口\n\n### 分布类型的使用\n\n分布类型的用途：<br>\n\n1. 主要联接设计器和其他代码生成器\n2. 辅助进行重构\n3. 单元测试\n\n## C# 3的分部方法\n\n分部方法的声明与抽象方法相同:<br>\n使用partial修饰符无须实现，在实际的实现部分也要partial修饰符。<br>\n分部方法可以不被实现，这些未被实现的分部方法的调用会被编译器移除。<br>\n由于方法可能不存在，分部方法返回类型必须为void，且不能获取out参数。必须是私有的\n\n## 静态类型\n\n## 独立的取值方法/赋值方法属性访问器\n\n举例：\n​\t\n\n```\nstring name;\npublic string Name\n{\n\tget{return name;}\n\tprivate set{ name=value;}\n}\n```\n\nName属性对于其他所有类型都是只读的，但在类型内部能用属性语法设置。<br>\n**大部分的默认访问修饰符是私有的，但对于取值/赋值方法，访问修饰符和属性本身整体上保持一致**<br>\n**另外不能把属性设为私有，但把取值方法设为公有**\n\n## 命名空间别名\n\n### 限定的命名控件别名\n\nC# 1例子：\n​\t\n\n```\nusing System;\nusing System.ComponentModel;\nusing WebForms = System.Web.UI.WebControls;\nusing WinForms = System.Windows.Forms;\n\nnamespace Chapter07\n{\n[Description(\"Listing 7.05\")]\nclass SimpleAliases\n{        \n    static void Main()\n    {\n        Console.WriteLine (typeof (WinForms.Button));\n        Console.WriteLine (typeof (WebForms.Button));\n    }\n}\n}\n```\n\n若有一个类也叫WinForms，那编译器该如何区分？\nC# 2改进：\n\n```\nusing System;\nusing System.ComponentModel;\nusing WebForms = System.Web.UI.WebControls;\nusing WinForms = System.Windows.Forms;\n\nnamespace Chapter07\n{\n[Description(\"Listing 7.06\")]\nclass DoubleColonForAliases\n{\n    class WinForms\n    {\n    }\n    \n    static void Main()\n    {\n        Console.WriteLine (typeof (WinForms::Button));\n        Console.WriteLine (typeof (WebForms::Button));\n    }\n}\n}\n```\n\n引入“::“来区分命名空间和类型\n\n### 全局命名空间别名\n\n无法为命名空间层级的根或全局命名空间定义别名。<BR>\n可以使用`global::`\n\n### 外部别名\n\n## pragma指令\n\npragma指令是一个由`#pragma`开头的代码行所表示的预处理指令，它后面能包含任何文本。\n\n### 警告pragma\n\n举例：例如我们使用了一个从未使用的变量，但想要忽略编译器警告\n\n```\n#pragma warning disable 0169\nint x;\n#pragma warning restore 0169\n```\n\n### 校验和pragma\n\n## 非安全代码中固定大小的缓冲区\n\n## 把内部成员暴露给选定的程序集\n\n\n\n","tags":["C#"]},{"title":"深入理解C#（十三）：迭代器","url":"/2019/01/09/深入理解C-（十三）：迭代器/","content":"\n# 深入理解C#（十三）\n\n*第六章（C# 2：实现迭代器的捷径）<br>\n\n## 知识简介\n\n迭代器模式：行为模式的一种范例，允许访问一个数据项序列中的所有元素，而不用关心序列的类型。能有效构建一个数据管道。(数据项序列进入数据管道后，经过一系列不同的转换或过滤后再从另一端出来）<br>\n行为模式：一种简化对象之间通信的设计模式\n\n迭代器模式通过IEnumerator和IEnumerable接口以及它们的泛型等价物来封装。若某个类型实现了IEnumerable接口，就意味着它可以被迭代访问。\n\n难点在于怎么自建迭代器\n\n## C# 2：利用yield语句简化迭代器\n\n利用C# 2和yield return来迭代实例集合：\n\n```\npublic IEnumerator GetEnumerator()\n{\n\tfor(int index=0;index<values.Length;index++)\n\t{  yield return values[(index+startingPoint)%values.Length];\n\t}\n}\n```\n\n这是一个实现迭代器块的方法，这个方法被声明为返回一个\nIEnumerator接口，所以就只能使用迭代器块来实现返回类型为IEnumerable、IEnumerator等的方法。如果方法声明的返回类型是非泛型接口，那么迭代器块的生成类型(yield type)是object，否则就是泛型接口的类型参数。如：方法声明返回IEnumerable<string>,就会得到string类型的生成类型。<BR>\n*在迭代器块中存在try/catch或try/finally代码块时，不能在try和finally中使用yield return*<BR>\n**编写迭代器块代码实际上是在请求编译器创建一个状态机**<BR>\n当编译器看到迭代器块时，会为状态机创建一个嵌套类型，来正确记录块中的位置，以及局部变量（包括参数）的值。<BR>\n这个状态机实现一下功能：\n\n- 必须具有某个初始状态\n- 每次调用MoveNext，提供下一个值之前（执行到yield return语句之前），执行GetEnumerator方法中的代码\n- 使用Current属性时，返回生成的上一个值\n- 知道何时完成生成值的操作，以便MoveNext返回false\n\n### 迭代器的工作流程\n\n- 在第一次调用MoveNext之前，CreateEnumerable不会被调用\n- 所有工作在调用MoveNext时就完成了，获取Current的值，不执行任何代码\n- 在yield return的位置，代码就停止执行，在下一次调用MoveNext时又继续执行\n- 在一个方法中的不同地方可以编写多个yield return语句\n- 代码不会在最后的yield return处结束，而是通过返回false的MoveNext调用来结束\n\n### 进一步了解\n\nyield return语句临时推出了方法，知道再次调用MoveNext后继续执行，根本没有检查finally代码块的行为。<BR>\n*迭代器块不能实现具有ref或out参数的方法*<BR>\nyield break结束迭代器的执行,类似于普通方法中的return语句<BR>\nfinally在迭代器块中常用于释放资源，通常与using语句配合使用\n\n## 迭代器示例\n\n### 迭代时刻表中的日期\n\nC# 1\n\n```\nfor(DataTime day=timetable.StartDate;\n\tday<=timetable.EndDate;\n\tday=day.AddDays(1))\n```\n\nC# 2\n​\tforeach(DateTime day in timetable.DateRange)\n想要手动实现迭代器很麻烦，但用迭代器块就很方便。为表示时刻表的类添加一个属性：\n\n```\npublic IEnumerable<DateTime> dateRange\n{\n\tget\n\t{\n\t\tfor(DateTime day=StartDate；\n\t\t\tday<=EndDate;\n\t\t\tday=day.AddDays(1))\n\t\t{\n\t\t\tyield return day;\n\t\t}\n\t}\n}\n```\n\n### 迭代文件中的行\n\n在.NET 4中，框架提供了reader.ReadLines来实现,如何自己轻松实现？\nC# 1\n\n```\nusing(TextReader reader=File.OpenText(filename))\n{\n\tstring line;\n\twhile((line=reader.ReadLine()) != null)\n\t{\n\t\t//针对line进行操作\n\t}\n}\n```\n\n- 获取TextReader\n- 管理TextReader的生命周期（using）\n- 迭代TextReader.ReadLine返回的行\n- 对这些行处理\n\n生命周期管理和迭代机制都是样板代码，有两种方法改进。<br>\n一。使用委托，编写一个工具方法，将阅读器和委托作为参数，为文件中的每一行调用该委托，最后关闭阅读器。<br>\n二。使用迭代器一次返回文件中的一行，如下\n\n```\npublic static IEnumerable<string> ReadLines(string filename)\n    {\n        using (TextReader reader = File.OpenText(filename))\n        {\n            string line;\n            while ((line = reader.ReadLine()) != null)\n            {\n                yield return line;\n            }\n        }\n    }\n\nforeach (string line in ReadLines(@\"文件路径\"))\n        {\n            Console.WriteLine(line);\n        }\n```\n\n进一步改进：如果我们想从网络流中读取文本或使用UTF-8以外的编码格式，最简单的想法是重新修改方法签名，使其接受一个TextReader。但这个方案很糟糕，问题是，如果在第一次调用MoveNext（）之前发生了异常，就没有机会清理了。另外，若GetEnumerate人（）被调用两次，但它们使用相同的阅读器。\n\n```\nstatic IEnumerable<String> ReadLines（Func <TextReader> provider)\n{\n\tusing (TextReader reader=provider())\n\t{\n\t\t。。。\n```\n\n### 使用迭代器块和谓词对进行延迟过滤\n\n**看过linq后回来重看**\n\n### CCR实现伪同步代码\n\nCCR（Concurrency and Coordination Runtime，并发和协调运行时）\n**看完异步开发回来看**\n\n​\t","tags":["C#"]},{"title":"深入理解C#（十二）：匿名方法","url":"/2019/01/09/深入理解C-（十二）：匿名方法/","content":"\n# 深入理解C#（十二）\n\n*第五章（C# 2：进入快速通道的委托（下））<br>\n**匿名方法**\n\n## 使用匿名方法的内联委托操作\n\nC# 1中的问题：用特定签名来实现委托是很常见的情况。有时只需要一个委托来做一件很简单的事，但是必须创建一个完整的新方法。\n\n匿名方法允许指定一个内联委托实例的操作，作为创建委托实例表达式的一部分。\n\n## 简单的匿名方法实例：处理一个参数\n\n.NET 2.0有一个泛型委托类型Action<T>,它的签名如下：<BR>\n`public delegate void Action<T>(T obj)`<br>\nAction<T>就是对T的一个实例执行某些操作。如Action<string>可以反转字符串并打印出来，Action<int>可以打印传给它的那个数的平方根，Action<IList<double>>可以计算出传给它的所有数的平均值并打印。<br>\n实例：\n\n```\nAction<string> printReverse = delegate (string text)\n{\nchar[] chars = text.ToCharArray();\nArray.Reverse(chars);\nConsole.WriteLine(new string(chars));\n};\n```\n\n匿名方法的语法：<br>\ndelegate关键字，参数，代码块（定义对委托实例的操作）匿名方法的结果是一个委托实例，和调用普通方法一样调用委托。\n\n```\nprintReverse(\"hello world\");\n```\n\n**逆变性不适用于匿名方法：必须指定和委托类型完全匹配的参数类型**\n\n匿名方法的是实现，是在IL中为源代码中断每个匿名方法创建一个方法\n\n一个更精简的极端例子：体现匿名方法的一般用法，即作为传给另一个方法的参数使用。\n\n```\nList<int> x = new List<int>();\nx.Add(5);\nx.Add(10);\nx.Add(15);\nx.Add(20);\nx.Add(25);\n\nx.ForEach(delegate (int n) { Console.WriteLine(Math.Sqrt(n)); });\n```\n\n### 匿名方法的返回值\n\n```\nPredicate<int> isEven = delegate (int x)\n        { return x % 2 == 0; };\n\nConsole.WriteLine(isEven(1));\nConsole.WriteLine(isEven(4));\n```\n\n没有必要再声明一个返回类型，因为编译器会检查是否所有可能返回值都兼容于委托类型声明的返回类型。\n\n### 忽略委托参数\n\n```\n class IgnoredParametersAnonymousMethods\n{\n    static void Main()\n    {\n        Button button = new Button();\n        button.Text = \"Click me\";\n        button.Click += delegate { Console.WriteLine(\"LogPlain\"); };\n        button.KeyPress += delegate { Console.WriteLine(\"LogKey\"); };\n        button.MouseClick += delegate { Console.WriteLine(\"LogMouse\"); };\n\n        Form form = new Form();\n        form.AutoSize = true;\n        form.Controls.Add(button);\n        Application.Run(form);\n    }\n}\n```\n\n一般写法：`button.Click+=delegate(object sender,EventArgs e){...}`\n\n## 匿名方法中的捕获变量\n\n匿名方法外部对变量的更改在匿名方法内部是可见的，反之亦然。\n\n```\nstatic void Main()\n{\nstring captured = \"before x is created\";\n\nMethodInvoker x = delegate\n{\n    Console.WriteLine(captured);\n    captured = \"changed by x\";\n};\n\ncaptured = \"directly before x is invoked\";\nx();\n\nConsole.WriteLine(captured);\n\ncaptured = \"before second invocation\";\nx();\nConsole.Read();\n}\n```\n\n**创建委托实例不会导致执行**<br>\n**在整个方法中，我们使用的始终是同一个captured变量**\n\n### 捕获变量的实际用处\n\n能简化避免专门创建一些类来存储一个委托需要处理的信息（除了作为参数传递信息之外）\n\n```\nList<Person> FindAllYoungerThan(List<Person> people,int limit)\n{\n\treturn people.FinaAll(delegate(Person person){ return person.Age<limit;});\n}\n```\n\n我们在委托实例内部捕获了limit参数，若不支持捕获变量，就不能使用作为参数传递的limit\n\n### 捕获变量的延长生存期\n\n**对于一个捕获变量，只要还有任何委托实例在引用它，它就会一直存在**\n\n### 局部变量实例化\n\n每声明一次局部变量，它就被实例化一次。\n\n### 捕获变量的使用规则和小结\n\n- 只在复杂情况下使用\n- 捕获有for或foreach语句声明的变量之前，思考委托是否需要在循环迭代结束后延续，不是则在循环内另建一个变量来复制想要的值。\n- 若创建多个委托实例，且捕获了变量，思考是否希望它们捕捉同一个变量\n- 如果捕获的变量不发生改变，无需担心","tags":["C#"]},{"title":"深入理解C#（十一）：改进的委托","url":"/2019/01/09/深入理解C-（十一）：改进的委托/","content":"\n# 深入理解C#（十一）\n\n*第五章（C# 2：进入快速通道的委托（上））<br>\n\n## 回顾C# 1中我们的做法\n\n总是先定义事件/委托实际要处理的方法，如：\n\n```\n  static void LogKeyEvent(object sender, KeyPressEventArgs e)\n    {\n        Console.WriteLine(\"LogKey\");\n    }\n```\n\n然后new一个新的事件/委托实例，把这个方法加到委托列表中，如：\n​\t\n\n```\n  button.KeyPress += new KeyPressEventHandler(LogKeyEvent);\n```\n\n我们总是要把委托实例实际执行的代码做参数穿给委托实例，这样绕弯子会使代码难以阅读，且使得类中填充了大量只用于委托的方法。\n\n## 方法组转换\n\nC# 2支持从方法组到一个兼容委托类型的隐式转换。方法组（method  group）其实就是一个方法名，可以选择添加一个目标，也就是说和C# 1中创建委托实例使用的表达式相同（含义不同，一个是类型加参数，一个是方法组）。新的隐式转换：\n​\t\n\n```\nbutton.KeyPress+=LogkeyEvent;\n```\n\n一个创建线程的代码：\n\n```\nThread t=new Thread(MyMethod);\n```\n\n为什么表达式如`LogKeyEvent`属于方法组，因为如果有重载的话，可能不止一个方法适用。隐式转换会将一个方法组转换为具有兼容签名的任意委托类型。<BR>\n假定有以下两个方法签名：\n\n```\nvoid MyMethod()\nvoid MyMethod(object sender,EventArgs e)\n```\n\n那么在向一个ThreadStart或EventHandler赋值时，都可以将MyMethod作为方法组使用：\n\n```\nThreadStart x=MyMethod;\nEventHandler y=MyMethod；\n```\n\n对于本身已重载成可以获取一个ThreadStart或EventHandler的方法，不能把它作为方法的参数使用。同样，不能利用隐式方法组转换来转换成普通的System.Delegate类型。可用辅助方法、强制转换或中间变量来解决。\n\n## 协变性和逆变性\n\n### 委托参数的逆变性\n\n举例说明：\n\n```\npublic delegate void EventHandler(object sender,EventArgs e)\npublic delegate void KeyPressEventHandler(object sender, KeyPressEventArgs e)\npublic delegate void MouseEventHandler(object sender,MouseEventArgs e)\n```\n\n有三个委托类型的签名：KeyPressEventArgs和MouseEventArgs都是从EventArgs派生\n利用方法组转换和委托逆变性：\n\n```\nstatic void LogPlainEvent(object sender, EventArgs e)\n{\n    Console.WriteLine (\"An event occurred\");\n}\n\nstatic void Main()\n{\n    Button button = new Button();\n    button.Text = \"Click me\";\n    button.Click += LogPlainEvent;\n    button.KeyPress += LogPlainEvent;\n    button.MouseClick += LogPlainEvent;\n\n    Form form = new Form();\n    form.AutoSize = true;\n    form.Controls.Add(button);\n    Application.Run(form);\n}\n```\n\n用一个事件处理方法来处理所有事件。\n\n*关于事件处理方法的参数说明：*<BR>\n第一个参数是object类型，代表事件来源；第二个参数则负责携带与事件有关的任何额外信息\n\n在有委托参数协变性后，我们可以使用一个具有EventHandler签名的方法，作为符合约定的所有委托类型的操作。\n\n### 委托返回类型的协变性\n\n举例：<BR>\n首先声明一个委托类型\n\n```\ndelegate Stream StreamFactory();\n```\n\n然后声明一个方法返回一个特定的流类型。\n\n```\nstatic MemoryStream GenerateSampleData()\n{\n    byte[] buffer = new byte[16];\n    for (int i = 0; i < buffer.Length; i++)\n    {\n        buffer[i] = (byte)i;\n    }\n    return new MemoryStream(buffer);\n}\n```\n\n利用协变性转换方法组\n\n```\nstatic void Main()\n{\n    StreamFactory factory = GenerateSampleData;\n\n    using (Stream stream = factory())\n\t//调用委托\n    {\n        int data;\n        while ((data = stream.ReadByte()) != -1)\n        {\n            Console.WriteLine(data);\n        }\n    }\n    Console.Read();\n}\n```\n\n注意：委托的返回类型是stream\n,但声明的方法的返回类型是MemoryStream。<br>\n`StreamFactory factory = GenerateSampleData;`这句话用到了方法组的转换，并利用返回类型的协变性来允许GenerateSampleData用于StreamFactory，等到调用委托实例时，实际返回的是委托声明的类型，也就是说返回类型已从MemoryStream协变成stream\n\n利用协变性和逆变性，还可以基于一个委托实例来构造另一个委托实例。\n\n```\nEventHandler general=new EventHandler(HandleEvent);\nKeyPressEventHandler key=new KeyPressEventHandler(general);\n```\n\n### 不兼容的风险\n\n可能发生在派生类中。\n\n","tags":["C#"]},{"title":"深入理解C#（十）：可空类型","url":"/2019/01/09/深入理解C-（十）：可空类型/","content":"\n# 深入理解C#（十）\n\n*第四章（C# 2：可空类型）<br>\n\n## C# 1中表示空值的模式\n\n1. 魔值：牺牲一个值来表示空值（DBNull.Value表示数据库返回null的情况，这个魔值表示所有类型的空值）\n2. 引用包装类型：直接用object作为变量类型，并根据需要进行装箱和拆箱\n3. 额外的布尔标志：使用一个普通的值类型的值，同时使用另一个布尔标志来表示值是“真正”存在还是被忽略。要么在代码中维护两个单独的变量，要么将值和标志封装到另一个值类型中。\n\n## `System.Nullable<T>`和System.Nullable\n\n`Nullable<T>`是一个有着值类型约束的泛型类型。T的类型称为可空类型的基础类型(underlying type)。<br>\n`Nullable<T>`有两个重要属性：HasValue和Value。就是采用上面第三种实现模式。<br>\n**`Nullable<T>`仍为值类型，值将直接包含一个bool和一个int，而不是其他对象的引用**<br>\n`Nullable<T>`引入一个名为GetValueOrDefault的新方法。存在值就返回值否则返回默认值/自己指定的返回值。<br>\n`Nullable<T>`覆盖了其他方法：GetHashCode,ToString和Equals。GetHashCode在没有值时返回0，ToString在没有值时返回空字符串<br>\n**再次强调`Nullable<T>`是一个结构（值类型),如果把它转换成引用类型，需要对它装箱**<br>\n调用first.Equals(second)的具体规则：\n​\t\n\n- first没有值，second为null，相等\n- first没有值，second不为null，不相等\n- first有值，second为null，不相等\n- 否则，若first的值等于second，相等\n\nSystem.Nullable类是一个静态类，只包含静态方法。\n提供三个有用方法：\n\n```\npublic static int Compare<T>(Nullable<T> n1,Nullable<T> n2)\npublic static bool Equals<T>(Nullable<T> n1,Nullable<T> n2)\npublic static Type GetUnderlyingType(Type nullableType)\n```\n\nCompare使用Comparer<T>.Default来比较两个基础值，Equals使用EqualityComparer<T>.Default。空值与空值相等，小于其他所有值。<br>\n第三个方法如果参数是一个可空类型，方法就返回它的基础类型；否则返回null。\n\n## C# 2为可空类型提供的语法糖\n\n### ？修饰符\n\n`Nullable<byte>`与`byte?`可相互转换\n\n### 使用null进行赋值和比较\n\n### 可空转换和操作符\n\n如果一个非可空的值类型支持一个操作符或一种转换，且那个操作符或转换只涉及其他非可空的值类型时，那么对应可空的值类型也支持同样的操作符或转换。举例：int=》long，int？=》long？<br>\n*具体细节待看*\n\n### 可空逻辑\n\n### 对可空类型使用as操作符\n\n在C# 2之前，as只能用于引用类型。在C# 2中，也可以用于可空类型。\n\n### 空合并操作符（？？）\n\nfirst？？second<br>\n\n1. 对first进行求值；\n2. 如结果非空，该结果就是表达式的结果\n3. 否则求second的值，其结果为整个表达式的结果\n   这个操作符还可用于可空值类型+引用类型<br>\n   这个操作符是右结合的<br>\n\n用法案例：<br>\n假设有一个在线订购系统，有billing address（账单寄送地址），contact address（联系地址），以及shipping address（送货地址）等，任何用户都必须有一个billing address，但contact address是可选的。对于一个订单来说，送货地址也是可选的，默认为billing address。遇到送货问题，要找联系人时。<br>\nC# 1实现：\n​\t\n\n```\nAddress contact=user.ContactAddress;\nif(contact==null)\n{\n\tcontact=order.ShippingAddress;\n\tif(contact==null)\n\t{\n\t\tcontact=user.BillingAddress;\n\t}\n}\n```\n\nC# 2改进：\n\n```\nAddress contact=user.ContactAddress??\n\t\t\t\torder.ShippingAddress??\n\t\t\t\tuser.BilllingAddress;\n```\n\n## 可空类型的新奇用法\n\n### 尝试一个不使用输出参数的操作\n\n输出参数的常规用法：用一个返回值来判断一个操作是否成功，并用一个输出参数来返回真正的结果。<br>\n返回引用类型的方法经常使用这样一种模式：失败时返回null，成功是返回非空值。但是，假如在方法执行成功的前提下，null也是一个有效的返回值，这样就不行了。\n\n```\nArrayList list=hash[key];\nif(list==null)\n{\n\tlist=new ArrayList();\n\thash[key]=list;\n}\nlist.Add(newItem);\n```\n\n*假设HashTable和Dictionary<Tkey,TValue>可以获取一个委托，每次查找到一个不存在的键时就调用这个委托来添加一个新值。使用这个模式适用这种情况。*\n使用可空类型，能将这种模式扩展至值类型。\n\n具体实例：\n\n```\npublic static bool TryParse(string s, out Int32 result);\n```\n\n这个int的方法的传统用法如下：\n\n```\nint result; \nif (int.TryParse(\"Not valid\", out result))\n{\n    Console.WriteLine(\"Parsed to {0}\", result);\n}\nelse\n{\n    Console.WriteLine(\"Couldn't parse\");\n}\nConsole.Read();\n```\n\n如果我们用可空类型：\n\n \tclass NullableTryParse\n​    {\n​        static int? TryParse(string data)\n​        {\n​            int ret;\n​            if (int.TryParse(data, out ret))\n​            {\n​                return ret;\n​            }\n​            else\n​            {\n​                return null;\n​            }\n​        }\n\n```\n    static void Main()\n    {\n        int? parsed = TryParse(\"Not valid\");\n        if (parsed != null)\n        {\n            Console.WriteLine(\"Parsed to {0}\", parsed.Value);\n        }\n        else\n        {\n            Console.WriteLine(\"Couldn't parse\");\n        }\n    }\n}\n```\n\n这样做的好处是它将返回值与解析是否成功封装在一个变量中，还把做和测试分离了。<br>\n还有一个好处是可以和空合并操作符配合使用。<br>\n**小结一下：**<BR>\n上述模式的要点在于：先定义并获取方法返回值（做），再判断返回值（测试）。<BR>\n如返回值是引用类型，我们可以通过判断是否为null，很容易实现这个模式，但若是值类型，就不好办了（除非我们定义一个特殊值，但这样会导致语义不明，就像魔数一样），所以就用到了可空类型，这样我们也能像使用引用类型一样，使用值类型。<BR>\n更好的做法：在.NET 4中包含了Tuple类型，使用元祖可以使返回值含义更明确。\n\n### 空合并操作符简化比较\n\n问题背景：假设要写一个电子商务网站，且有一个产品列表。希望按流行度，价格，名称依次排序。<BR>\nC# 1的实现：\n\n```\npublic int Compare(Product first,Product second)\n{\n\tint ret=second.Popularity.CompareTo(first.Popularity);\n\tif( ret !=0)\n\t{\n\t\treturn ret;\n\t}\n\tret=first.Price.CompareTo(second.Price);\n\tif(ret ！=0）\n\t{\n\t\treturn ret；\n\t}\n\treturn first.Name.CompareTo(second.Name);\n}\n```\n\n我们往往这样写Compare方法。但若是属性返回为null，我们在比较前还要先判断非空，这样代码就太复杂了。我们可以用空合并操作符来简化代码。\n\nC# 2 ？？操作符实现：\n\n```\npublic static class PartialComparer\n{\n    public static int? Compare<T>(T first, T second)\n    {\n        return Compare(Comparer<T>.Default, first, second);\n    }\n\n    public static int? Compare<T>(IComparer<T> comparer,T first,T second)\n    {\n        int ret = comparer.Compare(first, second);\n        return ret == 0 ? new int?() : ret;\n    }\n\n    public static int? ReferenceCompare<T>(T first, T second)\n        where T : class\n    {\n        return first == second ? 0\n             : first == null ? -1\n             : second == null ? 1\n             : new int?();\n    }\n\n    public static bool? ReferenceEquals<T>(T first, T second)\n        where T : class\n    {\n        return first == second ? true\n             : first == null ? false\n             : second == null ? false\n             : new bool?();\n    }\n}\n```\n\n先实现一个用于比较的辅助类。可注意ReferenceCompare方法中的条件操作符用法。<BR>\n现在可以重写Compare方法：\n\n```\npublic int Compare(Product first, Product second)\n    {\n\t\treturn PartialComparer.ReferenceCompare(first, second) ??\n\t\t// Reverse comparison of popularity to sort descending\n\t\tPartialComparer.Compare(second.Popularity, first.Popularity) ??\n\t\tPartialComparer.Compare(first.Price, second.Price) ??\n\t\tPartialComparer.Compare(first.Name, second.Name) ??\n\t\t0;\n    }\n```\n\n最后的0指明前面所有比较都通过，这两个Product相等。也可用`Comparer<string>.Default.Compare(first.Name,second.Name)`作比较。","tags":["C#"]},{"title":"深入理解C#（九）：泛型","url":"/2019/01/09/深入理解C-（九）：泛型/","content":"\n# 深入理解C#（九）\n\n*第三章（C# 2：泛型实现参数化类型）<br>\n\n## 理解泛型类型和方法\n\n## 泛型方法的类型推断\n\n例子：\n\n```\nstatic List<T> MakeList<T>(T first,T second)\n...\nList<string> list=MakeList<string>(\"Line 1\",\"Line 2\");\n```\n\n使用编译器的类型推断：\n\n```\nList<string> list=MakeList(\"Line 1\",\"Line 2\");\n```\n\n## 类型约束\n\n如List<int>等，所有类型参数都可以指定为任意类型，它们**未被约束**。我们想制定规则，从而判断哪些是泛型类型或泛型方法呢能接受的有效类型实参。<br>\n用**约束**来实现。约束放在泛型方法或泛型类型声明的末尾，有上下文关键字where引入。\n\n1. 引用类型约束<br>\n   确保使用的类型实参是引用类型：必须是第一个约束<br>\n   `struct RefSample<T> where T:class`<br>\n   以这种方式约束一个类型参数后，可以使用==和！=来比较引用（包括null）\n2. 值类型约束<br>\n   确保使用的类型实参是值类型:<br>\n   `class ValSample<T> where T:struct`br>\n   设定值类型约束后，不允许使用==和！=进行比较。<br>\n   以上两种约束比较少用，后两者更有用。\n3. 构造函数类型约束<br>\n   检查类型实参是否有一个可用于创建类型实力的无参构造函数。必须是最后一个约束。<br>\n   `public T CreateInstance() where T : new()\n   {\treturn new T();\t}`<br>\n   在使用工厂风格的设计模式时，这个约束非常有用。\n4. 转换类型约束<br>\n   指定另一个类型，类型实参必须可以通过一致性、引用或装箱隐式地转换为该类型。还可以规定一个类型实参必须可以转换为另一个类型实参。<br>\n   这个约束意味着“在类型参数的实例上使用指定类型的成员”\n\n## 实现泛型\n\n假装T是一个真正的类型名称。额外要注意：<br>\n\n1. 默认值表达式：<br>\n   例子：Dictionary<TKey,TValue>有一个TryGetValue方法：用一个输出参数来接受你打算获取的值，用boolean返回值显示是否成功。这意味着方法必须用TValue类型的值来填充输出参数。<br>\n   C# 2提供了默认值表达式(default value expression)。<br>\n   例子：以泛型方式将一个给定的值和默认值进行比较\n\n   class DefaultValueComparison\n    {\n   ​     static int CompareToDefault<T>(T value)\n   ​         where T : IComparable<T>\n   ​     {\n   ​         return value.CompareTo(default(T));\n   ​     }\n\n   ```\n    static void Main()\n    {\n        Console.WriteLine(CompareToDefault(\"x\"));\n        Console.WriteLine(CompareToDefault(10));\n        Console.WriteLine(CompareToDefault(0));\n        Console.WriteLine(CompareToDefault(-10));\n        Console.WriteLine(CompareToDefault(DateTime.MinValue));\n    }\n   ```\n\n    }\n\n这个泛型方法规定了只能使用实现了IComparable<T>接口的类型，这样才能为传入的值调用CompareTo（T）\n\n类型推断只能用于泛型方法，有一个泛型类型，其中不包含任何泛型方法，怎么实现类型推断？<br>\n`Pair<int,string> pair=new Pair<int,string>(10,\"value\");`\n解决方法是使用包含泛型方法的非泛型辅助类。\n​\t\n\n```\npublic static class Pair\n{\n\tpublic static Pair<T1,T2> Of<T1,T2>(T1 first,T2 second)\n\t{\n\t\treturn new Pair<T1,T2>(first,second);\n\t}\n}\n\nPair<int,string> pair=Pair.Of(10,\"value\");\n```\n\n等到第七章再回看\n\n1. 直接比较\n   如果一个类型参数是未约束的（即没有对其应用约束），那么只能在该类型的值与null比较时才能使用==和！=操作符。不能直接比较两个T类型的值。如果一个类型参数被约束成值类型，就完全不能为它使用==和！=。如果被约束成引用类型，具体比较将完全取决于类型参数被约束成什么类型。\n\n## 高级泛型\n\n### 静态字段和静态构造函数\n\n**每个封闭类型都有它自己的静态字段集**<br>\n同样的规则也适用于静态初始化程序和静态构造函数。\n\n### JIT(just in time即时)编译器如何处理泛型\n\n暂略\n\n### 泛型迭代\n\n对集合执行的最常见操作之一是便利（迭代）所有元素。最简单的办法使用foreach语句。<br>\n当需要为自己的某个类型实现迭代时，由于IEnumerable<T>扩展了旧的IEnumerable接口，所以要实现两个不同方法：<br>\nIEnumerator<T> GetEnumerator();\nIEnumerator GetRnumerator();\n\n## 反射和泛型\n\n反射的一切都是围绕“检查对象及其类型”展开的。<br>\ntypeof可通过两种方式作用于泛型类型。一种方式是获取泛型类型定义，另一种方式是获取特定的已构造类型。<br>\ntypeof(Dictionary<,>)或typeof(Dictionary<string,X>)<br>\n\n获取泛型和已构造Type对象的各种方式<br>\n​\t\n\n```\nstring listTypeName = \"System.Collections.Generic.List`1\";\n\nType defByName = Type.GetType(listTypeName);\n\nType closedByName = Type.GetType(listTypeName + \"[System.String]\");\nType closedByMethod = defByName.MakeGenericType(typeof(string));\nType closedByTypeof = typeof(List<string>);\n\nConsole.WriteLine(closedByMethod == closedByName);\nConsole.WriteLine(closedByName == closedByTypeof);\n\nType defByTypeof = typeof(List<>);\nType defByMethod = closedByName.GetGenericTypeDefinition();\n\nConsole.WriteLine(defByMethod == defByName);\nConsole.WriteLine(defByName == defByTypeof);\n```\n\n反射泛型方法<br>\n\n```\npublic static void PrintTypeParameter<T>()\n{\nConsole.WriteLine(typeof(T));\n}\n\nstatic void Main()\n{\nType type = typeof(GenericMethodReflection);\nMethodInfo definition = type.GetMethod(\"PrintTypeParameter\");\nMethodInfo constructed;\nconstructed = definition.MakeGenericMethod(typeof(string));\nconstructed.Invoke(null, null);\n}\n```\n\n1. 获取泛型方法定义\n2. 使用MakeGenericMethod返回一个已构造的泛型方法。\n3. 后去已构造的方法后，就可以调用了。\n\n## 泛型在C#和其他语言中的一些限制\n\n为什么不能将List<string>转换成List<object>?<br>\n泛型是不变的，但为什么数组是协变的？<br>\n为了支持从JAVA中编译来的代码，因为Java有协变数组。\n\n使用泛型辅助类解决逆变性缺乏问题\n\n缺乏操作符约束或者数值约束<br>\n解决方法：<br>\n\n1. [表达式树，第九章](http://mng.bz/9m8i)\n2. C# 4的动态特性，14章有例子\n\n为什么泛型只限于类型（包括类、结构、委托和接口）和方法?\n\n1. 缺乏泛型属性、索引器和其他成员类型\n\n## 第三章小结\n\n泛型的三个优点：<br>\n\n1. 编译时的类型安全性\n2. 性能\n3. 代码的表现力\n   IDE和编译器能提前验证代码\n\n值类型性能上获益最大。在强类型的泛型API中，不再需要装箱和拆箱。\n使用泛型，代码能更清楚地表达其意图。","tags":["C#"]},{"title":"深入理解C#（八）：类型系统","url":"/2019/01/09/深入理解C-（八）：类型系统/","content":"\n# 深入理解C#（八）\n\n*第二章（C# 类型系统）<br>\n**C# 1的类型系统是静态的、显示的和安全的**\n\n静态：描述表达式的编译时类型，使用**不变的**数据来分析哪些操作可用。\n\n## C# 1的类型系统何时不够用\n\n.NET 1.1内建了三种集合类型：\n\n- 数组--强类型--内建到语言和运行时中\n- System.Collections命名空间中的弱类型集合\n- System.Collections.Specialized命名空间中的强类型集合\n\n*引用类型的数组支持协变（covariance），只要元素的类型之间允许转换，就能隐式将一种数组类型转换成另一种*\n\n**方法覆盖和接口实现不允许协变性/逆变性**<br>\n参数类型的逆变性：使用一个放宽限制的签名如：`void Process(object x)`\n\n## 值类型和引用类型\n\n类是引用类型；结构是值类型<br>\n数组是引用类型；枚举是值类型<br>\n委托类型是引用类型；接口类型是引用类型，但可由值类型实现\n\n### 变量存储\n\n1. 变量的值在它声明时的位置存储\n2. 局部变量的值总是存储在栈（stack）中（C# 1中完全成立，高级版本可能存在堆中）\n3. 实例变量的值总是存储在实例本身存储的地方\n4. 引用类型实例总是存储在堆（heap）中，静态变量也是。\n\n### 关于引用传递和值传递\n\n无论是引用传递还是值传递，永远不会传递对象本身。\n详见[Parameter passing in C#](http://jonskeet.uk/csharp/parameters.html)\n\n### 关于装箱和拆箱\n\n- 对于引用类型的变量，它的值永远是一个引用\n\n- 对于值类型的变量，它的值永远是该值类型的一个值\n\n  int i=5;\n  object o=i;\n  int j=(int) o;\n\n第二行，发生了装箱操作：运行时在堆上创建一个包含值（5）的对象，o的值是对该新对象的一个引用。该对象的值是原始值的一个副本，改变i不会改变箱内的值。\n\n第三行，执行相反操作，拆箱。必须告诉编译器将object拆箱成什么类型。\n\n装箱什么时候方式？<br>\n为一个类型的值调用ToString、Equals或GetHashCode方法时，如果该类型没有覆盖这些方法，也发生装箱。另外，将值作为接口表达式使用时也会发生装箱。\n\n太过频繁的装拆箱会增大程序的操作开销，还会创建数量众多的对象，加重垃圾回收器的负担。","tags":["C#"]},{"title":"深入理解C#（七）：委托","url":"/2019/01/09/深入理解C-（七）：委托/","content":"\n# 深入理解C#（七）\n\n*第二章（C# 1的核心基础）<br>\n**委托，类型系统的特征，值/引用类型**\n\n## 委托（delegate）\n\n1. 类似于C语言的函数指针\n2. 不指定一个要执行的行为，将这个行为用某种方式“包含在一个对象中”\n\n### 1. 委托的构成\n\n- 声明委托类型\n\n- 必须有一个方法包含了要执行的代码\n\n- 必须创建一个委托实例\n\n- 必须调用invoke委托实例\n  ​\t\n  namespace Chapter02\n  ​\t{\n  ​\t//声明委托类型\n  ​\tdelegate void StringProcessor(string input);\n  ​\t\n\n  ```\n  class Person\n  {\n  string name;\n  \n  public Person(string name)\n  {\n  this.name = name;\n  }\n  \n  //声明兼容的实例方法\n  public void Say(string message)\n  {\n  Console.WriteLine(\"{0} says: {1}\", name, message);\n  }\n  }\n  \n  class Background\n  {\n  //声明兼容发静态方法\n  public static void Note(string note)\n  {\n  Console.WriteLine(\"({0})\", note);\n  }\n  }\n  \n  [Description(\"Listing 2.1\")]\n  class SimpleDelegateUse\n  {\n  static void Main()\n  {\n  Person jon = new Person(\"Jon\");\n  Person tom = new Person(\"Tom\");\n  //创建三个委托实例\n  StringProcessor jonsVoice, tomsVoice, background;\n  jonsVoice = new StringProcessor(jon.Say);\n  tomsVoice = new StringProcessor(tom.Say);\n  background = new StringProcessor(Background.Note);\n  //调用委托实例\n  jonsVoice(\"Hello, son.\");\n  tomsVoice.Invoke(\"Hello, Daddy!\");\n  background(\"An airplane flies past.\");\n  }\n  }\n  \n  }\n  ```\n\n  具体步骤：<br>\n\n1. 声明一个委托类型。\n2. 找到或写一个方法，具有和委托类型相同的签名，并能做我们想做的事情。\n3. 创建委托实例，指定在调用委托实例时，执行该方法。（创建委托实例，取决于操作使用实例方法还是静态方法。具体做法就是new一个我们声明的委托类型，把任意匹配的方法，作为参数传入）\n4. 调用委托实例，可以显示用Invoke方法调用，也可用简化语句直接调用。\n\n类比：委托就像提前请律师打官司，声明委托类型就像指明要处理那种类型的案件，找到或写一个方法就像找到一个满足要求的律师，创建委托实例就像和律师签订协议，在需要时调用委托实例，就像遇上官司了，就要请律师出门解决。所以实际执行的方法是律师在做，委托只是提前签好协定，这样我们就可以在任何有需求的时候解决问题。\n\n### 合并和删除委托\n\n实际使用时，委托实例往往有一个操作列表（invocation list）与之关联。Combine负责将两个委托实例的调用列表连接到一起，Remove负责从一个委托实例中删除另一个实例的调用列表。一般使用+和+=操作符代替Combine。<br>\n注意： 委托和string一样是不易变的。Combine和String.Concat很像，合并现有实例来形成新的实例。<br>\n可用-和-=简写Remove操作<br>\n注意：若委托的签名有一个非void的返回类型，则Invoke的返回值是最后一个操作的返回值。除非使用GetInvocationList获取操作列表时，都显示调用某个委托，否则只能看到最后一个操作的返回值。<br>\n注意：如果调用列表中断任何操作爆出一个异常，都会组织执行后续操作。\n\n### 事件的简单讨论\n\n基本思想：让代码在发生某事时作出响应。<br>\n**注意：事件不是委托类型的字段，但C#允许使用字段风格的时间（field-like event）**<br>\n可以将事件看作类似属性的东西。两者都声明具有一种特定的类型，对于事件来说，是一个委托类型。(即：事件之于委托，就像属性之于字段）使用属性，实际是在调用方法。实现属性，可在方法中添加别的功能（校验机制之类）。同样订阅或取消订阅事件，实际是在调用（add和remove方法）<br>\n既然能用委托实现为什么还要事件？<br>\n和属性类似，事件添加了一个封装层，实现发布/订阅模式。[Delegates and Events](http://csharpindepth.com/Articles/Chapter2/Events.aspx)\n\n字段风格的事件，只需要一个声明。编译器将声明转换成一个具有默认add/remove实现的事件和一个私有委托类型的字段。表面上调用一个事件，实际调用存储在字段中的委托实例。","tags":["C#"]},{"title":"深入理解C#（六）：大致了解-异步代码","url":"/2019/01/09/深入理解C-（六）：大致了解-异步代码/","content":"\n# 深入理解C#（六）\n\n*第一章（大致了解C#各个版本的特性：异步代码）\n\n**C# 5特性：异步函数**\n可以用它来中断代码执行，而不阻塞线程。\n\nWindows Forms中有两条规范：<br>\n\n1. 不能阻塞UI线程\n\n2. 不能在任何其他线程中访问UI元素\n\n   private async void CheckProduct(object sender, EventArgs e)\n   ​     {\n   ​         try\n   ​         {\n   ​             // Only permit one lookup at a time\n   ​             productCheckButton.Enabled = false;\n   ​             statusLabel.Text = \"Checking...\";\n   ​             nameValue.Text = \"\";\n   ​             priceValue.Text = \"\";\n   ​             stockValue.Text = \"\";\n\n   ```\n            string id = idInput.Text;\n            Task<Product> productLookup = directory.LookupProductAsync(id);\n            Task<int> stockLookup = warehouse.LookupStockLevelAsync(id);\n   \n            Product product = await productLookup;\n            if (product == null)\n            {\n                statusLabel.Text = \"Product not found\";\n                // We don't care about the result of the stock check\n                return;\n            }\n            nameValue.Text = product.Name;\n            priceValue.Text = product.Price.ToString(\"c\");\n   \n            int stock = await stockLookup;\n            stockValue.Text = stock.ToString();\n            statusLabel.Text = \"Ready\";\n        }\n        finally\n        {\n            // However we finish this method, allow another lookup\n            productCheckButton.Enabled = true;\n        }\n    }\n   ```\n\n新的语法：**方法的async修饰符和两个await表达式**\n\n说明：现在产品目录和库存中查询产品详细信息和当前库存。等待（await）直到找到产品信息，如果目录中没有条目与给定ID对应，就退出。否则，将产品名称和价格显示在UI元素上，然后再等待获得库存信息并显示。","tags":["C#"]},{"title":"深入理解C#（五）：大致了解-COM和动态类型","url":"/2019/01/09/深入理解C-（五）：大致了解-COM和动态类型/","content":"\n# 深入理解C#（五）\n\n*第一章（大致了解C#各个版本的特性：COM和动态类型）\n\n**C# 4特性：互操作性**<br>\n包括：处理旧的COM技术和在DLR（Dynamic Language Runtime，动态语言运行时）上执行全新动态语言。\n\n## 简化COM互操作\n\n用COM控制让数据出现在Excel中\n例子：\n\n```\nvar app = new Application { Visible = false };\nWorkbook workbook = app.Workbooks.Add();\nWorksheet worksheet = app.ActiveSheet;\nint row = 1;\nforeach (var product in Product.GetSampleProducts()\n.Where(p => p.Price != null))\n{\nworksheet.Cells[row, 1].Value = product.Name;\nworksheet.Cells[row, 2].Value = product.Price;\nrow++;\n}\nworkbook.SaveAs(Filename: \"demo.xls\",\nFileFormat: XlFileFormat.xlWorkbookNormal);\napp.Application.Quit();\n```\n\n## 与动态语言互操作\n\n问题：产品能通过WEb服务访问，但只能用Python代码。Web服务使用了Python特性来构建结果，没有声明我们要访问的属性类型。但要我们指定类型，怎么办？\n\n使用新的类型dynamic<br>\n可以将dynamic类型隐式转换为其他类型\n\n例子：从IronPython中获取产品列表并打印出来。\n\n```\nScriptEngine engine = Python.CreateEngine();\nScriptScope scope = engine.ExecuteFile(@\"CSharp4\\FindProducts.py\");\ndynamic products = scope.GetVariable(\"products\");\nforeach (dynamic product in products)\n{\nConsole.WriteLine(\"{0}: {1}\", product.ProductName, product.Price);\n}\n```\n\nproducts和product为动态类型，编译器允许我们对产品列表迭代打印，但是它不确保是否能执行成功。如果有错误，只有执行时才会知道失败。","tags":["C#"]},{"title":"深入理解C#（四）：大致了解-LINQ简介","url":"/2019/01/09/深入理解C-（四）：大致了解-LINQ简介/","content":"\n# 深入理解C#（四）\n\n*第一章（大致了解C#各个版本的特性：LINQ简介）\n\n## LINQ简介\n\nLINQ（Language Integrated Query，语言集成查询）<br>用于简化查询\n\n### 查询表达式和进程内查询\n\n例子：\n查询所有供应商和对应产品，先连接产品和供应商，再按价格筛选，然后按先供应商名再产品名的优先级排序，最后打印每个供应商名称和产品名称\n\n```\nList<ProductWithSupplierID> products = ProductWithSupplierID.GetSampleProducts();\nList<Supplier> suppliers = Supplier.GetSampleSuppliers();\nvar filtered = from p in products\n               join s in suppliers on p.SupplierID equals s.SupplierID\n               where p.Price > 10\n               orderby s.Name, p.Name\n               select new\n               {\n                   SupplierName = s.Name,\n                   ProductName = p.Name\n               };\nforeach (var v in filtered)\n{\n    Console.WriteLine(\"Supplier={0}; Product={1}\",v.SupplierName, v.ProductName);\n}\n```\n\n**特性：隐式类型局部变量（implicitly typed local variable）**<br>\n使用var关键字说明，编译器根据变量的初始值推断其类型\n\n### LINQ to XML\n\n例子：\n\n```\nXDocument doc = XDocument.Load(\"data.xml\");\nvar filtered = from p in doc.Descendants(\"Product\")\n               join s in doc.Descendants(\"Supplier\")\n               on (int)p.Attribute(\"SupplierID\")\n                   equals (int)s.Attribute(\"SupplierID\")\n               where (decimal)p.Attribute(\"Price\") > 10\n               orderby (string)s.Attribute(\"Name\"),\n                       (string)p.Attribute(\"Name\")\n               select new\n               {\n                   SupplierName = (string)s.Attribute(\"Name\"),\n                   ProductName = (string)p.Attribute(\"Name\")\n               };\nforeach (var v in filtered)\n{\n    Console.WriteLine(\"Supplier={0}; Product={1}\",\n                      v.SupplierName, v.ProductName);\n}\n}\n```\n\n### LINQ to SQL\n\n例子：\n\n```\nusing (LinqDemoDataContext db = new LinqDemoDataContext())\n    {\n        var filtered = from p in db.Products\n                       join s in db.Suppliers\n                       on p.SupplierID equals s.SupplierID\n                       where p.Price > 10\n                       orderby s.Name, p.Name\n                       select new\n                       {\n                           SupplierName = s.Name,\n                           ProductName = p.Name\n                       };\n        foreach (var v in filtered)\n        {\n            Console.WriteLine(\"Supplier={0}; Product={1}\",\n                              v.SupplierName, v.ProductName);\n        }\n    }\n```\n\n虽然查询是用C#代码来表示的，但却是用SQL执行。\n实际发出一个数据库请求，被转化为SQL查询。","tags":["C#"]},{"title":"深入理解C#（三）：大致了解-处理未知数据","url":"/2019/01/09/深入理解C-（三）：大致了解-处理未知数据/","content":"\n# 深入理解C#（三）\n\n*第一章（大致了解C#各个版本的特性：处理未知数据）\n\n## 表示未知的值类型\n\n问题描述：decimal表示产品价格，是值类型，若某个产品价格未知，该如何表示？（若是引用类型，可用null表示）\n\n### C# 1解决方案：\n\n- 给decimal建一个引用类型包装器\n- 用一个单独的bool标志，表示价格是否已知\n- 使用一个魔数（magic value）来表示，如decimal.MinValue\n\n### C# 2:\n\nNullable<T>结构，提供一些语法糖来简化。\n例子：\n\n```\ndecimal? price;\npublic decimal? Price\n{\n\tget{return price;}\n\tprivate set{price=value;}\n}\n```\n\nPrice=null;\n**null现在表示“没有其他数据的任意可空类型的一个特殊值”**<br>\n所有引用类型和基于Nullable<T>的类型为可空类型<br>\n*与null值作比较，结果总是false*\n\n## 可选参数和默认值\n\n问题描述：对一个方法或构造函数，有时我们会自己设定参数，这时往往需要重构来减少参数量，并设置我们的默认值。有什么方法能简化？\n\n### C#4：\n\n可选参数和默认值：\n例子：\n\n```\npublic Product(string name,decimal? price=null)\n{\n\tthis.name=name;\n\tthis.price=price;\n}\n```\n\n这里对于可空类型的参数price，我们设定他为可选参数，默认值为null，这样我们就不需要重载这个构造函数，但我们依然能使用形如：`Product p=new Product(\"Unreleased product\");`这样的方式构造一个Product实例，因为price被设定有默认值null。","tags":["C#"]},{"title":"深入理解C#（二）：大致了解-排序和过滤","url":"/2019/01/09/深入理解C-（二）：大致了解-排序和过滤/","content":"\n# 深入理解C#（二）\n\n*第一章（大致了解C#各个版本的特性：排序和过滤）\n\n## 按字母顺序打印产品列表\n\n*按名称排序，找出最贵的产品*\n*这里只摘录C# 3的实现方法*\n\n### Lambda表达式使用Comparison<Product>进行排序\n\n```\nList<Product> products=Product.GetSampleProducts();\t\nproducts.Sort((x,y)=>x.Name.CompareTo(y));\nforeach(Product product in products)\n{\n\tConsole.WriteLine(product);\n}\t\n```\n\n### 使用一个扩展方法对List<Product>进行排序\n\n```\nList<Product> products=Product.GetSampleProducts();\nforeach(Product product in products.OrderBy(p=>p.Name))\n{\n\tConsole.WriteLine(product);\n}\n```\n\n## 查询集合\n\n### C# 1\n\n需要循环，测试每个元素，操作符合条件的元素（这里是打印元素）\n\n### C# 2\n\n测试和打印分开\n\n```\nList<Product> products=Product.GetSampleProducts();\n\nPredicate<Product> test=delegate(Product p) { return p.Price>10m;};\nList<Product> matches=products.FinaAll(test);\n\nAction<Product> print=Console.WriteLine;\nmatces.ForEach(print);\n```\n\n用FinaAll和ForEach分解问题\n另一个版本：\n\n```\nList<Product> products=Product.GetSampleProducts();\nproducts.FindAll(delegate(Product p){return p.Price>10;}}.\n\t\t.ForEach(Console.WriteLine);\n```\n\n### C# 3\n\n用Lambda表达式来测试\n\n```\nList<Product> products=Product.GetSampleProducts();\nforeach(Product product in products.Where(p=>p.Price>10))\n{\n\tConsole.WriteLine(product);\n}\n```\n\n## 小结\n\n1. C# 1，传统方法\n2. C# 2, 匿名方法：有助于问题的分离性（将测试和打印分开）\n3. C# 3， Lambda表达式：增强了可读性","tags":["C#"]},{"title":"深入理解C#（一）：大致了解-数据类型","url":"/2019/01/09/深入理解C-（一）：大致了解-数据类型/","content":"\n# 深入理解C#（一）\n\n*第一章（大致了解C#各个版本的特性：数据类型）\n\n## **产品/名称/价格**的例子\n\n### C# 1实现\n\n```\npublic class Product\n{\nstring name;\npublic string Name{ get { return name;} }\n\ndecimal price;\npublic decimal Price { get { return price; }}\n\npublic Product(string name,decimal price)\n{\n\tthis.name=name;\n\tthis.price = price;\n}\n\npublic static ArrayList GetSample()\n{\n\tArrayList list = new ArrayList();\n\tlist.Add(new Prodect(\"west side\",9.99m));\n\tlist.Add(new Prodect(\"Assassins\",14.99m));\n\treturn list;\n}\n\npublic override string ToString()\n{\n\treturn string.Format(\"{0}: {1}\",name,price);\n}\n```\n\n存在以下问题：<br>\n\n1. ArrayList 没有 提供 与其 内部 内容 有关 的 编译 时 信息。 不慎 在 GetSampleProducts 创建 的 列表 中 添加 一个 字符串 是 完全 有可能 的， 而 编译器 对此 没有 任何 反应。\n   (例如`list.Add(\"this is a string\");`编译器不能发现错误）\n2. 代码 中为 属性 提供 了 公共 的 取值 方法， 这 意味着 如果 添加 对应 的 赋值 方法， 那么 赋值 方法 也 必须 是 公共 的。\n3. 用于 创建 属性 和 变量 的 代码 很复杂—— 封装 一个 字符串 和 一个 十进制 数 应该 是一 个 十分 简单 的 任务， 不该 这么 复杂。\n\n### C# 2实现\n\n```\npublic class Product\n{\nstring name;\npublic string Name{\n\t get { return name;}\n\tprivate set { name=value;}\n```\n\n \t}\n​\t\n\n```\ndecimal price;\npublic decimal Price { get { return price; }}\n\npublic Product(string name,decimal price)\n{\n\tthis.name=name;\n\tthis.price = price;\n}\n\npublic static List GetSample()\n{\n\tList<Product> list = new List();\n\tlist.Add(new Prodect(\"west side\",9.99m));\n\tlist.Add(new Prodect(\"Assassins\",14.99m));\n\treturn list;\n}\n\npublic override string ToString()\n{\n\treturn string.Format(\"{0}: {1}\",name,price);\n}\n```\n\nC# 2提出泛型\nList<Product> list = new List();<br>\n且属性拥有私有赋值方法 private set { name=value;} <br>\n这样就解决了C# 1中前两个问题\n\n### C# 3实现\n\n特性1：自动实现的属性和简化的初始化\n\n```\npublic class Product\n{\npublic string Name{ get; private set;\n```\n\n \t}\n​\t\n\n```\npublic decimal Price { get; private set; }\n\npublic Product(string name,decimal price)\n{\n\tName=name;\n\tPrice = price;\n}\n\nProduct() {}\n\npublic static List GetSample()\n{\n\treturn new List{\n\tnew Prodect{ Name=”West Side\",Price=9.99m},\n\tnew Prodect{Name=\"Assassins\", Price=14.99m}\n\t};\n}\n\npublic override string ToString()\n{\n\treturn string.Format(\"{0}: {1}\",Name,Price);\n}\n```\n\n用属性代替变量，删除了所有与变量关联的代码，在类中处处使用属性，增强了一致性。<br>\n有一个私有的无参构造函数，用于基于属性的初始化。\n\n### C# 4实现\n\n为了移除易变形,使用只读属性<br>\n在调 用 构造 函数 时 指定 实 参 的 名称， \n**关于只读属性**\n\n1. readonly是一个用于以下三种上下文的修饰符：\n\n2. 在字段定义中：readonly表示这个字段的实例化只能发生在<1>变量声明时<2>在所属类的构造器中\n\n3. 在只读段落（readonly struct）中：为一个struct加上readonly表示这个struct是不变的（immutable）。\n\n4. 在方法返回ref readonly中，表示这个方法返回一个reference，这个ref不可写\n\n   using System.Collections.Generic;\n   ​\tpublic class Product\n   ​\t{\n   ​\treadonly string name;\n   ​\tpublic string Name{ get { return name;}\n    \t}\n\n   ```\n   readonly decimal price;\t\n   public decimal Price { get{return price;} }\n   \n   public Product(string name,decimal price)\n   {\n   \tthis.name=name;\n   \tthis.price = price;\n   }\n   \n   Product() {}\n   \n   public static List GetSample()\n   {\n   \treturn new List{\n   \tnew Prodect{ name:\"West Side\",price:9.99m},\n   \tnew Prodect{name:\"Assassins\", price:14.99m}\n   \t};\n   }\n   \n   public override string ToString()\n   {\n   \treturn string.Format(\"{0}: {1}\",name,price);\n   }\n   ```\n\n指定实参名称的好处是：在方法或构造函数包含多个参数时，使代码更清楚。另外可以不按顺序添加参数，而按照名称添加。这是C# 4为每个方法或构造函数自动添加的，直接使用。\n\n### 小结一下：<br>\n\n除了用到readonly的时候，大部分时候选用C# 3的属性自动实现的特性，隐藏变量，在方法中始终使用属性，保持一致性。对于拥有多个复杂参数的函数或构造函数，用命名实参来调用方法。","tags":["C#"]},{"title":"C#review补档","url":"/2019/01/08/C-review/","content":"\n# C#回顾\n\n## 与java明显不同\n\n1. WriteLine()\n2. 文件名可以不同于类的名称\n3. 动态（Dynamic）类型\n   您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。 声明动态类型的语法：`dynamic <variable_name> = value;`\n4. 指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。\n5. 常量是使用 const 关键字来定义的\n6. ? : 运算符\n   我们已经在前面的章节中讲解了 条件运算符 ? :，可以用来替代 if...else 语句。它的一般形式如下：`Exp1 ? Exp2 : Exp3;`\n7. for(;;) 结构来表示一个无限循环。\n8. return 语句可用于只从函数中返回一个值。但是，可以使用 输出参数 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。 关键字 out\n9. 在 C# 中，使用 ref 关键字声明引用参数。\n10. 数组：`double[] balance = new double[10];`\n11. foreach (int j in n )\n12. C# 参数数组:params 关键字 当声明一个方法时，您不能确定要传递给函数作为参数的参数数目\n    在使用数组作为形参时，C# 提供了 params 关键字，使调用数组为形参的方法时，既可以传递数组实参，也可以只传递一组数组。params 的使用格式为：`public 返回类型 方法名称( params 类型名称[] 数组名称 )`\n13. C# 中的析构函数\n    类的 析构函数 是类的一个特殊的成员函数，当类的对象超出范围时执行。\n    析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。\n    析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。\n\n## 注意点\n\n1. C# string 字符串的前面可以加 @（称作\"逐字字符串\"）将转义字符（\\）当作普通字符对待，比如：`string str = @\"C:\\Windows\";`等价于：`string str = \"C:\\\\Windows\";`\n2. Console.ReadLine() 只接受字符串格式的数据。\n3. 可空类型：在处理数据库和其他包含可能未赋值的元素的数据类型时，将 null 赋值给数值类型或布尔型的功能特别有用：`< data_type> ? <variable_name> = null;`\n4. 我们可以使用 static 关键字把类成员定义为静态的。当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本。\n   关键字 static 意味着类中只有一个该成员的实例。\n5. 您也可以把一个成员函数声明为 static。这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在。\n6. 抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。\n\n## 待详细看\n\n1. [namespace命名空间](https://www.w3cschool.cn/csharp/csharp-namespace.html):using System;命名空间的设计目的是为了提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。\n2. [可空类型](https://www.w3cschool.cn/csharp/csharp-nullable.html)\n3. [多维数组和交错数组](https://www.w3cschool.cn/csharp/csharp-multi-dimensional-arrays.html):C# 支持多维数组。多维数组又称为矩形数组。交错数组是数组的数组。\n4. [Array 类](https://www.w3cschool.cn/csharp/csharp-array-class.html)是 C# 中所有数组的基类，它是在 System 命名空间中定义。Array 类提供了各种用于数组的属性和方法。*直接调用array中的方法能实现数组的逆转和排序等*\n5. [结构](https://www.w3cschool.cn/csharp/csharp-struct.html)在 C# 中，结构是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。struct 关键字用于创建结构。\n6. [动态多态性](https://www.w3cschool.cn/csharp/csharp-polymorphism.html)\n\n## 委托（delegate)\n\nC# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。\n\n委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 System.Delegate 类。","tags":["C#"]},{"title":"2018-7-26-JavaEE-WEB-2","url":"/2018/07/26/2018-7-26-JavaEE-WEB-2/","content":"\n# JAVA EE WEB学习（二）\n\n**创建第一个Servlet**\n\n## Servlet作用\n\n1. 直接处理和响应用户请求\n2. 将处理工作委托给应用中其他部分的类\n3. WEB容器会有一个或多个Servlet，用于处理JSP、显示目录列表、访问静态资源\n\n## 继承的servlet类\n\n1. 继承HttpServlet\n2. 接收HttpServletRequest和HttpServletResponse参数\n\n## 简单例子\n\n```\npackage servlet;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class Demo3 extends HttpServlet {\n\tprivate static final String DEFAULT_USER=\"Guest\";\n\t/**\n\t * Constructor of the object.\n\t */\n\tpublic Demo3() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Destruction of the servlet. <br>\n\t */\n\tpublic void destroy() {\n\t\tsuper.destroy(); // Just puts \"destroy\" string in log\n\t\t// Put your code here\n\t\tSystem.out.println(this.getServletInfo());\n\t\tSystem.out.println(\"fin\");\n\n\t}\n\n\t/**\n\t * The doGet method of the servlet. <br>\n\t *\n\t * This method is called when a form has its tag value method equals to get.\n\t * \n\t * @param request the request send by the client to the server\n\t * @param response the response send by the server to the client\n\t * @throws ServletException if an error occurred\n\t * @throws IOException if an error occurred\n\t */\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tString user =request.getParameter(\"user\");\n\t\tif(user==null)\n\t\t{\n\t\t\tuser=Demo3.DEFAULT_USER;\n\t\t}\n\t\tresponse.setContentType(\"text/html\");\n\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\t\t\n\t\tPrintWriter out = response.getWriter();\n\t\tout.append(\"<!DOCTYPE HTML>\\r\\n\")\n\t\t   .append(\"<HTML>\\r\\n\")\n\t\t   .append(\"  <HEAD>\\r\\n\")\n\t\t   .append(\"    <TITLE>A Servlet</TITLE>\\r\\n\")\n\t\t   .append(\"  </HEAD>\\r\\n\")\n\t\t   .append(\"  <BODY>\\r\\n\")\n\t\t   .append(\"     Hello, \").append(user).append(\"!<br/><br/>\\r\\n\")\n\t\t   .append(\"     <form action=\\\"demo3\\\" method=\\\"POST\\\">\\r\\n\")\n\t\t   .append(\"       Enter your name:<br/>\\r\\n\")\n\t\t   .append(\"       <input type=\\\"text\\\" name=\\\"user\\\"/><br/>\\r\\n\")\n\t\t   .append(\"       <input type=\\\"submit\\\" value=\\\"Submit\\\"/>\\r\\n\")\n\t\t   .append(\"       </form>\\r\\n\")\n\t\t   .append(\"  </BODY>\\r\\n\")\n\t\t   .append(\"</HTML>\\r\\n\");\n\n\n\t}\n\n\t/**\n\t * The doPost method of the servlet. <br>\n\t *\n\t * This method is called when a form has its tag value method equals to post.\n\t * \n\t * @param request the request send by the client to the server\n\t * @param response the response send by the server to the client\n\t * @throws ServletException if an error occurred\n\t * @throws IOException if an error occurred\n\t */\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tthis.doGet(request, response);\n\t}\n\n\t/**\n\t * Initialization of the servlet. <br>\n\t *\n\t * @throws ServletException if an error occurs\n\t */\n\tpublic void init() throws ServletException {\n\t\t// Put your code here\n\t\tSystem.out.println(\"start\");\n\t\tSystem.out.println(this.getServletName());\n\t}\n\n}\n\n```\n\n**注意点**\n\n1. init方法在构造完成之后，响应第一个请求之前调用\n2. 调用init方法时，Servlet中所有属性都已设置完，提供了对ServletConfig和SercletContext对象的访问。\n3. 可以使用init方法读取属性文件或使用JDBC连接数据库\n4. destory方法在Servlet不再接受请求之后立即调用，即web应用程序被停止或卸载，或Web容器关闭时。因此：**应该使用destory方法清理servlet持有的资源**\n\n## 配置可部署的Servlet\n\n1. 在web.xml中部署，一般IDE会在创建时自动部署。\n2. \n\n```\n<servlet>\n\t.....\n\t.....\n\t<load-on-startup>x</load-on-startup>\n</servlet>\n```\n\nServlet按照x大小顺序启动，越小优先级越高。\n\n1. 将Servlet映射到URL\n   `<servlet-name>`对应`<url-pattern>`一个servlet可以映射到多个url\n\n## 了解doGet、doPost和其他方法\n\n### HttpServletRequest\n\n1. 功能：从客户端发送的请求中获取参数。参数有两种形式：查询参数和请求正文（post请求）。查询参数在HTTP请求的第一行数据中如`GET /index.jsp?id=412&category=Books HTTP/1.1`中有两个查询参数:id和category  或  作为post变量保存在请求正文中\n2. **获取请求参数：**方法getParameter返回参数单个值，或多个参数第一个值；getParameterValues返回参数值的数组；getParameterMap返回包含所有参数名值对；getparameterNames返回所有可用参数的名字的枚举。后两种方法一般用于遍历所有请求参数。\n3. **确定与请求内容相关的信息：**getContentType返回请求的内容类型；getContentLength返回请求正文长度。\n4. **读取请求的内容：**getInputStream读二进制格式；BufferedReader读基于字符编码。**不要在同一请求上同时使用这两种方法；不要在含post变量的请求上使用这些方法**\n5. **获取请求特有的数据**getRequestURL：返回完整URL；getRequestURI：返回服务器路径；getServletPath：只返回Servlet映射的URL;\n\n### HttpServletResponse\n\n1. 功能：提供了对响应中与HTTP协议相关属性的访问。可用于：设置响应头、编写相应正文、重定向请求、设置HTTP状态码等\n2. **编写响应正文：**将内容输出到响应正文中。getOutputStream和getWritter都可以向响应中输出数据。**不要对同一响应对象同时使用这两种方法。**\n3. **设置内容类型或编码格式：**使用setContentType和setCharacterEncoding方法。必须放在getWritter方法之前，否则返回到writer使用容器默认编码。\n4. **设置头和其他响应属性：**暂略\n\n## 使用初始化参数配置应用程序\n\n### 使用上下文初始化参数\n\n1. 在web.xml文件中用`<context-param>`标签声明上下文初始化参数 *在`<servlet>`外部*\n2. 在Servlet代码中获得和使用这些参数：先获得servletcontext（getServletContext），用这个实例的getInitParameter方法，参数为param-name可得到param-value。\n\n### 使用servlet初始化参数\n\n1. 将`<init-param>`添加到*`<servlet>`内部*\n2. 在Servlet代码中获得和使用这些参数：先获得ServletConfig（getServletConfig），用这个实例的getInitParameter方法，参数为param-name可得到param-value。\n3. **通常用这种方式改变数据库服务器的IP地址**\n\n## 通过表单上传文件","tags":["JavaEE"]},{"title":"2018-7-25-JavaEE-WEB-1","url":"/2018/07/25/2018-7-25-JavaEE-WEB-1/","content":"\n\n\n# JAVA EE WEB学习（一）\n\n**基本结构**\n\n## Servlet等\n\n1. servlet：接收响应HTTP请求\n2. 过滤器：拦截发送给servlet的请求，用于：数据格式化，对返回的数据压缩、认证和授权\n3. 监听器：通知代码多种事件，如：程序启动、关闭，HTTP会话创建和销毁\n4. JavaServer Pages/JSP：创建图形用户界面\n\n## 目录结构和归档文件WAR\n\n1. Java归档文件：JAR  Java EE WEB归档文件：WAR\n2. ![目录结构](/img/post/目录结构.png)\n3. ![目录结构2](/img/post/目录结构2.png))\n\n## 部署描述符\n\n1. 用于描述Web应用程序的元数据，为服务器部署和运行Web应用程序提供指令。\n2. 来自于/WEB-INF/web.xml\n3. 包含Servlet、监听器和过滤器的定义+HTTP会话、JSP和应用程序的配置选项。\n4. *可用注解配置Web应用程序*\n\n## 类加载器架构（ClassLoader)\n\n1. Java SE 平台中，java.*类加载到根类加载器->JRE中的扩展JAR加载到扩展类加载器->其他所有类加载到Class Loader\n2. 双亲优先类加载委托模式：低级别加载器申请加载一个类时，将委托不断向上传递至根加载器，确认成功。未能找到，则从自己的JAR文件和目录中尝试加载。\n3. Java EE WEb中，使用子女优先类加载委托模式：公共的服务器类加载器给每个WEB应用程序分配一个自由的相互隔离的类加载器。在自己无法加载某个类时，请求它的父类加载器帮助加载。\n\n","tags":["JavaEE"]},{"title":"Java POI开发小结","url":"/2018/07/02/2018-07-02-Apache-POI/","content":"\n# 关于POI以及一些想法\n\nApache POI是Apache软件基金会提供的100％开源库。大多数中小规模的应用程序开发主要依赖于Apache POI（HSSF+ XSSF）。它支持Excel 库的所有基本功能; 然而，呈现和文本提取是它的主要特点。 [官网链接](http://poi.apache.org/guidelines.html)\n\nJava Excelapi有很多，除了Apahce POI，网上教程较多的Jexcel等。虽然没有使用过其他java excelapi，就本人使用Apahce POI开发感受和其他人的提醒，能用VB操作excel就尽量不要用java了。\n\nApache   POI提供的基本功能，简单的读写ｅｘｃｅｌ文档没有问题，但是没有实现复制单元格(cell)，复制电子表格(Sheet)等功能（也有可能提供了但我没找到，毕竟没有很详细地完整看完官方Guide）。学习基本功能和了解POI实现机制，可以看上面官网链接或[易百中文教程](https://www.yiibai.com/apache_poi/apache_poi_core_classes.html)。\n\n我在下面会列出一些我在开发时自己编写的ＰＯＩ工具类中一些常用函数，具体代码可以在我的GitHub [ApachePOI](https://github.com/xiaot1996/ApachePOI)项目中找到。\n\n#  代码实现\n\n ## 获取有效行数\n\n```java\n/********************************************************\n\t * function : count the number of valid rows in a given sheet \n\t * *******************************************************\n\t * parameters:\n\t * wb : workbook which contains the sheet we want\n\t * indexSheet : the index of the sheet in the xb (start from 0)\n\t *************************************************************** */\n\tpublic static int getSheetRowNumber(XSSFWorkbook wb,int indexSheet)\n\t{\n\t\tXSSFSheet sheet=wb.getSheetAt(indexSheet);\n\t\tint count=0;\n\t\tint begin = sheet.getFirstRowNum();  \n\t\t  \n\t    int end = sheet.getLastRowNum();  \n\t  \n\t    for (int i = begin; i <= end; i++) {  \n\t        if (null == sheet.getRow(i)|| getCellValue(sheet.getRow(i).getCell(0)) == \"\" || null==sheet.getRow(i).getCell(0)) {  \n\t            continue;  \n\t        }  \n\t        else count++;\n\t    }\n\t    \n\t    return count;\n\t}\n```\n\n## 列编号(ABC...)与数字(123...)的转换\n\n```java\n/**********************************************************\n     * Excel column index begin 1\n     * @param colStr\n     * @param length\n     * @return\n     **********************************************************/\n    public static int excelColStrToNum(String colStr, int length) {\n        int num = 0;\n        int result = 0;\n        for(int i = 0; i < length; i++) {\n            char ch = colStr.charAt(length - i - 1);\n            num = (int)(ch - 'A' + 1) ;\n            num *= Math.pow(26, i);\n            result += num;\n        }\n        return result;\n    }\n\n    /**\n     * Excel column index begin 1\n     * @param columnIndex\n     * @return\n     */\n    public static String excelColIndexToStr(int columnIndex) {\n        if (columnIndex <= 0) {\n            return null;\n        }\n        String columnStr = \"\";\n        columnIndex--;\n        do {\n            if (columnStr.length() > 0) {\n                columnIndex--;\n            }\n            columnStr = ((char) (columnIndex % 26 + (int) 'A')) + columnStr;\n            columnIndex = (int) ((columnIndex - columnIndex % 26) / 26);\n        } while (columnIndex > 0);\n        return columnStr;\n    }\n```\n\n## 在不同工作簿(workbook)间，复制一个区域的单元格并保留格式，设置行宽\n\n```\n/********************************************************\n\t * function : copy a part of cells in different workbooks\n\t * *******************************************************\n\t * @param:\n\t * xbIn : the resource workbook\n\t * xbOut : the destination workbook\n\t * indexSheetIn : the index of the sheet in the xbIn (start from 0)\n\t * indexSheetOut : the index of the sheet in the xbOut (start from 0)\n\t * rowInStart : the number of the first row that we need in the indexSheetIn ( start from 1 )\n\t * rowInEnd : the number of the last row that we need in the indexSheetIn ( start from 1 )\n\t * colInStart : the number of the first column that we need in the indexSheetIn ( start from 1, represent A in the sheet )\n\t * colInEnd : the number of the last column that we need in the indexSheetIn ( start from 1, represent A in the sheet )\n\t * rowOutStart : the number of the first row that we want to put cells in the indexSheetOut ( start from 1 )\n\t * colOutStart : the number of the first column that we want to put cells in the indexSheetOut ( start from 1, represent A in the sheet )\n\t * *******************************************************/\n\tpublic static boolean copyCells(XSSFWorkbook wbIn,XSSFWorkbook wbOut,int indexSheetIn,int indexSheetOut, \n\t\t\tint rowInStart,int colInStart,int rowInEnd,int colINEnd,int rowOutStart,int colOutStart )\n\t{\n\t\tXSSFSheet sheetIn=wbIn.getSheetAt(indexSheetIn);\n\t\tXSSFRow rowIn;\n\t\tXSSFCell cellIn;\n\t\tXSSFCellStyle cellStyleIn;\n\t\tString cellInValue;\n\t\t\n\t\t\n\t\tXSSFSheet sheetOut=wbOut.getSheetAt(indexSheetOut);\n\t\tXSSFRow rowOut;\n\t\tXSSFCell cellOut;\n\t\tXSSFCellStyle cellStyleOut;\n\t\t\n\t\tint rowNum=rowInEnd-rowInStart;\n\t\tint colNum=colINEnd-colInStart;\n\t\tfor(int i=0;i<rowNum+1;i++)\n\t    {  \t    \t\n\t    \t\n\t    \trowIn=sheetIn.getRow(rowInStart+i-1); \t\t    \t\t\n\t    \trowOut = sheetOut.createRow(rowOutStart+i-1);\n\t\t\t//set the copied row's height\n\t    \trowOut.setHeight(rowIn.getHeight());\n\t    \tfor(int j=0;j<colNum+1;j++) {\n\t    \t\tcellIn=rowIn.getCell(colInStart+j-1);\n\t    \t\tif(cellIn!=null) {\n\t    \t\tcellInValue=getCellValue(cellIn);\n\t    \t    cellOut=rowOut.createCell(colOutStart+j-1);\n\t    \t    cellStyleIn=cellIn.getCellStyle();\n\t    \t    cellStyleOut=wbOut.createCellStyle();\n\t    \t    cellStyleOut.cloneStyleFrom(cellStyleIn);\n\t    \t    cellOut.setCellStyle(cellStyleOut);\n\t    \t    cellOut.setCellValue(cellInValue);\n\t    \t\t}\n\t    \t}\t\n\t    }\n\t\t\n\t\t//in order to deal with merged regions\n\t\tjava.util.List<CellRangeAddress> regions=sheetIn.getMergedRegions();\n\t\t\n\t\tfor(CellRangeAddress cellRangeAddress : regions)\n\t\t{\n\t\t\tif(cellRangeAddress.getFirstColumn()>=colInStart-1&&\n\t\t\t\t\tcellRangeAddress.getLastColumn()<=colINEnd-1&&\n\t\t\t\t\tcellRangeAddress.getFirstRow()>=rowInStart-1&&\n\t\t\t\t\tcellRangeAddress.getLastRow()<=rowInEnd-1)\n\t\t\t{\n\t\t\t\tint diffrow=rowOutStart-rowInStart;\n\t\t\t\tint diffcol=colOutStart-colInStart;\n\t\t\tint firstRow=cellRangeAddress.getFirstRow()+diffrow;\n\t\t\tint firstCol=cellRangeAddress.getFirstColumn()+diffcol;\n\t\t\tint lastRow=firstRow+cellRangeAddress.getLastRow()-cellRangeAddress.getFirstRow();\n\t\t\tint lastCol=firstCol+cellRangeAddress.getLastColumn()-cellRangeAddress.getFirstColumn();\n\t\t\tCellRangeAddress cellRangeAddressNew=new CellRangeAddress(firstRow, lastRow, firstCol, lastCol);\n\n\t\t\tsheetOut.addMergedRegion(cellRangeAddressNew);\n\t\t\t}\n\t\t}\n\t\t//set the copied column's width\n\t\tfor(int columnIndex=colInStart-1;columnIndex<=colINEnd-1;columnIndex++) {\n\t\t\tint width=sheetIn.getColumnWidth(columnIndex);\n\t\t\tsheetOut.setColumnWidth(columnIndex, width);\n\t\t}\n\t\t\n\t    return true;\n\t}\n```\n\n## 需要注意的\n\n- 在linux环境下，使用LibreOffice Calc，虽然在给每个电子表格(sheet)命名时，无论代码中还是软件中，名称可以包含空格或特殊字符，但用apahce poi获取sheet名时，只会读到空格或特殊符号之前的部分。我的解决方法是在创建每个sheet时统一用横杠(-)代替空格和特殊字符。\n- 对于合并单元格(merged region)，好的做法是在**同一个函数**中先把该表中**所有**要合并的单元格存到cellRangeAddress列表中，再进行复制之类的操作，避免在多个函数反复添加合并单元格。\n- 自动设置列宽方法autoSizeColumn，对于合并单元格不能很好适用，建议还是自己设置。\n- 在设置格式时，LibreOffice Calc中形如`=$表名.单元格编号`。但在java POI中形式为`cell.setcellformula(表名!单元格编号)`","tags":["Java","Apache POI"]},{"title":"WEB学习-HTML和CSS入门","url":"/2018/02/20/2018-02-20-WEB-learning/","content":"\n* 目录\n{:toc}\n\n# WEB项目文件结构\n![文件结构](/img/post/WEB-structure.png)\n\n# 常用网页框架设计\n- 1个100%页面宽度的行类(.row)\n- 占页面1/12-12/12的列类(.col-n)*n为1-12的数字*\n*CSS类前有.*\n\n# flex\n- 为了让行中列元素并排显示，需要给row加上`display:flex`\n- 关于flex，查看[flex](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex),[flexbox](https://segmentfault.com/a/1190000007550042),[flex-wrap](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-wrap)\n\n# 负空间（space）\n- margin 外边距\n- padding 内边距\n- 加上后缀`-top -right -left -bottom`具体设置\n*border 边框*\n\n# 溢出\n- `overflow:auto;`\n\n# 响应\n例子：\n`@media only screen and (max-width:500px) and (orientation:landscape)`\n- `@media`实现页面响应\n- `only‘`用于兼容旧式浏览器\n- `screen`指示这个响应用于所有显示设备\n*print用于响应当用户要打印页面时*\n- `and`加上条件\n- `orientation`指的是手机方向：landscape mode横向，portrait mode纵向\n\n# 浏览器兼容\n在head中添加normalize.css样式表，该表格google搜索下载\n\n# 占位图片\n- `<img src=\"http://placehold.it/nxn\"`\n- `<img src=\"http://placekitten.com/n/n\"`\n\n# 字体\n1. 在[Google Fonts](https://fonts.google.com/)中找到字体\n2. 在html的head中加入链接`<link href=\"https://fonts.googleapis.com/css?family=Roboto\" rel=\"stylesheet\">`\n3. 在css中为需要使用该字体的元素添加`font-family: 'Roboto', sans-serif;`\n\n\n","tags":["WEB入门"]},{"title":"WEB学习-Bootstrap框架学习","url":"/2018/02/20/2018-02-21-WEB-Bootstrap-learning/","content":"\n[TOC]\n\n# Grid system(网格系统)\n\n- 每一行rows应放在.container(fixed-width)或.container-fluid(full-width)中\n- 使用rows来创建水平列组(groupes of columns)\n- 内容放在column中，column是rows的子类\n\n# Chrome开发者工具\nctrl+shift+i\n\n# 应用框架\n要将 bootstrap CSS 应用于 bootstrap-prestructure.html 文件，需要：将 bootstrap-prestructure.html 文件移至你的 bootstrap 目录。打开 HTML 文件，在母体元素下方的 head 元素中添加一条指向 bootstrap CSS 文件的链接：\n`<link rel=\"stylesheet\" href=\"css/bootstrap.min.css\">`\n\n# 保存修改\n要将你在开发者工具中对 HTML 所做的更改保存至你的 HTML 文件，只需右键单击或 ctrl + 单击 <html> 元素，然后选择“复制为 HTML”，然后用复制的文本替换你文件中的 HTML。\n\n# 响应式页面\n响应式图片加上`class=\"img-responsive\" alt=\"Responsive image\"`\n\n# Bootstrap排版\n文字对齐加上`class=\"text-left\"`表示左对齐\n文字装换加上`class=\"text-uppercase\"`将文字变为大写\n*可添加在文字类型如h1，h3，最好是直接添加在包含他们的div上*\n\n# 自定义CSS\n在/css文件夹下添加style.css文件\n从大到小对网页中的元素添加定制","tags":["WEB入门","Bootstrap"]},{"title":"Git 学习","url":"/2018/02/06/2018-02-06-Git-learning/","content":"\n* 目录\n{:toc}\n\n# 基础\n*以在GitLab上创建一个project为例*\n\n## 1. SSH秘钥\n生成SSH秘钥指令：\n`$ ssh-keygen -t rsa -C \"votre.email@telecom-sudparis.eu\" -b 4096`\n保存在`$HOME/.ssh/id_rsa.pub`\n将获得的SSH秘钥填入GitLab网站\n**SSH秘钥用于GitLab网站识别Unix账号**\n\n## 2. 创建project并添加合作者\n命名规则：课程+年份+创作者\n*给合作者Master权限*\n\n## 3. 克隆project到本地\n`git clone git@gitlab.tem-tsp:votreprenom.votrenom/votrenomdeproject.git`\n\n## 4. 查看git状态\n`git status`\n\n## 5. 创建第一个文件README.md并提交\n1. `git add README.md`\n2. `git commit -m \"注释\"`\n3. `git push origin master`\n4. 其他合作者`git pull origin`\n\n- git add：\ni） `git add .` 或 `git add --all` 提交所有修改\n\n- git commit：\ni） `git commit`后会生产一个hash码，用于标记此次commit操作\n\n- git push：\ni） `git push`默认将master上传\nii）origin是远程仓库名，master是分支名\n\n- git pull：\ni）当有其他人想master分支推送了更新，则服务器上的master向前推进，本地的Master落后服务器版本，需要运行 `git fetch`来同步本地并用`git merge`合并，或直接用`git pull`。`git pull`=`git fetch` + `git merge`\n\n---\n\n# 分支操作\n*branch*\n\n## 1. 创建分支\n`git checkout -b module1`\n\ni） 创建并转到module1分支\nii）`git checkout 分支名` 转到已存在的分支\n\n## 2. 查看分支\n`git branch`\n\ni）一般而言，Master分支是默认创建的。\n**但若是在项目一开始，即项目为空时，创建分支，会丢失master分支。**\n\n## 3. 在分支上进行操作\n- 与在[基础部分](# 例子1-基础)操作相同\n- 在每个分支上做的add,commit操作是独立的\n\n## 4. 查看日志\n- `git log --graph --oneline --decorate`\n- 使用工具gitg/gitk\n\n## 5. 合并（Fusion）分支\n1. 转到Master`git checkout master`\n2. `git merge --no-ff moudle1 -m \"Merge branch 'modele1'\"`\n\ni)  有`--no-ff`则moudle1会保留，没有则不保留module1分支\n\n---\n\n# 冲突conflict\n\n## 设置冲突管理工具\n`git config merge.tool meld`\n\n## 冲突前提\n分支module1和Master中有同一个文件，且分别在不同分支修改了文件，并做了`add commit`操作。做第二次`commit`时冲突发送。\n\n解决方法：\n用`git mergetool`调用meld，查看修改冲突的地方，修改保存后会生成很多不必要的文件\n用`rm 文件名.文件类型.* 文件名_* *~`删除这些文件。\n\n---\n\n# Git-flow\n\n## Git-flow原则\n1. 两条长期分支\n**master**只保留官方的，实用的代码版本\n**develop**在这个分支进行开发，只有想正式对外发布且经过确认，才会和Master合并。\n- 新建develop分支：`git checkout -b develop master`\n- 将develop分支发布到Master分支：`git checkout Master`\n                             ​    `git merge --no-ff develop `\n2. 创建release(预发布)分支\n当要进行develop分支和Master合并时，先从develop分支上创建一个release分支，加上标签（tag)用于标记新的版本。\n*建议创建一个release分支，这个分支里commit只用于修改bugs。*\n\n3. 在develop的子分支（feature分支）上编码\n只有子分支状态满足，develop上的合并操作才会执行\n\n4. hotfix\n当master上发现bug，就在master上引出一个hotfix分支。\n这个分支有两个作用：\n1. 为Master提供一个新版本\n2. 为develop修复整个project的bug\n\n*注意：*release,feature和hotfix分支都是临时分支，使用完后，应该删除，使代码库的常设分支始终只有Master和Deve。\n\n![Git-flow图](/img/git/git-model.png)\n\n\n## Git-flow例子\n1. 在本地建立工作文件夹，初始化库\n\n```\nmkdir exercice-git-flow  \ncd exercice-git-flow  \ngit init  \ntouch README.md  \ngit add README.md  \ngit commit -m \"commit initial\"\n```\n\n2. 新建develop分支\n`git checkout -b develop`\n\n3. 新建feature分支，以功能名命名\n`git checkout -b navire1`\n\n4. 在这个分支中写一个文本文档\n\n```\ngedit navire.txt  \ngit add navire.txt  \ngit commit -m \"navire version 1`\n```\n\n5. 修改和二次提交\n为navire.txt中加入新的几行\n\n```\ngedit navire.txt  \ngit add navire.txt  \ngit commit -m \"navire version 2\"\n```\n\n现在我们已经实现了一定功能，合并这个分支和develop\n\n```\ngit checkout develop  \ngit merge --no-ff navire1 -m \"Merge branch 'navire1' into develop\"\n```\n\n6. 假设经过多次3-5，我们已经实现了很多功能，想把develop和master合并\n\n```\ngit checkout master  \ngit merge --no-ff develop -m \"commit release 1.0\"\n```\n\n因为这是一个正式版本，我们加上标签tag\n`git tag -a v1.0 -m \"release 1.0\"`\n\n# 版本控制\n=有待完成=\n","tags":["Git"]},{"title":"Vim学习（一）","url":"/2018/02/05/2018-02-05-Vim-learning-1/","content":"\n* 目录\n{:toc}\n\n# vim学习\n\n## Part 1\n```markdown\n- i → Insert 模式，按 ESC 回到 ormal 模式.\n- x → 删当前光标所在的一个字符。\n- :wq → 存盘 + 退出 (:w 存盘, :q 退出)   （注：:w 后可以跟文件名）\n- dd → 删除当前行，并把删除的行存到剪贴板里\n- p → 粘贴剪贴板\n```\n\n---\n\n## Part 2\n1. 插入模式\n\t- a → 在光标后插入\n\t- o → 在当前行后插入一个新行\n\t- O → 在当前行前插入一个新行\n\t- cw → 替换从光标所在位置后到一个单词结尾的字符\n2. 简单的移动光标\n\t- 0 → 数字零，到行头\n\t- ^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）\n\t- $ → 到本行行尾\n\t- g_ → 到本行最后一个不是blank字符的位置。\n\t- /pattern → 搜索 pattern 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个）\n3. 拷贝/粘贴 \n\t- P → 粘贴;p是表示在当前位置之后，P表示在当前位置之前\n\t- yy → 拷贝当前行当行于 ddP;y -> 拷贝\n4. Undo/Redo\n\t- u → undo\n\t- C-r → redo\n5. 打开/保存/退出/改变文件(Buffer)\n\t- :e <path/to/file> → 打开一个文件\n    - :w → 存盘\n    - :saveas <path/to/file> → 另存为 <path/to/file>\n    - :x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车)\n    - :q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。\n    - :bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。\n\n---\n\n## Part 3\n1. vim的重复\n\t- . 小数点，重复上一条命令\n\t- N加命令，重复N次\n2. 光标移动\n    - 数字加G，到第N行\n    - gg，到第一行\n    - G，到最后一行\n    - w，到下个词开k移动到与当前光标相匹配的词（×是下一个，#是上一个） \n3. 组合命令（开始位置+命令+结束位置）\n    - 0y$; 拷贝本行，+p粘贴\n    - 能与光标移动联动的还有\n\t\t- d，删除\n\t\t- v，可视化选择\n\t\t- gU，变大写\n\t\t- gu，变小写\n\t\t- 其他\n\n---\n\n## Part 4\n1. 当前行上移动光标\n\t- 0，到行头\n    - ^，到本行的第一个非blank字符\n    - $，到行尾\n    - f字符，到下一个字符处\n    - t字符，到符号前的第一个字符\n    - 3fa，到本行第三次出现的a处\n    - F和T，与f和t相似，方向相反 \n    - dt符号，删除符号前的所有内容\n2. 可视化选择v,V\n    - J，把所有行连在一起\n    - <和>,左右缩进\n    - =，自动缩进\n    - 选中行后，$到最后，a插入字符，Esc为每行添加字符\n3. 分屏\n    - ：split，创建分屏 \n    - ctrl-w，切屏\n","tags":["vim"]},{"title":"Markdown 学习","url":"/2018/01/27/2018-01-27-Markdown-learning/","content":"* 目录\n{:toc}\n\n# Markdown 学习\n[一个好的Markdown学习网站](http://xianbai.me/learn-md/index.html)\n\n## 注释comment\n\\<!-- 注释 -->\n\n---\n\n## 标题Header\n\\# 加空格实现\n\n---\n\n## 句段Sentence/Paragraph\n1. 换行 \n- 行末加两个空格 \n- \\<br>\n\n---\n\n## 符号Punctuation Charcaters\n- \\*倾斜* \n- \\-或+ 列表\n- \\>引用\n1. 字符实体\n    tab 预格式化 \n\n---\n\n## 分隔符Horizontal Rules\n\\--- 三个减号或星号或下划线需隔开上一行 \n\n---\n\n## 文本格式Text Styling\n- 星号（\\*）或下划线（\\_）包围的文字将会显示斜体 ex: *倾斜*\n- 两个星号（\\**）或下划线（\\__）包围的需要特别强调的文字将会加粗 ex: **加粗**\n- 两个等号（equalsigns：\\=）包围来突出高亮显示。ex: ==高亮==\n- 使用两个加号（plus sign：\\+）来标记下划线。\nex：++下划线++\n- 两个波浪符号（two wavy line:\\~~）包围来给文本添加删除线。ex: ~~删除线~~\n\n---\n\n## 脚标 Script\n标准 Markdown 不支持脚标，只能通过内嵌 HTML 的\\<sup\\>和\\<sub\\>标签来实现。\n* 脚标两边加上\\< > ex: 2^10^ \n* 脚标两边加上\\~ ~ ex: H~2~o\n\n---\n\n## 链接Hyperlink\n1. 文字\n- Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要用尖括号包起来的文字， Markdown 就会自动把它转化成链接。如果你还想要加上链接的 title ，只要在网址后面用双引号把 title 文字包起来即可。\n- \\[text\\]\\(url\"解释“\\) ex: [链接](href: \"this is a null ref\")\n- 先定义参考refid：\\[text]\\[refid]\n再定义refid所指：\\[refid]:URL\n2. 图片\n1. 插入图片\n- 需要在链接文字方括号之前添加一个感叹号（exclamation mark：!），其语法格式  \\!\\[alt_text](url) 其中alt_text可以置空    \n- Markdown中的段落（包括图片）默认顶格左对齐，若要将图片居中，可以直接内嵌 HTML 的 <img> 标签，设置align=\"middle\"。如果还不行，可以尝试封裹一层 div 设置 style=\"text-align:center\" 实现\n2. 图片链接\n- 我们在 Markdown 图片标记![]()外面再嵌套一层[]()即可建立图片超链接，点击图片即可跳转到链接地址。\n图片链接的格式看起来大概是这样的:\n\\[\\!\\[](img_url)](ref_url)\n\n---\n\n## 锚点inner link\n1. 书签Bookmark\n    先定义锚点id：<a href=\"#auchor_id\">bookmark_text</a>\n    再定义一个id为auchor_id的对象（这里以<p>为例）：<p id=\"auchor_id\">auchor_text</p>\n2. 脚注Footnote\n    先在需要脚注的单词（terminology）后面添 加 [^Footnote] ： terminology[^Footnote]\n    再在文末 glossary 区域定义脚注（添加注解）： [^Footnote]：explanatory notes\n\n---\n\n## 引用Blockquote\nMarkdown 标记区块引用是使用类似 email 的引用方式，在断好的行前加上 > （more than or greater than sign）：\n\n---\n\n## 代码Code\n1. 行内代码Inline Code\nUse the `printf()` function.(此处使用了反斜杠转义)\n2. 代码块Code Blocks\n- 可使用预格式化引用语法格式。Preformatted Code Block\n在句段的行首插入1个 tab 或4个空格，则表示代码块。\n- [Fenced Code Block]\n在句段行首和行末用三个反引号换行闭包，并在行首三个反引号后添加 YAML 语言标识。\n\n---\n\n## 列表List\n1. 无序列表Unordered List\n无序列表（unordered, bulleted）项目的行首使用星号（或加号，或减号）加空格作为列表标记list markers\n2. 有序列表Ordered List\n有序列表（ordered / numbered）项目的行首则使用数字接一个英文句点标记（use numbers followed by periods）\n3. 扩展支持把列表变成带勾选框的任务列表，只需要在列表标记后添加[ ]标记☐表示unchecked，在中括号中填写x（[x]）标记☑︎表示checked（filled）。\n\n---\n\n## 表格Table\nYou can create tables by assembling a list of words and dividing them with hyphens - (for the first row), and then separating each column with a pipe | (vertical bar):\n\n  t1 |  t2 \n --- | ---\n t11 | t12 \n t21 | t22 \n\n","tags":["Markdown"]}]