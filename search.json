[{"title":"Blender+Unity3D","url":"/2019/11/06/Blender-Unity3D/","content":"\n## Blender+Unity3D\n\n1. 用blender建模\n2. 将模型以fbx格式导入https://www.mixamo.com网站（用chrome浏览器，firefox有问题）\n3. 选择想要的动作（pack选包），下载\n4. 导入到unity\n5. 将模型拖入场景\n6. 在model属性选择select，找到原始模型\n7. 在rig的animation type中选择humanoid人形骨骼\n8. 点选configue调整avatar\n9. 为animator建造动画控制器\n10. 将动画拖入动画控制器\n11. 每个动画也要转化成humanoid人形骨骼，但不需要再创建avatar，选择已经转好的avatar\n12. 通过修改动画中Animation勾选属性looptime可实现动画重复移动\n\n","tags":["Unity","Blender"]},{"title":"C++刷题实战（Dictionaries and Hashmaps)","url":"/2019/11/06/C-刷题实战（Dictionaries-and-Hashmaps/","content":"\n# C++刷题实战（Dictionaries and Hashmaps)\n\n## Hash Tables: Ransom Note\n\n思路1：剔除note中重复元素，查找note和magazine中每个元素数量，比较\n\n部分测试超时\n\n```c++\nvoid checkMagazine(vector<string> magazine, vector<string> note) {\n    //set<string> myM;\n    set<string> myN;\n    for(const auto& n:note){\n        myN.insert(n);\n    }\n\n    for(const auto& n:myN){\n        auto resM=count(begin(magazine),end(magazine),n);\n        auto resN=count(begin(note),end(note),n);\n        if(resN>resM){\n            cout <<\"No\"<<endl;\n            return;\n        }\n    }\n    cout <<\"Yes\"<<endl;\n}\n\n```\n\n思路2：用map存储magazine，遍历note元素，找到map中的对应值\n\n```c++\n// Complete the checkMagazine function below.\nvoid checkMagazine(vector<string> magazine, vector<string> note) {\n    unordered_map<string,int> mapM;\n    for(const auto& m:magazine){\n        if(mapM.find(m)==mapM.end()){\n                mapM.insert(pair<string,int>(m,1));\n        }else{\n            mapM[m]++;\n        }\n    }\n    for(const auto& n:note){\n        \n        auto res=mapM.find(n);\n        if(res==mapM.end()){\n            cout <<\"No\"<<endl;   \n            return;\n        }else if(res->second==0){\n            cout <<\"No\"<<endl;\n            return;\n        }\n        mapM[n]--;\n    }\n    cout <<\"Yes\"<<endl;\n\n}\n```\n\n**构建计数map**\n\n```\nunordered_map<string,int> mapM;\nfor(const auto& m:magazine){\n\tif(mapM.find(m)==mapM.end()){\n\t\tmapM.insert(pair<string,int>(m,1));\n\t}else{\n\t\tmapM[m]++;\n\t}\n}\n```\n\n\n\n## Two Strings\n\n思路：若s1和s2同时包含从a到z任意一个字符则有公共子串，否则没有\n\n```c++\nstring twoStrings(string s1, string s2) {\nfor(auto c : \"abcdefghijklmnopqrstuvwxyz\"){\n    if(s1.find_first_of(c)!=std::string::npos&&s2.find_first_of(c)!=std::string::npos){\n        return \"YES\";\n    }\n}\nreturn \"NO\";\n}\n```\n\n**s1.find_first_of(c)!=std::string::npos**\n\n## Sherlock and Anagrams\n\n思路：找出包含相同元素的字串数量\n\n```\nint sherlockAndAnagrams(string s) {\n    int ret = 0;\n    size_t len = s.length();\n\n    unordered_map<string, int> rec;\n    for (size_t ilen = 1; ilen < len; ilen++)\n    {//ilen用来递增每次切分的字串长度\n        for (size_t i = 0; i <= len - ilen; i++)\n        {//i用来递增每次切分字串的起始位置\n            string curr = s.substr(i, ilen);\n            std::sort(curr.begin(), curr.end());//通过排序使得乱序的字串一致\n            rec[curr]++;//将相同的字串存入字典\n        }\n        \n        //\n        for (auto &r : rec)\n            if (r.second > 1)\n                ret += r.second * (r.second - 1) / 2;//遍历字典增加记录\n        rec.clear();\n    }\n    return ret;\n}\n```\n\n**string curr = s.substr(i, ilen);**\n\n## Count Triplets\n\n找等比数列个数\n\n思路：一次遍历：找到前三个构成等比数列的元素（a1,a,2,a3)和他们重复次数(c1,c2,c3)（因为已经排序，所以顺序找下去就行），这三个元素构成等比数列的个数=c1*c2*c3。之后，每次保留a2，a3和c2，c3作为前两个元素（a1，a2），找新的下一个构成等比数列的元素（新的a3），和它的重复次数（新的c3）。直到a3是最后一个元素。或a3不构成等比数列，则把a3设为a1重新开始。\n\n思路2：也是一次遍历，先把arrA存入hashmap，key为arrA的值，value是重复次数。这样只需要遍历遍map，通过判断key为m mXr 和 mXrXr的value是否存在就可以确保等比数列的构成。（有错）\n\n```c++\nlong countTriplets(vector<long> arr, long r) {\n    long count=0;\n    size_t len=arr.size();\n    if(r==1){\n        return len*(len-1)*(len-2)/3/2;\n    }\n   unordered_map<long,long> mapA;\n    for(const auto& a:arr){\n        if(mapA.find(a)==mapA.end()){\n            mapA.insert(pair<long,long>(a,1));\n        }else{\n            mapA[a]++;\n        }\n    }    \n    auto m = mapA.begin();\n    while(m!=mapA.end()){\n        if(mapA.count(m->first*r)!=0&&mapA.count(m->first*r*r)!=0){\n            count+=mapA[m->first]*mapA[m->first*r]*mapA[m->first*r*r];\n        }\n        m++;\n    }\n\n       cout << count <<endl;\n   return count;\n}\n```\n\n思路3： 按照作者的意思，作者进行个对arr的遍历，建立两个字典，假设三元组为(A，B，C)，两个字典分别是指对于B来说A已经存在了，以及对于C来说（A，B）的组合已经准备好了。\n每个字典里面放的并不是实值，而是对于未来三元组的一个可能性的预测，在遍历每个A的同时让B与C的线性空间不断减小，是一个非常有意思的解决思路。 \n\n```c++\nlong countTriplets(vector<long> arr, long r) {\n    long res=0;\n      \n    unordered_map<long,long> mapA,mapB;\n\n    for(const auto& a:arr){\n        if(mapB.count(a)) res+=mapB[a];\n        if(mapA.count(a)) mapB[a*r]+=mapA[a];\n        mapA[a*r]++;\n    }\n    return res;\n}\n```\n\n## Frequency Queries\n\n```c++\nvector<int> freqQuery(vector<vector<int>> queries) {\n   int q;\n    int type;\n    int current_count;\n    vector<int> query;\n    vector<int> query_results;\n    unordered_map<long, int> count_map;\n    unordered_map<int, long> frequency_map;\n    \n    q = queries.size();\n    \n    for(int i =0 ; i < q ;i++){\n        query = queries[ i ];\n        type = query[0];\n        switch(type){\n            case 1:\n                frequency_map[count_map[ query[1] ]]--;\n                count_map[ query[1] ]++;\n                frequency_map[count_map[ query[1] ]]++;\n                break;\n            case 2:\n                current_count = count_map[ query[1] ];\n                if(current_count > 0){\n                    frequency_map[current_count]--;\n                    count_map[ query[1] ]--;\n                    frequency_map[count_map[ query[1] ]]++;\n                }\n                break;\n            case 3:\n                query_results.push_back(( frequency_map[query[1]] > 0 )? 1:0); \n                break;\n            default:\n                break;\n        }        \n    }\n    return query_results;\n}\n```\n\n","tags":["C++","HackerRank"]},{"title":"C++刷题实战（Dictionaries and Hashmaps)","url":"/2019/11/06/C-刷题实战（Dictionaries-and-Hashmaps)/"},{"title":"C++刷题实战（Array)","url":"/2019/11/06/C-刷题实战（Array)/","content":"\n# C++刷题实战（Array)\n\n## 2D Array - DS\n\n思路：不断求和比较更新最大值\n\n```\nint hourglassSum(vector<vector<int>> arr) {\n    \n    int sumMax=arr[0][0]+arr[0][1]+arr[0][2]\n            +arr[1][1]\n            +arr[2][0]+arr[2][1]+arr[2][2];;\n    int lNum=arr.size();\n    int vNum=arr[0].size();\n\n    for(int i=0;i<lNum-2;++i){\n        for(int j=0;j<vNum-2;++j){\n            int tem=arr[i][j]+arr[i][j+1]+arr[i][j+2]\n            +arr[i+1][j+1]\n            +arr[i+2][j]+arr[i+2][j+1]+arr[i+2][j+2];\n            if(tem>sumMax){\n                sumMax=tem;\n            }\n        }\n    }\n    return sumMax;\n\n}\n```\n\n**vector operator[]**\n\n## Arrays: Left Rotation\n\n思路：先计算出实际偏移值，因为左移5次是一个循环，然后根据偏移值构建新的int数组\n\n```\nvector<int> rotLeft(vector<int> a, int d) {\n    int aSize=a.size();\n    int usefulRotationTime=d%aSize;\n    vector<int> b(aSize,0);\n    for(int i=0;i<aSize;i++){\n        if(i-usefulRotationTime<0){\n            b[i-usefulRotationTime+aSize]=a[i];\n        }else{\n            b[i-usefulRotationTime]=a[i];\n\n        }\n    }\n    return b;\n}\n```\n\n## New Year Chaos\n\n思路：只需要计算本来应该在前面但跑到后面的个数。\n\n```\nvoid minimumBribes(vector<int> q) {\n    int n = A.size();\n    int cnt = 0;\n    for(int i = n - 1; i >= 0; i--)\n    {\n        if(A[i] != (i + 1))\n        {\n            if(((i - 1) >= 0) && A[i - 1] == (i + 1))\n            {\n                cnt++;\n                swap(A[i], A[i-1]);\n            }\n            else if(((i - 2) >= 0) && A[i - 2] == (i + 1))\n            {\n                cnt += 2;\n                A[i - 2] = A[i - 1];\n                A[i - 1] = A[i];\n                A[i] = i + 1;\n            }\n            else\n            {\n                printf(\"Too chaotic\\n\");\n                return;\n            }\n        }      \n    }\n    printf(\"%d\\n\",cnt);\n    return;\n}\n```\n\n## Minimum Swaps 2\n\n思路1：从第一位开始：如果该位不是他本身（不在正确的位置上）就找到他本身并交换，以此类推。有时候会超时\n\n```\nvoid swap(vector<int>& arr,int x,int y){\n    int tem=arr[x];\n    arr[x]=arr[y];\n    arr[y]=tem;\n}\n// Complete the minimumSwaps function below.\nint minimumSwaps(vector<int> arr) {\n    \n    int count =0;\n    for(int i=0;i<arr.size();++i){\n        if(arr[i]!=i+1){\n            for(int j=i;j<arr.size();++j){\n                if(arr[j]==i+1){\n                    swap(arr,i,j);\n                    count++;\n                    break;\n                }\n            }\n        }       \n    }\n    return count;\n\n}\n```\n\n思路2：将问题图形化，利用闭环，寻找闭环节点数\n\nhttps://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/\n\n```\nint minSwaps(int arr[], int n) \n{ \n    // Create an array of pairs where first \n    // element is array element and second element \n    // is position of first element \n    pair<int, int> arrPos[n]; \n    for (int i = 0; i < n; i++) \n    { \n        arrPos[i].first = arr[i]; \n        arrPos[i].second = i; \n    } \n  \n    // Sort the array by array element values to \n    // get right position of every element as second \n    // element of pair. \n    sort(arrPos, arrPos + n); \n  \n    // To keep track of visited elements. Initialize \n    // all elements as not visited or false. \n    vector<bool> vis(n, false); \n  \n    // Initialize result \n    int ans = 0; \n  \n    // Traverse array elements \n    for (int i = 0; i < n; i++) \n    { \n        // already swapped and corrected or \n        // already present at correct pos \n        if (vis[i] || arrPos[i].second == i) \n            continue; \n  \n        // find out the number of  node in \n        // this cycle and add in ans \n        int cycle_size = 0; \n        int j = i; \n        while (!vis[j]) \n        { \n            vis[j] = 1; \n  \n            // move to next node \n            j = arrPos[j].second; \n            cycle_size++; \n        } \n  \n        // Update answer by adding current cycle.  \n        if (cycle_size > 0) \n        { \n            ans += (cycle_size - 1); \n        } \n    } \n  \n    // Return result \n    return ans; \n} \n  \n// Driver program to test the above function \nint main() \n{ \n    int arr[] = {1, 5, 4, 3, 2}; \n    int n = (sizeof(arr) / sizeof(int)); \n    cout << minSwaps(arr, n); \n    return 0; \n} \n```\n\n\n\n## Array Manipulation\n\n硬算：超时\n\n```\nlong arrayManipulation(int n, vector<vector<int>> queries) {\n    vector<long> indexs(n,0);\n    for(auto& q : queries){\n        for(int i=q[0]-1;i<=q[1]-1;++i){\n            indexs[i]=indexs[i]+q[2];\n        }\n    }\n    long it = *max_element(std::begin(indexs), std::end(indexs)); \n    return it;\n\n}\n```\n\n用差分数组： 对于序列a{}，取a[i]-a[i-1]为其差分数组b[i]的值，可以发现，a[i]=∑bj（1≤j≤i） \n\nhttps://www.cnblogs.com/COLIN-LIGHTNING/p/8436624.html\n\n1.定义：\n\n对于已知有n个元素的离线数列d，我们可以建立记录它每项与前一项差值的差分数组f：显然，f[1]=d[1]-0=d[1];对于整数i∈[2,n]，我们让f[i]=d[i]-d[i-1]。\n\n2.简单性质：\n\n(1)计算数列各项的值：观察d[2]=f[1]+f[2]=d[1]+d[2]-d[1]=d[2]可知，数列第i项的值是可以用差分数组的前i项的和计算的，即d[i]=f[i]的前缀和。\n (2)计算数列每一项的前缀和：第i项的前缀和即为数列前i项的和，那么推导可知\n ![img](https://images2017.cnblogs.com/blog/1296534/201802/1296534-20180209192534420-1693228814.png)\n 即可用差分数组求出数列前缀和；\n\n3.用途：\n\n(1)快速处理区间加减操作：\n\n假如现在对数列中区间[L,R]上的数加上x，我们通过性质(1)知道，第一个受影响的差分数组中的元素为f[L],即令f[L]+=x，那么后面数列元素在计算过程中都会加上x；最后一个受影响的差分数组中的元素为f[R],所以令f[R+1]-=x，即可保证不会影响到R以后数列元素的计算。这样我们不必对区间内每一个数进行处理，只需处理两个差分后的数即可；\n\n(2)询问区间和问题：\n\n由性质(2)我们可以计算出数列各项的前缀和数组sum各项的值；那么显然，区间[L,R]的和即为ans=sum[R]-sum[L-1];\n\n```\nlong arrayManipulation(int n, vector<vector<int>> queries) {\n    vector<long> cf(n+1,0);//构建下标从1到n+1的N长的差分数组\n    for(auto& q : queries){\n        cf[q[0]]+=q[2];//根据差分数组性质\n        if(q[1]+1<=n)\n        cf[q[1]+1]-=q[2];\n    }\n\n    long x=0;\n    long max=0;\n    for(int i=1;i<=n;i++){\n        x+=cf[i];//根据差分数组性质每加一位就是取最终list中后一位的值，记录最大值\n        if(max<x) max=x;\n    }\n    return max;\n\n}\n```\n\n 若将(x，y)区间整体加val，我们就可以对差分数组的b[x]加val，b[y+1]减val。 \n\n**差分数组**","tags":["C++","HackerRank"]},{"title":"C++刷题实战（Warm UP）","url":"/2019/11/06/C-刷题实战（Warm-UP）/","content":"\n# C++刷题实战（Warm UP）\n\n## Sock Merchant\n\n思路：把匹配的袜子挑出来放到新的vector中，每次配对袜子避开那些已经匹配了的\n\n其他思路：用不可重复的容器如set，不断尝试将新的袜子放入若以重复表示匹配\n\n```\nint sockMerchant(int n, vector<int> ar) {\n    vector<int> selected;\n    int count=0;\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(find(selected.begin(),selected.end(),j)==selected.end())&&\n            !(find(selected.begin(),selected.end(),i)!=selected.end())\n            &&ar[i]==ar[j]){\n                count++;\n                selected.push_back(j);\n                break;\n            }\n        }\n        selected.push_back(i);\n    }\n    return count;\n\n}\n```\n\n**push_back**\n\n`find(selected.begin(),selected.end(),j)!=selected.end()`用来找寻元素。这个表示找到了。\n\n## Counting Valleys\n\n思路：用一个int表示之前状态（在山上，水平面，峡谷里），一个int表示当前状态，只有从山上或水平面，下到峡谷才经过一个峡谷\n\n```\nint countingValleys(int n, string s) {\n    int state=0;\n    int statePrevious;\n    int valley=0;\n    for(int i=0;i<n;i++){\n        if(state==0){\n            statePrevious=0;\n        }else if(state>0){\n            statePrevious=1;\n        }else{\n            statePrevious=-1;\n        }\n        \n        if(s[i]=='U'){\n            state++;\n        }else if(s[i]=='D'){\n            state--;\n        }\n        if(statePrevious>=0&&state<0){\n            valley++;\n        }\n    }\n    return valley;\n}\n\n```\n\n# Jumping on the Clouds\n\n思路：只要向后两个是能站的云就站上去，否则就只向前一步，注意：需要判断结束条件\n\n```\nint jumpingOnClouds(vector<int> c) {\n    int steps=0;\n    auto player=c.begin();\n    while(player!=c.end()){\n        if(next(player,2)==--c.end()||next(player,1)==--c.end())\n        {\n            steps++;\n            break;\n        }\n        if(*next(player,2)==1){\n            player=next(player,1);\n        }else{\n            player=next(player,2);\n        }\n        steps++;\n    }\n    return steps;\n\n}\n```\n\n**iterator的end指向的是最后一个元素之后的位置，所以为了获得最后一个元素要--操作**\n\n**iterator是指针，要获得原object要*操作取消引用**\n\n关于next，advance的区别：next是advance带返回值的版本\n\n# Repeated String\n\n```\nlong repeatedString(string s, long n) {\n    int length=s.length();\n    int aNum=0;\n    for(int i=0;i<length;++i){\n        if(s[i]=='a'){\n            aNum++;\n        }\n    }\n    long repeteTimes=n/length*aNum;\n    long leftLetters=n%length;\n    for(long i=0;i<leftLetters;++i){\n        if(s[i]=='a'){\n            repeteTimes++;\n        }\n    }\n    return repeteTimes;\n}\n```\n\n思路：a在s中出现频率*s重复次数+最后用于补全的句子中a重复次数，s重复次数=n/s长度。注意：用long\n\n**获取字符串长度用length()**","tags":["C++","HackerRank"]},{"title":"C++学习与总结-高级篇","url":"/2019/11/06/C-学习与总结-高级篇/","content":"\n# C++学习与总结-高级篇\n\n## 小结：\n\n- **文件读写和文件位置定位**\n- **try、catch、throw**\n- **定义新的异常，继承exception** \n- **栈：在函数内部声明的所有变量都将占用栈内存。**\n- **堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。**\n- **模板**\n- **预处理器和宏**\n- **信号处理<csignal>**\n- **多线程**\n- **STL**\n\n## C++ 文件和流\n\n <iostream> 和 <fstream> \n\n **ofstream** 和 **fstream** 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 **ifstream** 对象。 \n\n文件操作：打开open，关闭close，写入 << ，读取 \\>>  \n\n文件位置指针\n\n**istream** 和 **ostream** 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 **seekg**（\"seek get\"）和关于 ostream 的 **seekp**（\"seek put\"）。\n\nseekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 **ios::beg**（默认的，从流的开头开始定位），也可以是 **ios::cur**（从流的当前位置开始定位），也可以是 **ios::end**（从流的末尾开始定位）。\n\n文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。\n\n## C++ 异常处理\n\n 三个关键字：**try、catch、throw**\n\n定义新的异常\n\n您可以通过继承和重载 **exception** 类来定义新的异常。\n\n## C++ 动态内存\n\nC++ 程序中的内存分为两个部分：\n\n- **栈：**在函数内部声明的所有变量都将占用栈内存。\n- **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。\n\n在 C++ 中，您可以使用特殊的运算符为给定类型的变量**在运行时分配堆内的内存**，这会返回所分配的空间地址。这种运算符即 **new** 运算符。\n\n如果您不再需要动态分配的内存空间，可以使用 **delete** 运算符，删除之前由 new 运算符分配的内存。\n\n **malloc()** *函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。* \n\n## C++ 命名空间\n\n 在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。 \n\n 因此，引入了**命名空间**这个概念，专门用于解决上面的问题，它可作为**附加信息**来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，**命名空间就是定义了一个范围**。 \n\n## C++ 模板\n\n模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。\n\n模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。\n\n## C++ 预处理器\n\n预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。\n\n所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。\n\n我们已经看到，之前所有的实例中都有 **#include** 指令。这个宏用于把头文件包含到源文件中。\n\n- #define 预处理指令用于创建符号常量。该符号常量通常称为**宏**，\n- 您可以使用 #define 来定义一个带有参数的宏 \n- 条件编译, 有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。\n\n```\n#ifdef NULL\n   #define NULL 0\n#endif\n```\n\nC++ 中的预定义宏:\n\n| `__LINE__` | 这会在程序编译时包含当前行号。                               |\n| ---------- | ------------------------------------------------------------ |\n| `__FILE__` | 这会在程序编译时包含当前文件名。                             |\n| `__DATE__` | 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 |\n| `__TIME__` | 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 |\n\n**#** 和 **##** 运算符\n\n\\# 字符串化的意思，出现在宏定义中的#是把跟在后面的参数转换成一个字符串。\n\n当用作字符串化操作时，# 的主要作用是将宏参数不经扩展地转换成字符串常量。\n\n-  宏定义参数的左右两边的空格会被忽略，参数的各个 Token 之间的多个空格会被转换成一个空格。 \n-  宏定义参数中含有需要特殊含义字符如\"或\\时，它们前面会自动被加上转义字符 \\。 \n\n\\## 连接符号，把参数连在一起。\n\n将多个 Token 连接成一个 Token。要点：\n\n-  它不能是宏定义中的第一个或最后一个 Token。\n-  前后的空格可有可无。\n\n## C++ 信号处理\n\n信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。\n\n有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 <csignal> 中。\n\n## signal() 函数\n\nC++ 信号处理库提供了 **signal** 函数，用来捕获突发事件。以下是 signal() 函数的语法：\n\n```\nvoid (*signal (int sig, void (*func)(int)))(int); \n```\n\n您可以使用函数 **raise()** 生成信号，该函数带有一个整数信号编号作为参数，语法如下：\n\n```\nint raise (signal sig);\n```\n\n**Sleep 函数**\n\n功能：执行挂起一段时间，也就是等待一段时间在继续执行\n\n用法：Sleep(时间)\n\n**注意：**\n\n-  （1）Linux 用 **#include ** 和 **sleep()**，Windos 用 **#include ** 和 **Sleep()**。\n-  （2）Sleep括号里的时间，在windows下是已毫秒为单位，而LInux是已秒为单位。\n\n## C++ 多线程\n\n多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：**基于进程和基于线程**。\n\n- 基于进程的多任务处理是程序的并发执行。\n- 基于线程的多任务处理是同一程序的片段的并发执行。\n\n c++ 11 之后有了标准的线程库： #include <thread>\n\n## C++ Web 编程\n\n 公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。 \n\n## C++ STL 教程\n\nC++ 标准模板库的核心包括以下三个组件：\n\n| 组件                | 描述                                                         | 例子                                                         |\n| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 容器（Containers）  | 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 | vector，string，list，set（任意两元素不相等），map,stack,queue,deque(双端队列，动态数组) |\n| 算法（Algorithms）  | 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 |                                                              |\n| 迭代器（iterators） | 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 |                                                              |\n\n标准模板库包含了序列容器（sequence containers）与关系容器（associative containers）。 \n\n| 数据容器                                                     | 描述                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 序列容器 - [有序集](https://zh.wikipedia.org/wiki/线性表)    |                                                              |\n| **[vector](https://zh.wikipedia.org/wiki/Vector_(STL))**     | 动态数组，兼容C语言数组。vector可以如同数组一样的访问方式，例如使用下标（operator[]）运算符，并记得自己的长度信息（size），您也可以使用对象的方式来访问vector（push_back、pop_back）。使用vector可以轻易地定义多维可调整型数组（std::vector<std::vector<...> >）。要使用vector，必须含入vector头文件。vector可在[O(1)](https://zh.wikipedia.org/wiki/大O记号)内完成在末尾插入 / 移除元素，但在vector中间或开头插入/移除元素，则需要消耗O(n)时间。 |\n| **[list](https://zh.wikipedia.org/wiki/List_(STL))**         | list容器是一个有序（Ordered）的数据结构（循序容器），每个元素中存储着上一个元素和下一个元素的地址（指针），因此是一个双向链接的链表。与vector相比，其元素的访问速度较慢，而在已知元素位置的情况下，插入和删除速度较快。STL容器中唯一支持事务语义。 |\n| **forward_list** （单向链表）                                | list的单链表版，去掉了一些操作。                             |\n| **deque** （[双端队列](https://zh.wikipedia.org/wiki/双端队列)） | 可看做为能在常量时间内完成向开头或结尾插入或删除元素的vector，但是修改之后，其迭代器的有效性就无法得到保障。 |\n| **array**                                                    | 只能在初始化时指定大小的数组，可视为内置数组的封装。         |\n| [关联容器](https://zh.wikipedia.org/w/index.php?title=Associative_array&action=edit&redlink=1) - 无序集 |                                                              |\n| **set**                                                      | 不重复元素的集合。                                           |\n| **multiset**                                                 | 跟set具有相同功能，但允许重复的元素。                        |\n| **[map](https://zh.wikipedia.org/w/index.php?title=Map_(C%2B%2B_container)&action=edit&redlink=1)** | 关联数组，每个元素含有两个数据项，map将一个数据项映射到另一个数据项中。 |\n| **multimap**                                                 | 跟map具有相同功能，但允许重复的键值。                        |\n| **unordered_set** **unordered_multiset** **unordered_map** **unordered_multimap** | 分别类似于集合、多重集合、映射、多重映射，但使用[哈希表](https://zh.wikipedia.org/wiki/哈希表)实现。它的键（Keys）没有排序（operator<），相反必须存在一个从键类型到size_t的哈希函数、且要求键之间可以判等（operator==）。自[C++11](https://zh.wikipedia.org/wiki/C%2B%2B11)起进入语言标准。 |\n| 其他类型的容器                                               |                                                              |\n| **bitset**                                                   | 存储系列位类似的固定大小的布尔向量。实现按位运算，没有迭代器，不是序列。可视为std::array<bool, N>。若需要改变序列长度，可用std::vector<bool>。 |\n| **valarray**                                                 | 数值类型的std::vector。牺牲泛型能力而专为数值计算做了优化，例如在数组上的sin操作可对数组内所有数值取[正弦](https://zh.wikipedia.org/wiki/正弦)。有些实现会对std::valarray应用向量指令等优化手段。 一个观点是里面全是数值类型的valarray才是[数学](https://zh.wikipedia.org/wiki/数学)意义上的[向量](https://zh.wikipedia.org/wiki/向量)，而可以泛型的vector更该叫array——[编程语言](https://zh.wikipedia.org/wiki/编程语言)中的[数组](https://zh.wikipedia.org/wiki/数组)。 |","tags":["C++"]},{"title":"C++学习与总结-1114篇","url":"/2019/11/06/C-学习与总结-1114篇/","content":"\n# C++学习与总结-11/14篇\n\n## 小结：\n\n- **使用nullptr而不是NULL**\n- **巧用auto**\n- **for(auto &x : array) {**\n      **std::cout << x << std::endl;**\n  **}**\n- **使用 `{}` 进行初始化**\n- **模板可用using改名，可添加默认参数，可变长**\n- **构造函数可以委托和继承**\n- **关键字  `override` 和 `final`用于控制重载  default和delete用于控制编译器生成默认构造函数**\n- **enum class**\n- **使用lambda表达式和捕获列表**\n- **用`std::function`包装函数，将函数和函数指针作为对象处理**\n- **`std::move` 总会接受到一个左值，从而转发调用了`reference(int&&)` 输出右值引用。** \n- **std::array**\n- **`std::shared_ptr`/`std::unique_ptr`/`std::weak_ptr`**\n- **`std::regex`**\n- **<thread>和<mutex>**\n- **`noexcept` 修饰符**\n- **字面量R**\n\n## nullptr 与 constexpr     \n\n 当需要使用 `NULL` 时候，请养成直接使用 `nullptr` 的习惯。 \n\n `constexpr`常量表达式 让用户显式的声明函数或对象构造函数在编译器会成为常数  从 C++ 14 开始，`constexptr` 函数可以在内部使用局部变量、循环和分支等简单语句 \n\n##  类型推导 \n\n C++ 11 引入了 `auto` 和 `decltype` 这两个关键字实现了类型推导，让编译器来操心变量的类型。 \n\n 使用 `auto` 进行类型推导的一个最为常见而且显著的例子就是迭代器\n\n```\nfor(auto itr = vec.cbegin(); itr != vec.cend(); ++itr);\n```\n\n **注意**：`auto` 不能用于函数传参，  `auto` 还不能用于推导数组类型： \n\n `decltype` 关键字是为了解决 auto 关键字只能对变量进行类型推导的缺陷而出现的。 和sizeof相似：\n\n有时候，我们可能需要计算某个表达式的类型，例如：\n\n```\nauto x = 1;\nauto y = 2;\ndecltype(x+y) z;   // z 是一个 int 型的\n```\n\n 从 C++ 14 开始是可以直接让普通函数具备返回值推导 \n\n```\ntemplate<typename T, typename U>\nauto add(T x, U y) {\n    return x+y;\n}\n```\n\n##  区间迭代     \n\n```\nint array[] = {1,2,3,4,5};\nfor(auto &x : array) {\n    std::cout << x << std::endl;\n}\n```\n\n##  初始化列表     \n\n 使用 `{}` 进行初始化 \n\nC++11 首先把初始化列表的概念绑定到了类型上，并将其称之为 `std::initializer_list`，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如：\n\n```\n#include <initializer_list>\n\nclass Magic {\npublic:\n    Magic(std::initializer_list<int> list) {}\n};\n\nMagic magic = {1,2,3,4,5};\nstd::vector<int> v = {1, 2, 3, 4};\n```\n\n初始化列表除了用在对象构造上，还能将其作为普通函数的形参，例如：\n\n```\nvoid func(std::initializer_list<int> list) {\n    return;\n}\n\nfunc({1,2,3});\n```\n\n##  模板增强     \n\n#### 外部模板\n\n```\nextern template class std::vector<double>;  // 不在该编译文件中实例化模板 \n```\n\n#### 类型别名模板\n\n```\nusing process = int(*)(void *); // 定义了一个返回类型为 int，参数为 void* 的函数指针类型，名字叫做 process\n```\n\n#### 默认模板参数\n\n```\ntemplate<typename T = int, typename U = int>\nauto add(T x, U y) -> decltype(x+y) {\n    return x+y;\n}\n\n```\n\n#### 变长参数模板\n\n```\ntemplate<typename... Ts> class Magic;\n\n```\n\n 可以使用 `sizeof...` 来计算参数的个数 \n\n 对参数进行解包 :\n\n **递归模板函数** \n\n```\n#include <iostream>\ntemplate<typename T>\nvoid printf(T value) {\n    std::cout << value << std::endl;\n}\ntemplate<typename T, typename... Args>\nvoid printf(T value, Args... args) {\n    std::cout << value << std::endl;\n    printf(args...);\n}\nint main() {\n    printf(1, 2, \"123\", 1.1);\n    return 0;\n}\n\n```\n\n **初始化列表展开** \n\n```\ntemplate<typename T, typename... Args>\nauto print(T value, Args... args) {\n    std::cout << value << std::endl;\n    return std::initializer_list<T>{([&] {\n        std::cout << args << std::endl;\n    }(), value)...};\n}\nint main() {\n    print(1, 2.1, \"123\");\n    return 0;\n}\n\n```\n\n ## 面向对象增强 \n\n#### 委托构造\n\n C++ 11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的： \n\n```\nclass Base {\npublic:\n    int value1;\n    int value2;\n    Base() {\n        value1 = 1;\n    }\n    Base(int value) : Base() {  // 委托 Base() 构造函数\n        value2 = 2;\n    }\n};\n\nint main() {\n    Base b(2);\n    std::cout << b.value1 << std::endl;\n    std::cout << b.value2 << std::endl;\n}\n\n```\n\n#### 继承构造\n\n在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++ 11 利用关键字 using 引入了继承构造函数的概念：\n\n```\nclass Base {\npublic:\n    int value1;\n    int value2;\n    Base() {\n        value1 = 1;\n    }\n    Base(int value) : Base() {                          // 委托 Base() 构造函数\n        value2 = 2;\n    }\n};\nclass Subclass : public Base {\npublic:\n    using Base::Base;  // 继承构造\n};\nint main() {\n    Subclass s(3);\n    std::cout << s.value1 << std::endl;\n    std::cout << s.value2 << std::endl;\n}\n\n```\n\n#### 显式虚函数重载\n\n C++ 11 引入了 `override` 和 `final` 这两个关键字来防止上述情形的发生。 \n\n当重载虚函数时，引入 `override` 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译。\n\n`final` 则是为了防止类被继续继承以及终止虚函数继续重载引入的。\n\n#### 显式禁用默认函数\n\n 允许显式的声明采用或拒绝编译器自带的函数。 \n\n```\nclass Magic {\npublic:\n    Magic() = default;  // 显式声明使用编译器生成的构造\n    Magic& operator=(const Magic&) = delete; // 显式声明拒绝编译器生成构造\n    Magic(int magic_number);\n}\n\n```\n\n ## 强类型枚举 \n\nC++ 11 引入了枚举类（enumaration class），并使用 `enum class` 的语法进行声明：\n\n```\nenum class new_enum : unsigned int {\n    value1,\n    value2,\n    value3 = 100,\n    value4 = 100\n};\n\n```\n\n在这个语法中，枚举类型后面使用了冒号及类型关键字来指定枚举中枚举值的类型，这使得我们能够为枚举赋值（未指定时将默认使用 int）。\n\n而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 `<<` 这个算符来进行输出，可以收藏下面这个代码段：\n\n```\n#include <iostream>\ntemplate<typename T>\nstd::ostream& operator<<(typename std::enable_if<std::is_enum<T>::value, std::ostream>::type& stream, const T& e)\n{\n    return stream << static_cast<typename std::underlying_type<T>::type>(e);\n}\n\n```\n\n这时，下面的代码将能够被编译：\n\n```\nstd::cout << new_enum::value3 << std::endl\n\n```\n\n## Lambda表达式\n\nLambda 表达式的基本语法如下：\n\n```\n[捕获列表](参数列表) mutable(可选) 异常属性 -> 返回类型 {\n    // 函数体\n}\n[ caputrue ] ( params ) opt -> ret { body; };\n\n```\n\n所谓捕获列表，其实可以理解为参数的一种类型，lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的，这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：\n\n**1. 值捕获**\n\n **2. 引用捕获** \n\n **3. 隐式捕获** \n\n总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：\n\n- `[]` 空捕获列表\n- `[name1, name2, ...]` 捕获一系列变量\n- `[&]` 引用捕获, 让编译器自行推导捕获列表\n- `[=]` 值捕获, 让编译器执行推导应用列表\n- **表达式捕获（C++ 14）** \n- 泛型 Lambda (C++ 14) `auto` 关键字来产生意义上的泛型： \n\n##  函数对象包装器     \n\nC++11 `std::function`  是一种通用、多态的函数封装，它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作，它也是对  C++中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的），换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。例如：\n\n```\n#include <functional>\n#include <iostream>\n\nint foo(int para) {\n    return para;\n}\n\nint main() {\n    // std::function 包装了一个返回值为 int, 参数为 int 的函数\n    std::function<int(int)> func = foo;\n\n    int important = 10;\n    std::function<int(int)> func2 = [&](int value) -> int {\n        return 1+value+important;\n    };\n    std::cout << func(10) << std::endl;\n    std::cout << func2(10) << std::endl;\n}\n\n```\n\n 而 `std::bind` 则是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用 \n\n##  右值引用     \n\n  传统的 C++ 没有区分『移动』和『拷贝』的概念，造成了大量的数据移动，浪费时间和空间。右值引用的出现恰好就解决了这两个概念的混淆问题 \n\n无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发，所以 `std::move` 总会接受到一个左值，从而转发调用了`reference(int&&)` 输出右值引用。 \n\n## 新增容器\n\n#### std::array\n\n使用 `std::array` 保存在栈内存中，相比堆内存中的 `std::vector`，我们就能够灵活的访问这里面的元素，从而获得更高的性能；同时正式由于其堆内存存储的特性，有些时候我们还需要自己负责释放这些资源。\n\n而第二个问题就更加简单，使用`std::array`能够让代码变得更加现代，且封装了一些操作函数，同时还能够友好的使用标准库中的容器算法等等，比如 `std::sort`。\n\n`std::array` 会在编译时创建一个固定大小的数组，`std::array` 不能够被隐式的转换成指针，使用 `std::array` 很简单，只需指定其类型和大小即可：\n\n```\nstd::array<int, 4> arr= {1,2,3,4};\n\n```\n\n#### std::forward_list\n\n `std::forward_list` 使用单向链表进行实现 \n\n C++11 引入了两组无序容器：`std::unordered_map`/`std::unordered_multimap` 和 `std::unordered_set`/`std::unordered_multiset`。 \n\n#### 元组 std::tuple \n\n关于元组的使用有三个核心的函数：\n\n1. `std::make_tuple`: 构造元组\n2. `std::get`: 获得元组某个位置的值\n3. `std::tie`: 元组拆包\n\n##  智能指针和引用计数 \n\n `std::shared_ptr`/`std::unique_ptr`/`std::weak_ptr`，使用它们需要包含头文件memory。 \n\n `std::make_shared` 就能够用来消除显示的使用 `new`，所以`std::make_shared` 会分配创建传入参数中的对象，并返回这个对象类型的`std::shared_ptr`指针。例如：\n\n```\nauto pointer = std::make_shared<int>(10);\n\n```\n\n `std::shared_ptr` 可以通过 `get()` 方法来获取原始指针，通过 `reset()` 来减少一个引用计数，并通过`get_count()`来查看一个对象的引用计数。 \n\n `std::unique_ptr` 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证了代码的安全： \n\n 是，我们可以利用 `std::move` 将其转移给其他的 `unique_ptr`\n\n `std::weak_ptr`是一种弱引用（相比较而言 `std::shared_ptr` 就是一种强引用）。弱引用不会引起引用计数增加 \n\n `std::weak_ptr` 没有 `*` 运算符和 `->` 运算符，所以不能够对资源进行操作，它的唯一作用就是用于检查 `std::shared_ptr` 是否存在，`expired()` 方法在资源未被释放时，会返回 `true`，否则返回 `false`。 \n\n## 正则表达式\n\n C++11 提供的正则表达式库操作 `std::string` 对象，模式 `std::regex` (本质是 `std::basic_regex`)进行初始化，通过 `std::regex_match` 进行匹配，从而产生 `std::smatch` （本质是 `std::match_results` 对象）。 \n\n##  线程支持 \n\n `std::thread` 用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含<thread>头文件，它提供了很多基本的线程操作，例如`get_id()`来获取所创建线程的线程 ID，例如使用 `join()` 来加入一个线程  等等 \n\n C++11 引入了 mutex 相关的类，其所有相关的函数都放在mutex 头文件中。 \n\n`std::mutex` 是 C++11 中最基本的 `mutex` 类，通过实例化 `std::mutex` 可以创建互斥量，而通过其成员函数 `lock()` 可以仅此能上锁，`unlock()` 可以进行解锁。但是在在实际编写代码的过程中，最好不去直接调用成员函数，因为调用成员函数就需要在每个临界区的出口处调用 `unlock()`，当然，还包括异常。这时候 C++11 还为互斥量提供了一个 RAII 语法的模板类`std::lock_gurad`。RAII 在不失代码简洁性的同时，很好的保证了代码的异常安全性。\n\n在 RAII 用法下，对于临界区的互斥量的创建只需要在作用域的开始部分，例如：\n\n```\nvoid some_operation(const std::string &message) {\n    static std::mutex mutex;\n    std::lock_guard<std::mutex> lock(mutex);\n\n    // ...操作\n\n    // 当离开这个作用域的时候，互斥锁会被析构，同时unlock互斥锁\n    // 因此这个函数内部的可以认为是临界区\n}\n\n```\n\n在并发编程中，推荐使用 `std::unique_lock`。例如：\n\n```\n#include <iostream>\n#include <thread>\n#include <mutex>\n\nstd::mutex mtx;\n\nvoid block_area() {\n    std::unique_lock<std::mutex> lock(mtx);\n    //...临界区\n}\nint main() {\n    std::thread thd1(block_area);\n\n    thd1.join();\n\n    return 0;\n}\n\n```\n\n `std::future` 则是提供了一个访问异步操作结果的途径 \n\n `std::packaged_task` 可以用来封装任何可以调用的目标，从而用于实现异步的调用 \n\n `std::condition_variable` 是为了解决死锁而生的。当互斥操作不够用而引入的。 \n\n## 其他\n\n `long long int` 类型至少具备 64 位的比特数。 \n\nC++11 将异常的声明简化为以下两种情况：\n\n1. 函数可能抛出任何异常\n2. 函数不能抛出任何异常\n\n并使用 `noexcept` 对这两种行为进行限制，例如：\n\n```\nvoid may_throw();           // 可能抛出异常\nvoid no_throw() noexcept;   // 不可能抛出异常\n\n```\n\n使用 `noexcept` 修饰过的函数如果抛出异常，编译器会使用 `std::terminate()` 来立即终止程序运行。\n\n`noexcept` 还能用作操作符，用于操作一个表达式，当表达式无异常时，返回 `true`，否则返回 `false`。\n\n C++11 提供了原始字符串字面量的写法，可以在一个字符串前方使用 `R` 来修饰这个字符串，同时，将原始字符串使用括号包裹，例如： \n\n```\n std::string str = R\"(C:\\\\What\\\\The\\\\Fxxk)\";\n\n```\n\n C++11 引进了自定义字面量的能力，通过重载双引号后缀运算符实现： ","tags":["C++"]},{"title":"C++学习与总结-基础篇","url":"/2019/11/06/C-学习与总结-基础篇/","content":"\n# C++学习与总结-基础篇\n\n## 小结：\n\n- **用#if 0**\n  **code**\n  **#endif 测试**\n- **typedef重命名类型**\n- **常量：const 和 #define**\n- **引用**\n- **clog**\n- **拷贝构造函数**\n- **函数重载和运算符重载**\n- **virtual虚函数，动态链接，数据封装，多态**\n- **纯虚函数，接口，抽象类**\n\nC++11/14 以前的重要特性：\n\n C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。 \n\n四大特性：\n\n1. 封装\n2. 抽象\n3. 继承\n4. 多态\n\n---\n\n## 关于注释\n\n我们还可以使用 #if 0 ... #endif  来实现注释，且可以实现嵌套，格式为：\n\n```\n#if 0\n   code\n#endif \n```\n\n你可以把 #if 0 改成 #if 1 来执行 **code** 的代码。\n\n这种形式对程序调试也可以帮助，测试时使用 **#if 1** 来执行测试代码，发布后使用 **#if 0** 来屏蔽测试代码。\n\n**#if** 后可以是任意的条件语句。\n\n下面的代码如果 condition 条件为 true 执行 code1 ，否则执行 code2。\n\n```\n#if condition\n  code1\n#else\n  code2\n#endif\n```\n\n## 关于数据类型\n\nchar 一个字节\n\nint 四个字节\n\nfloat 四个字节\n\n 使用 **typedef** 为一个已有的类型取一个新的名字 \n\n## 关于变量类型\n\nC++ 中有两种类型的表达式：\n\n- **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。\n- **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。\n\n## 关于常量\n\n在 C++ 中，有两种简单的定义常量的方式：\n\n- 使用 **#define** 预处理器。\n- 使用 **const** 关键字。\n\n## 关于存储类\n\n 存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。 \n\n使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。\n\n## 关于运算符\n\n sizeof  返回变量的大小 \n\n Condition ? X : Y   如果 Condition 为真 ? 则值为 X : 否则值为 Y。 \n\n &   返回变量的地址 \n\n \\*  指向一个变量 \n\n## 关于函数\n\n向函数传递参数的**传值调用**方法，把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。\n\n向函数传递参数的**指针调用**方法，把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。\n\n向函数传递参数的**引用调用**方法，把引用的地址复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。\n\n 当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。 \n\n## 关于引用\n\n 引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 \n\n- 不存在空引用。引用必须连接到一块合法的内存。\n- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。\n- 引用必须在创建时被初始化。指针可以在任何时间被初始化。\n\n C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 \n\n 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 \n\n## 关于标准输入输出\n\n标准日志流（clog）\n\n预定义的对象 **clog** 是 **iostream** 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 **clog** 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲在，直到缓冲填满或者缓冲区刷新时才会输出。\n\n## 关于类和对象\n\n使用初始化列表来初始化字段\n\n C::C( double a, double b, double c): X(a), Y(b), Z(c) \n\n### 拷贝构造函数\n\n**必须定义拷贝构造函数的情况：**\n\n只包含类类型成员或内置类型（但不是指针类型）成员的类，无须显式地定义拷贝构造函数也可以拷贝；有的类有一个数据成员是指针，或者是有成员表示在构造函数中分配的其他资源，这两种情况下都必须定义拷贝构造函数。\n\n**什么情况使用拷贝构造函数：**\n\n类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数：\n\n- （1）一个对象以值传递的方式传入函数体  \n- （2）一个对象以值传递的方式从函数返回  \n- （3）一个对象需要通过另外一个对象进行初始化。\n\n### 友元函数\n\n类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。 \n\n因为友元函数没有this指针，则参数要有三种情况： \n\n要访问非static成员时，需要对象做参数；\n\n要访问static成员或全局变量时，则不需要对象做参数；\n\n如果做参数的对象是全局对象，则不需要对象做参数.\n\n可以直接调用友元函数，不需要通过对象或指针\n\n## 关于继承\n\n多继承(环状继承),A->D, B->D, C->(A，B)，例如：\n\n```\nclass D{......};\nclass B: public D{......};\nclass A: public D{......};\nclass C: public B, public A{.....};\n```\n\n这个继承会使D创建两个对象,要解决上面问题就要用虚拟继承格式\n\n格式：class 类名: virtual 继承方式 父类名\n\n```\nclass D{......};\nclass B: virtual public D{......};\nclass A: virtual public D{......};\nclass C: public B, public A{.....};\n```\n\n虚继承--（在创建对象的时候会创建一个虚表）在创建父类对象的时候\n\n```\nA:virtual public D\nB:virtual public D\n```\n\n## 关于重载\n\nC++ 允许在同一作用域中的某个**函数**和**运算符**指定多个定义，分别称为**函数重载**和**运算符重载**。\n\n重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。\n\n```\nBox operator+(const Box&);\n```\n\n## 关于多态\n\n**虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。\n\n我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。\n\n*不添加virtual就是静态多态，或静态链接。*\n\n您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。 \n\n``` \n// pure virtual function\nvirtual int area() = 0;\n```\n\n## 关于数据抽象\n\n用类定义抽象数据类型（ADT）\n\n**设计策略**\n\n*抽象把代码分离为接口和实现。*所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。\n\n**在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可。**\n\n## 关于数据封装\n\n C++ 通过创建**类**来支持封装和数据隐藏（public、protected、private） \n\n C++中**, 虚函数**可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关。 \n\n## 关于接口\n\n C++ 接口是使用**抽象类**来实现的，  如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 \"= 0\" 来指定的，\n\n如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 \"= 0\" 来指定的\n\n**设计策略**\n\n面向对象的系统可能会使用一个抽象基类*为所有的外部应用程序提供一个适当的、通用的、标准化的接口*。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。\n\n外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。\n\n**这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。**","tags":["C++"]},{"title":"OpenGL（glut） 开发跳一跳实战","url":"/2019/11/06/OpenGL（glut）-开发跳一跳实战/","content":"\n# OpenGL（glut） 开发跳一跳实战\n\n## 1. 找到素材\n\n因为老师给的glut库只支持特定格式的3D模型，本来想用blender建模导入，尝试不行。所以就先在网上先找到（.off) 的棋子模型\n\n## 2. 实现棋子的显示\n\n- 声明模型\n\n```\nModel3D  *chess_piece_model = NULL; // main character model: chess piece\n```\n\n- 创建模型实例并加载资源\n\n```\nchess_piece_model = new Model3D();\nchess_piece_model->load_3d_model(\"resources/chess_piece.off\");\n```\n\n- 绘制模型\n\n  棋子颜色为黑色纯色，也可使用texture\n\n```\nvoid display_chess_piece_model()\n{\n\t\n\tglPushMatrix();\n\n\tglTranslatef(0, 14, 0); // pour le positioner sur le terrain\n\tglScalef(10, 10, 10);\n\n\n\tglBegin(GL_TRIANGLES);\n\tfor (int i = 0; i < chess_piece_model->nb_triangles; i++) {\n\t\tglColor3f(0.0f, 0.0f, 0.0f);\n\n\t\tglVertex3f(chess_piece_model->points[chess_piece_model->faces[i].a].x, chess_piece_model->points[chess_piece_model->faces[i].a].y, chess_piece_model->points[chess_piece_model->faces[i].a].z);\n\n\t\tglVertex3f(chess_piece_model->points[chess_piece_model->faces[i].b].x, chess_piece_model->points[chess_piece_model->faces[i].b].y, chess_piece_model->points[chess_piece_model->faces[i].b].z);\n\n\t\tglVertex3f(chess_piece_model->points[chess_piece_model->faces[i].c].x, chess_piece_model->points[chess_piece_model->faces[i].c].y, chess_piece_model->points[chess_piece_model->faces[i].c].z);\n\t}\n\tglEnd();\n\tglPopMatrix();\n}\n```\n\n##  3. 实现平台的显示\n\n平台是基于立方体做transform得到的。所以要先实现立方体的绘制。\n\n绘制立方体，参见这篇文章\n\nhttps://www.cnblogs.com/icmzn/p/5049768.html\n\n用一个二维数组vertex_list记录立方体点位置\n\n```\nstatic const GLfloat vertex_list[][3] = {\n\t-0.5f, -0.5f, -0.5f,\n\t 0.5f, -0.5f, -0.5f,\n\t-0.5f,  0.5f, -0.5f,\n\t 0.5f,  0.5f, -0.5f,\n\t-0.5f, -0.5f,  0.5f,\n\t 0.5f, -0.5f,  0.5f,\n\t-0.5f,  0.5f,  0.5f,\n\t 0.5f,  0.5f,  0.5f,\n};\n```\n\n![image-20191104151452718](D:\\Shared Projects\\WEB\\blog\\source\\img\\未分类\\image-20191104151452718.png)\n\n用另一个二维数组记录面和点的绘制顺序\n\n```\nstatic const GLint index_list[][4] = {\n\t0, 2, 3, 1,\n\t4, 6, 2, 0,\n\t4, 0, 1, 5,\n\t4, 6, 7, 5,\n\t5, 7, 3, 1,\n\t6, 2, 3, 7,\n};\n```\n\n因为为了方便在平台不同面显示不同内容（方便打广告XD），把顶面和其他面的显示分开实现。\n\n用了两个texture。一个是箭头放在顶面用来实现类似劲舞团的功能，另一个是纯色图片用于装饰其他面\n\n以下是显示顶面的代码\n\n```\nvoid display_cube_face() {\n\tglBindTexture(GL_TEXTURE_2D, texture_arrow->OpenGL_ID[0]);\n\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\tglTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);\n\n\tif (texture_arrow->isRGBA)\n\t\tgluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA8, texture_arrow->img_color->lenx, texture_arrow->img_color->leny, GL_RGBA, GL_UNSIGNED_BYTE, texture_arrow->img_all);\n\telse\n\t\tgluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGB8, texture_arrow->img_color->lenx, texture_arrow->img_color->leny, GL_RGB, GL_UNSIGNED_BYTE, texture_arrow->img_color->data);\n\n\tglEnable(GL_TEXTURE_2D);\n\n\tglPolygonMode(GL_FRONT, GL_FILL);\n\tglPolygonMode(GL_BACK, GL_FILL);\n\n\tglBegin(GL_QUADS);\n\tfor (int j = 0; j < 4; ++j) {\n\t\tswitch (j)\n\t\t{\n\t\tcase 0:\n\t\t\tglTexCoord2f(0, 0);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tglTexCoord2f(0, 1);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tglTexCoord2f(1, 1);\n\t\tcase 3:\n\t\t\tglTexCoord2f(1, 0);\n\t\t\tbreak;\n\t\t}\n\t\tglVertex3fv(vertex_list[index_list[5][j]]);\n\t}\n\tglEnd();\n\tglPolygonMode(GL_FRONT, GL_FILL);\t\t\t\t\t// front of a face is filled\n\tglPolygonMode(GL_BACK, GL_LINE);\n\tglDisable(GL_ALPHA_TEST);\n\tglDisable(GL_TEXTURE_2D);\n\n}\n```\n\n## 实现棋子移动\n\n获取收入修改棋子位置\n\n```\nif (inp->keys[KEY_CODE_W]) {\n\t\tchess_posZ += chees_move_speed;\n\t}\n\tif (inp->keys[KEY_CODE_S]) {\n\t\tchess_posZ -= chees_move_speed;\n\t}\n\tif (inp->keys[KEY_CODE_A]) {\n\t\tchess_posX += chees_move_speed;\n\t}\n\tif (inp->keys[KEY_CODE_D]) {\n\t\tchess_posX -= chees_move_speed;\n\t}\n```\n\n## 实现棋子跳跃\n\n通过两个bool变量，jump和falldown来检测棋子跳起下落状态\n\n```\nif (jump) {\n\t\tif (tim->global_timer_25_Hz)\t\n\t\t{\n\t\t\tif (!falldown) {\n\t\t\t\tchess_posY += 0.6f;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchess_posY -= 0.7f;\n\t\t\t}\n\n\t\t\tif (chess_posY > 20) falldown = true;\n\t\t\tif (chess_posY < 5) {\n\t\t\t\tchess_posY = 5;\n\t\t\t\tjump = false;\n\t\t\t\tfalldown = false;\n\t\t\t\t//debug(\"end jump\");\n\t\t\t}\n\t\t}\n\t\t\n\t}\n```\n\n## 实现类似劲舞团的输入响应\n\n用一个二维数组记录每次正确输入后，棋子的新位置，即每个棋盘所在位置。\n\n```\nstatic const int chess_routes[][2] = {\n\t0,20,\n\t25,20,\n\t50,20,\n\t50,35,\n};\n\n```\n\n用另一个二维数组记录，正确输入的键盘值序列。\n\n```\nstatic const int required_inputs[] = {\n\tKEY_CODE_2,\n\tKEY_CODE_8,\n\tKEY_CODE_6,\n\tKEY_CODE_4,\n};\n\n```\n\n每一次按方向键，检测是否输入正确，并处理\n\n```\nif (inp->keys[KEY_CODE_UP]) {\n\t\tif (required_inputs[chess_current_index] == KEY_CODE_8) {\n\t\t\tchess_posX = chess_routes[chess_current_index][0];\n\t\t\tchess_posZ = chess_routes[chess_current_index][1];\n\t\t\tchess_current_index++;\n\t\t\t//debug(\"%d\\n\", chess_current_index);\n\t\t}\n}\n\n```\n\n## 待解决问题\n\n主要问题是我把相机视角设置为45度俯视。跟随棋子移动有问题。如果能正确锁定棋子，可以让平台随机生成，每到一个新的平台就自动生成下个平台，并确保显示正确。现在因为视角追随问题，还不能实现。\n\n第二个问题是键盘输入。如果要实现跳一跳，要知道按了多久的空格键。有待解决。","tags":["OpenGL"]},{"title":"ORB-SLAM学习","url":"/2019/11/06/ORB-SLAM学习/","content":"\n# ORB-SLAM\n\n## 编译环境\n\nwin10+CMake+Visual Studio2017\n\n1. 使用vcpkg下载Eigen3，OpenCV，Pangolin包\n2. 下载ORB-SLAM.zip，解压，并用cmake编译\n\n## 运行ORB-SLAM\n\n1. 下载数据集\n2. 在windows命令行执行.\\mono_euroc <Chemin fichier vocabulaire> <Chemin vers le fichier de paramètres> <Chemin vers le répertoire contenant les images> <Chemin vers le fichier de timestamps> \n\n## 摄像机校准\n\n每个摄像机有一下投影参数：\n\n- longueurs focales焦距（fx，fy）（单位：像素pixels）\n- centre optique (cx,cy)\n- paramètres de distorsions radiale 辐射失真参数（k1,k2,[k3])\n- paramètres de distorsions tangentielle 切向失真参数（p1,p2)\n\n用于校准照相机\n\n校准需要比较已知3D点坐标（(les points de la mire : le damier qui vous est fourni，视点，棋盘坐标）和一系列由此棋盘得到的照片上对应的点\n\n\n\n步骤：\n\n1. 解压缩OpenCV_Calibration文件夹，cmake编译\n2. 使用棋盘来校准，此棋盘格的横向包含8个内部角（双曲线点），纵向包含6个角（如果需要，反之亦然）。 每个棋盘格盒宽30毫米。 \n3. 运行calibration程序，不加任何参数，来获得参考文件/用help（）也行\n4. 然后，使用计划要在工作空间中散布的至少10张照片来校准相机。 在“良好”校准期间，您的重新投影误差应小于0.5像素。 如果不是这种情况，请重复校准。 \n5. 通过calibration程序，您可以将相机矩阵（包含相机的固有参数（以像素为单位的焦距（fx，fy）和主要点（cx，cy））保存为.yml或.yaml类型的文件。 \n\n\n\n## 问答：\n\n1. 为什么对同样的数据执行ORB-SLAM从来不会得到同样的结果？\n\n   随机数和多线程\n\n\n\n1. KeyFrames的作用是什么？包含了什么？\n\n   - Camera parameters \n     -  Tiw:Camera extrinsics(Pose) \n     -  [Camera intrinsics] \n   - Featurepoints (2D points + descriptors )\n     -  是否与Mappoint相关联（3D点） \n   - Bag of Wordsdes features \n     -  用于在失去跟踪器的情况下进行重定位和闭环 \n\n   关键帧Ki (Key Frame) 存贮下列信息：\n   1， 相机的位姿 Tiw， 这是一个刚体转换， 用于转换世界坐标系中的点到相机坐标系。\n   2， 相机的内参， 包括焦距(focal length) 和主点 (principal point)\n   3， 帧中提取的ORB特征， 与一个地图点关联或者不关联， 如果畸变模型提供的话， 这个地图点的坐标是经过矫正没有畸变的。 \n\n   \n\n2. ORB-SLAM的地图包含KeyFrames和MapPoints。解释在什么条件下：\n\n   1. 一个新的KeyFrame会被创建\n\n   Spawn new Keyframe if: More than 20 frames have passed and local mapping is idle and current frames tracks at least 50 points and current frame tracks less than 90% point of kref 当超过20帧已经通过且local mapping是闲置状态且当前帧已经追踪到至少50个点且当前帧追踪少于kref中90%的点，则产生新的关键帧\n\n   \n\n   1. 一个KeyFrame会被销毁\n\n   Local Keyframes culling 关键帧删减\n\n   -  Discard keyframes in Kc whose 90% points are seen in 3 other keyframes 丢弃掉在其他三个关键帧中90%的点都可见的关键帧\n\n   \n\n   1. 一个新的MapPoint会被创建\n\n   \n\n   New map points creation 生成新的map points\n\n   -  Triangulate Ki matched ORBs from connected Keyframes (Kc) in visibility graph 从可见图中相连的关键帧中对应上ORB的点做三角化处理\n   -  Match ki unmatched ORBs in kc with epipolar constraint and triangulate them \n\n   \n\n   1. 一个MapPoint会被删除\n\n   Recent map points culling  最近map points删减\n\n   -  ~ Prune map points not visible in more than 3 connected keyframes in visibility graph 删除可见图中3个以上相连的关键帧中不可见的map points\n\n\n\n\n\n1. 此外，KeyFrames和MapPoints是否真的被销毁？\n\n\n\n\n\n1. ORB-SLAM的Essential Graph（关键图）是什么？它的作用是什么？\n\n   **Essential Graph**：基于位置优化的实时闭环控制。它通过生成树构建，生成树由系统、闭环控制链接和视图内容关联强边缘进行维护。\n\n   Essential Graph  \n\n   - 生成树“按权重链接“可见性图”的节点（nb映射公共点） \n   - 和与基本图的关键帧相关的词袋。 \n\n   \n\n   \n\n2. 什么时候，是出于什么原因以及在哪些数据上进行ORB-SLAM中的光束调整les ajustements de faisceaux？ \n\n   **Bundle Adjustment**（**BA**）：光束平差法，就是利用非线性最小二乘法来求取相机位姿，三维点坐标。在仅给定相机内部矩阵的条件下，对四周物体进行高精度重建。\n\n   Bundle Adjustment 可以将所观测的图像位置和预测的图像位置点进行最小 error 的映射（匹配），由很多非线性函数的平方和表示（error）。因此，最小化 error 由非线性最小二乘法实现。\n\n\n\n\n\n1. 在闭环过程中，由于哪种算法确定了当前镜头的姿势，我们确定了哪个KeyFrame最接近摄像机所看到的姿势。 \n\n   Essential graph optimization 基本图优化\n\n   -  Pose graph optimization on the Essential graph to distribute the loop closing error along the graph  对基本图进行位姿图优化，使闭环误差沿图分布 \n\n\n\n\n\n## 相关文章\n\n1. 什么是ORB？https://www.jianshu.com/p/420f8211d1cb\n\n2. ORB是怎么工作的？https://www.jianshu.com/p/9ee6b2145eaa\n\n3. ORB-SLAM中的ORB特征 https://zhuanlan.zhihu.com/p/61738607\n\n4. **Bag-of-words**：词袋算法 ，它是主要用来判断同一个地点是不是被重新访问过，它的算式在实现的原理上可以认为是对每一帧或者叫每一幅图用了很多单词来进行描述。\n\n   在实际应用中在这个词袋中使用的单词量会非常大，并且这些词在现实中并没有一个非常明确的物理含义；词袋方案现在主流所采取的方案之一，它做得最好的一方案叫 DBOW2，也是一个开源的方案。\n\n   **Bundle Adjustment**（**BA**）：光束平差法，就是利用非线性最小二乘法来求取相机位姿，三维点坐标。在仅给定相机内部矩阵的条件下，对四周物体进行高精度重建。\n\n   Bundle Adjustment 可以将所观测的图像位置和预测的图像位置点进行最小 error 的映射（匹配），由很多非线性函数的平方和表示（error）。因此，最小化 error 由非线性最小二乘法实现。\n\n   **Essential Graph**：基于位置优化的实时闭环控制。它通过生成树构建，生成树由系统、闭环控制链接和视图内容关联强边缘进行维护。\n\n5. 关于SLAM学习 https://github.com/GeekLiB/Lee-SLAM-source\n\n6. 重要概念：https://blog.csdn.net/fang_liu_yang/article/details/53488765\n\n7. 原文翻译1：https://blog.csdn.net/u011344545/article/details/78836717#commentBox\n\n8. 原文翻译2：https://blog.csdn.net/u012525173/article/details/70332125\n\n9. 项目源码：https://github.com/raulmur/ORB_SLAM\n\n\n\nORB_SLAM PATH_TO_VOCABULARY：是一种树型数据结构模型，`ORB-SLAM`里面主要用来做`回访(loop-closure)`检 测，对于不同数据集严格来说需要离线单独处理生成，但一般成像条件都差不多所以对于不同图像数据集可以使用相同的词汇数据文件（相当于一个数据库文件，方 便快速保存和查询视觉特征信息）。虽然是TXT文件，打开就是许多数字而已。 \n\n\n\nhttp://blog.leanote.com/post/gaunthan/ORB-SLAM-A-Versatile-and-Accurate-Monocular-SLAM-System-2\n\n\n\nhttps://blog.csdn.net/fuxingyin/article/details/53511439","tags":["计算机图形学","SLAM"]},{"title":"ORB-SLAM学习","url":"/2019/11/06/ORB-SLAM学学习/","content":"\n# ORB-SLAM\n\n## 编译环境\n\nwin10+CMake+Visual Studio2017\n\n1. 使用vcpkg下载Eigen3，OpenCV，Pangolin包\n2. 下载ORB-SLAM.zip，解压，并用cmake编译\n\n## 运行ORB-SLAM\n\n1. 下载数据集\n2. 在windows命令行执行.\\mono_euroc <Chemin fichier vocabulaire> <Chemin vers le fichier de paramètres> <Chemin vers le répertoire contenant les images> <Chemin vers le fichier de timestamps> \n\n## 摄像机校准\n\n每个摄像机有一下投影参数：\n\n- longueurs focales焦距（fx，fy）（单位：像素pixels）\n- centre optique (cx,cy)\n- paramètres de distorsions radiale 辐射失真参数（k1,k2,[k3])\n- paramètres de distorsions tangentielle 切向失真参数（p1,p2)\n\n用于校准照相机\n\n校准需要比较已知3D点坐标（(les points de la mire : le damier qui vous est fourni，视点，棋盘坐标）和一系列由此棋盘得到的照片上对应的点\n\n\n\n步骤：\n\n1. 解压缩OpenCV_Calibration文件夹，cmake编译\n2. 使用棋盘来校准，此棋盘格的横向包含8个内部角（双曲线点），纵向包含6个角（如果需要，反之亦然）。 每个棋盘格盒宽30毫米。 \n3. 运行calibration程序，不加任何参数，来获得参考文件/用help（）也行\n4. 然后，使用计划要在工作空间中散布的至少10张照片来校准相机。 在“良好”校准期间，您的重新投影误差应小于0.5像素。 如果不是这种情况，请重复校准。 \n5. 通过calibration程序，您可以将相机矩阵（包含相机的固有参数（以像素为单位的焦距（fx，fy）和主要点（cx，cy））保存为.yml或.yaml类型的文件。 \n\n\n\n## 问答：\n\n1. 为什么对同样的数据执行ORB-SLAM从来不会得到同样的结果？\n\n   随机数和多线程\n\n\n\n1. KeyFrames的作用是什么？包含了什么？\n\n   - Camera parameters \n     -  Tiw:Camera extrinsics(Pose) \n     -  [Camera intrinsics] \n   - Featurepoints (2D points + descriptors )\n     -  是否与Mappoint相关联（3D点） \n   - Bag of Wordsdes features \n     -  用于在失去跟踪器的情况下进行重定位和闭环 \n\n   关键帧Ki (Key Frame) 存贮下列信息：\n   1， 相机的位姿 Tiw， 这是一个刚体转换， 用于转换世界坐标系中的点到相机坐标系。\n   2， 相机的内参， 包括焦距(focal length) 和主点 (principal point)\n   3， 帧中提取的ORB特征， 与一个地图点关联或者不关联， 如果畸变模型提供的话， 这个地图点的坐标是经过矫正没有畸变的。 \n\n   \n\n2. ORB-SLAM的地图包含KeyFrames和MapPoints。解释在什么条件下：\n\n   1. 一个新的KeyFrame会被创建\n\n   Spawn new Keyframe if: More than 20 frames have passed and local mapping is idle and current frames tracks at least 50 points and current frame tracks less than 90% point of kref 当超过20帧已经通过且local mapping是闲置状态且当前帧已经追踪到至少50个点且当前帧追踪少于kref中90%的点，则产生新的关键帧\n\n   \n\n   1. 一个KeyFrame会被销毁\n\n   Local Keyframes culling 关键帧删减\n\n   -  Discard keyframes in Kc whose 90% points are seen in 3 other keyframes 丢弃掉在其他三个关键帧中90%的点都可见的关键帧\n\n   \n\n   1. 一个新的MapPoint会被创建\n\n   \n\n   New map points creation 生成新的map points\n\n   -  Triangulate Ki matched ORBs from connected Keyframes (Kc) in visibility graph 从可见图中相连的关键帧中对应上ORB的点做三角化处理\n   -  Match ki unmatched ORBs in kc with epipolar constraint and triangulate them \n\n   \n\n   1. 一个MapPoint会被删除\n\n   Recent map points culling  最近map points删减\n\n   -  ~ Prune map points not visible in more than 3 connected keyframes in visibility graph 删除可见图中3个以上相连的关键帧中不可见的map points\n\n\n\n\n\n1. 此外，KeyFrames和MapPoints是否真的被销毁？\n\n\n\n\n\n1. ORB-SLAM的Essential Graph（关键图）是什么？它的作用是什么？\n\n   **Essential Graph**：基于位置优化的实时闭环控制。它通过生成树构建，生成树由系统、闭环控制链接和视图内容关联强边缘进行维护。\n\n   Essential Graph  \n\n   - 生成树“按权重链接“可见性图”的节点（nb映射公共点） \n   - 和与基本图的关键帧相关的词袋。 \n\n   \n\n   \n\n2. 什么时候，是出于什么原因以及在哪些数据上进行ORB-SLAM中的光束调整les ajustements de faisceaux？ \n\n   **Bundle Adjustment**（**BA**）：光束平差法，就是利用非线性最小二乘法来求取相机位姿，三维点坐标。在仅给定相机内部矩阵的条件下，对四周物体进行高精度重建。\n\n   Bundle Adjustment 可以将所观测的图像位置和预测的图像位置点进行最小 error 的映射（匹配），由很多非线性函数的平方和表示（error）。因此，最小化 error 由非线性最小二乘法实现。\n\n\n\n\n\n1. 在闭环过程中，由于哪种算法确定了当前镜头的姿势，我们确定了哪个KeyFrame最接近摄像机所看到的姿势。 \n\n   Essential graph optimization 基本图优化\n\n   -  Pose graph optimization on the Essential graph to distribute the loop closing error along the graph  对基本图进行位姿图优化，使闭环误差沿图分布 \n\n\n\n\n\n## 相关文章\n\n1. 什么是ORB？https://www.jianshu.com/p/420f8211d1cb\n\n2. ORB是怎么工作的？https://www.jianshu.com/p/9ee6b2145eaa\n\n3. ORB-SLAM中的ORB特征 https://zhuanlan.zhihu.com/p/61738607\n\n4. **Bag-of-words**：词袋算法 ，它是主要用来判断同一个地点是不是被重新访问过，它的算式在实现的原理上可以认为是对每一帧或者叫每一幅图用了很多单词来进行描述。\n\n   在实际应用中在这个词袋中使用的单词量会非常大，并且这些词在现实中并没有一个非常明确的物理含义；词袋方案现在主流所采取的方案之一，它做得最好的一方案叫 DBOW2，也是一个开源的方案。\n\n   **Bundle Adjustment**（**BA**）：光束平差法，就是利用非线性最小二乘法来求取相机位姿，三维点坐标。在仅给定相机内部矩阵的条件下，对四周物体进行高精度重建。\n\n   Bundle Adjustment 可以将所观测的图像位置和预测的图像位置点进行最小 error 的映射（匹配），由很多非线性函数的平方和表示（error）。因此，最小化 error 由非线性最小二乘法实现。\n\n   **Essential Graph**：基于位置优化的实时闭环控制。它通过生成树构建，生成树由系统、闭环控制链接和视图内容关联强边缘进行维护。\n\n5. 关于SLAM学习 https://github.com/GeekLiB/Lee-SLAM-source\n\n6. 重要概念：https://blog.csdn.net/fang_liu_yang/article/details/53488765\n\n7. 原文翻译1：https://blog.csdn.net/u011344545/article/details/78836717#commentBox\n\n8. 原文翻译2：https://blog.csdn.net/u012525173/article/details/70332125\n\n9. 项目源码：https://github.com/raulmur/ORB_SLAM\n\n\n\nORB_SLAM PATH_TO_VOCABULARY：是一种树型数据结构模型，`ORB-SLAM`里面主要用来做`回访(loop-closure)`检 测，对于不同数据集严格来说需要离线单独处理生成，但一般成像条件都差不多所以对于不同图像数据集可以使用相同的词汇数据文件（相当于一个数据库文件，方 便快速保存和查询视觉特征信息）。虽然是TXT文件，打开就是许多数字而已。 \n\n\n\nhttp://blog.leanote.com/post/gaunthan/ORB-SLAM-A-Versatile-and-Accurate-Monocular-SLAM-System-2\n\n\n\nhttps://blog.csdn.net/fuxingyin/article/details/53511439","tags":["计算机图形学","SLAM"]},{"title":"Vision 3D","url":"/2019/11/06/Vision-3D/","content":"\n# Vision 3D\n\n##  传感器和测量方法 \n\n Mesures absolues \n\n- 深度信息得到物体的位置和转向\n- 体视法 和  摄影测量术 \n- temps de vol\n- 成焦或散焦的形状  结构光：结构光投影和激光三角测量 \n- 卷信息  断层摄影术 \n\n Mesures relatives\n\n-  对象表面的[局部]几何形状，但不是其位置 \n-  阴影（shading）形状 纹理（textures）形状\n\n##  3D重建方法 \n\n 选配 （自上而下）\n\n-  搜索已知对象类型的出现，并在场景空间中进行替换。 \n-  高级原语：预定义的对象 \n\n 建设 （自下而上）\n\n- 无需事先使用已知对象即可进行重建 \n- 使用低级重建原语，原语的程序集构造一个较高级的实体。 \n\n ## 3D重建的视觉部分\n\n Vision Active \n\n- Image + source （图像和源）\n\n- Laser （激光）\n\n  ![1572280064835](../img/未分类/1572280064835.png)\n\n- Tomographie 断层摄影术 \n\n  ![1572280091661](../img/未分类/1572280091661.png)\n\n- Shape from shading 阴影形状\n\n Vision Passive  \n\n-  利用图像之间的差异 \n\n![1572280192378](../img/未分类/1572280192378.png)\n\n-  多眼视觉（立体视觉） \n-  运动中的单眼视觉 \n\n##  Shape from Shading 阴影形状 \n\n 原理1：光度法 \n\n![1572280338294](../img/未分类/1572280338294.png)\n\n![1572280352725](../img/未分类/1572280352725.png)\n\n- a:  恒定且已知的反照率 \n- 已知光源 \n\n原理2： 扩散照明模型（朗伯型）  Lambertien \n\n![1572280494638](../img/未分类/1572280494638.png)\n\n![1572280479562](../img/未分类/1572280479562.png)\n\n原理3： 伪尺度照明模型 \n\n##  Shape / Depth from focus / defocus \n\n 问题：通过更改传感器的焦距或位置获得的2张或更多图像得到场景的3D估算\n\n Depth from focus (actif) 聚焦深度\n\n![1572293531473](../img/未分类/1572293531473.png) \n\n 离焦深度（passif） \n\n![1572293595010](../img/未分类/1572293595010.png)\n\n ## Reconstruction stéréo 立体重建\n\n Principe : Triangulation 三角测量\n\n![1572343874877](../img/未分类/1572343874877.png)\n\n需要校准\n\n##  Shape from structured light 结构光图形\n\n 激光投影：半径→点，平面→线，网格 \n\n激光平面 plan laser：\n\n-  柱面镜或旋转镜 \n-  已知方程\n-  校准好的相机 \n\n![1572344041720](../img/未分类/1572344041720.png)\n\n 一个或多个模式的投影 \n\n模式：\n\n-  干扰（光相干） \n-  投影 \n\n模式编码\n\n 两种模式之间只有1位的变化 \n\n##   Range Imaging : Time of Flight 距离成像：飞行时间 \n\nprincipe:lidar 激光雷达\n\n-  在持续时间d的t0处发出一个光脉冲 \n-  测量脉冲t0 + Dt（i，j）的反射光的每个像素（i，j）：Dt表示距离 \n\n技术\n\n-  TOF：反射信号的Dt的脉冲测量 \n-  相位：在频率f处的连续调制，反射信号的相移测量 \n\n##  Méthodes de reconstruction 重建方法\n\n Méthodes Globales :   处理所有图像。 \n\n- shape from XXX\n- 立体技术： 关联 / 弹性匹配 \n\n应用： 深度图 \n\n  Méthodes basées sur des primitives :  基于原语的方法：\n\n 仅处理从图像中提取的图元。 \n\n-  特别点   Points particuliers \n-  等高线  Contours \n-  地区  Régions \n\n 条件重建 \n\n##  Primitives 2D / 3D 原语\n\n Points d’intérêts  特别点\n\n- Sommet 顶点\n\n- 缺点： 相似度低的标准1 ， 可以使用其邻域来描述 \n\n- 优点： 点视差 及时差异\n\n Les contours 等高线\n\n-  Arête (segment, courbe) 棱边（段，曲线）\n-  优点： 强大的形态学标准 ； 轮廓上的差异 \n\n Les régions 地区   \n\n- Face (facette, carreau) 面\n- 优点：区域邻接图 \n- 缺点： 毛点差 差异不明显\n\n##  Calibration 校准\n\n 相机参数的估计 \n\n- 确定空间点经过的变换以获得图像的点 \n- 型号： Pin Hole1ou sténopé \n- 场景参考系=》照相机参考系  外在参数 \n- 照相机参考系=》图像参考系  内在参数 \n\n##  Calibration : Paramètres intrinsèques 校准：内在参数\n\n![1572346340641](../img/未分类/1572346340641.png)\n\n##  Distorsions 扭曲\n\n 发生在投影线性模型和与图像相关的点之间 \n\n来源：\n\n-  镜片瑕疵 \n-  镜头/矩阵未对准 \n\n形式：\n\n-  在径向变形中>>切向变形 \n-  如果考虑到径向和切向变形，（Du，Dv）可能是高度非线性的 \n\n 考虑到 ：\n\n- K1拒绝相机模型的参数并破坏模型的线性 \n\n- 独立于模型的失真估计和图像校正 \n- 我们将处理校正后的像素（u'，v'）： \n\n![1572346567239](../img/未分类/1572346567239.png)\n\n ## Paramètres extrinsèques 外部参数\n\n-  场景标记和相机标记之间的刚性移动 \n-  由包含已知3D点的校准图案表示的场景标记 \n-  通过记录图像中的特定点来估计瞄准器和摄像机之间的刚性位移 \n\n![1572346673746](../img/未分类/1572346673746.png)\n\n##  Calibration avec OpenCV \n\n![1572346699130](../img/未分类/1572346699130.png)\n\n ## Calibration stéréo \n\n...\n\n##  Feature points \n\n 目的：检测同一对象的其他图像中易于识别的兴趣点（特征点） \n\n 点检测：\n\n- 例子：SIFT：标度空间中的高斯差（DoG）的最小值和最大值 \n\n 点上的特征映射： \n\n-  描述符向量之间的欧式距离（通常为32、64或128个分量） \n\n 不变性 ：\n\n-  位移：位置不干预匹配 \n-  旋转：特征点沿渐变方向定向 \n-  尺度： 使用比例空间（ScaleSpace）可为检测到的特征点提供比例因子 \n\n局部不变性：\n\n- 光照\n- 仿射变换或投影 \n\n##  Descripteurs et Matching  描述符和匹配 \n\n Descripteurs \n\n 根据检测点的方向在附近的尺度上对邻域中的梯度方向描绘局部直方图 \n\n ![1572347247108](../img/未分类/1572347247108.png)\n\n Matching \n\n Entre points （点之间）：\n\n-  描述符之间的欧式距离 \n-  在k-d tree中寻找最优点 \n\n Entre ensembles de points （点集之间）: \n\n-  在mmc的意义上进行调整 \n-  de l’homographiecorrespondante (si nb pts >= 4 \n-  de la matrice essentielle (si nb pts >= 8) \n\n ##  分解为奇异值（SVD） \n\n##  Etude de cas : Recalage / cible pour augmentation \n\nTP1\n\n# SLAM\n\n## SLAM定义\n\n主要任务：\n\n- 跟踪：估计摄像机的姿势 \n\n  -  特征匹配 \n  -  Optical Flow 光流\n\n- 制图：环境重建 \n\n  -  三角测量 \n  -  深度参数化 \n\n- 其他任务 \n\n  - 重新定位 （ 失去追踪后 ）\n\n  - 闭环 \n\n  - 地图初始化 ： 深度参数化 & 延迟初始化/特定运动 \n\n    ![1572356949825](../img/未分类/1572356949825.png)\n\n定位：\n\n- 同义词： 视觉里程表  Visual Odometry \n- 根据...确定姿势 \n  -  2D / 3D映射：图像点 <-->3D点 =》 透视点（PnP） \n  -  3D（或2.5D）/ 3D匹配 ： 深度点↔3D点 =》 ICP：迭代最近点 \n\n 制图 /映射：\n\n 确定环境图 \n\n- 同义词： Reconstruction, Structure fromMotion (SfM)  重构，运动构造（SfM） \n- Mapping Local局部映射：\n  -  2D相机：了解两个图像之间的相对姿势 =》三角剖分=》3D点\n  -  Cameras2D :  了解相机之间的bases=》三角剖分=》3D点\n  -  Camera 3D :   carte de profondeur （深度图）⟹points 3D \n- Mapping Global \n  -   Pose + carte locale ⟹carte globale 姿势+本地地图⟹全球地图 \n\n## SLAM：架构\n\n Graph-BasedSLAM \n\n![1572357373749](../img/未分类/1572357373749.png)\n\n...\n\n##  Feature-Base vs Direct \n\n...\n\n##  Visual SLAM : Méthodes sparses 稀疏的\n\n 基于特征 \n\n- 优势：\n  -  基本要素加大要素(特征描述的容忍度和光照强度) \n  -  通过捆绑调整同时优化姿势和贴图 \n  -  计算更轻 \n- 劣势：\n  -  缺少纹理⇒没有points \n- 例子：\n  -  PTAM \n  -  ORB-SLAM \n\n##  VisualSLAM : Méthodes denses 密集的\n\n 基于像素 \n\n- 优势：\n  -   没有特征提取（在处理时间上花费更多） \n  -   毛状体，无纹理，或纹理重复(沥青质) \n  -   重建密集 \n- 劣势：\n  -   光度一致性限制了视点/特征匹配之间的基线：对需要大量“基线”的重建精度的影响 \n  -   对卷帘快门，自动增益和自动曝光敏感，因为它们对图像的影响需要光度学校准（在DSO中执行） \n  -   计算较重 \n- 例子：\n  -   DTAM \n  -   LSD-SLAM \n  -   DSO \n\n##  Visual SLAM : Autres méthodes \n\n- 优势：\n  -    混合方法（深度图像）+特征点（RGB图像） \n  -    重建（非常）密集 \n- 劣势：\n  -    3D地图尺寸 \n  -    传感器（Kinect）在大空间中的局限性 \n- 例子：\n  -    RGB-D SLAM \n\n##  Ajustement de faisceaux (Bundle Adjustment) 捆绑调整\n\n...\n\n##  ORB-SLAM：功能 \n\n![1572357935417](../img/未分类/1572357935417.png)\n\n-  所有阶段的ORB点和ORB描述符 \n   -  跟踪，映射，重定位和闭环。 \n-  大型环境中的实时跟踪和映射 \n   -  可测图:跟踪和地图绘制的唯一关于“可测区域”独立和“全球地图”的地图 \n-  Loop closinget relocalisatonen Temps Réel  \n   -  Essential Graph  \n      - 生成树“按权重链接“可见性图”的节点（nb映射公共点） \n      - 和与基本图的关键帧相关的词袋。 \n-  基于两个平行假设的评估进行稳健的初始化 \n   -  平面摄影场景 \n   -  或用于非平面场景的基本矩阵 \n-  用于点映射（3D）和关键帧选择的“适者生存”方法 \n   -  Suppression des keyframes redondantes 删除冗余的关键帧\n   -  删除冗余映射点 \n\n##  ORB-SLAM : Architecture \n\n![1572358251810](../img/未分类/1572358251810.png)\n\n##  ORB-SLAM：数据 \n\n- Map Points : pi\n\n  -  Position : Xw,i\n  -  视角方向 Viewing direction  :ni\n  -  最佳影像描述符 Best image descriptor  :Di\n  -  Viewing distance range [dmin..dmax]/ Best Descriptor \n\n- Keyframes \n\n  -  Camera parameters \n     -  Tiw:Camera extrinsics(Pose) \n     -  [Camera intrinsics] \n  -  Featurepoints (2D points + descriptors )\n     -  是否与Mappoint相关联（3D点） \n  -  Bag of Wordsdes features \n     -  用于在失去跟踪器的情况下进行重定位和闭环 \n\n- Organisation des Keyframes 关键帧的组织 \n\n  - 图：邻居关键帧图  Graphe : Graphe des Keyframesvoisines \n\n    -  Covisibility graph可视图：通过观察到的map points将关键帧链接在一起。\n    -  Essential graph 基本图:   关键帧通过它们共同观察到的映射点数链接在一起 \n    -  Spanning tree 生成树 \n\n    ![1572358707559](../img/未分类/1572358707559.png)\n\n##  ORB-SLAM : Tracking 追踪\n\n1.  ORB提取 \n2.  Tracking OK : Initial pose estimation from previous frame 追踪成功代表成功通过前一帧初始化相机位置预测\n    -   Match Mappoints from previous frame 通过比对前一帧的map points\n    -   Pose optimisation from correspondences 通过对应关系优化pose\n3.  Tracking Lost: Convert frame to Bow and query Keyframes 追踪丢失，把当前帧转换为bow并查询关键帧\n    -  Match map points from Keyframes Loop candidates 通过比对可能构成环路的关键帧和map points\n    -  If enough inliers: Pose optimisation 如果是正常值，优化pose\n4.  Track Local Map from Init. Pose Est. & Feature Matches 从初始化位置和匹配特征追踪local map\n    -  Project local map points into frame 将本地map points映射到frame\n       - k1：Keyframes sharing map points with current frame \n       - k2: Neighbors of  k1 in visibility graph \n       - kref ∈ k1: Keyframe sharing most map points with current frame \n       - Match map {K1，K2} points with current frame keypoints 上面三步获取map points，比较k1，k2点和当前帧关键点\n       - Pose optimisation 优化姿势\n5.  New Keyframe decision 新的关键帧的选择：\n    -  Spawn new Keyframe if: More than 20 frames have passed and local mapping is idle and current frames tracks at least 50 points and current frame tracks less than 90% point of kref 当超过20帧已经通过且local mapping是闲置状态且当前帧已经追踪到至少50个点且当前帧追踪少于kref中90%的点，则产生新的关键帧\n\n##  ORB-SLAM : Local Mapping \n\n1.   Keyframe insertion Ki 插入关键帧Ki\n     -  Update visibility graph and spanning tree 更新可见图和生成树\n     -  Compute BoW for keyframe 为关键帧计算Bow\n2.   Recent map points culling  最近map points删减\n     -  ~ Prune map points not visible in more than 3 connected keyframes in visibility graph 删除可见图中3个以上相连的关键帧中不可见的map points\n3.   New map points creation 生成新的map points\n     -  Triangulate Ki matched ORBs from connected Keyframes (Kc) in visibility graph 从可见图中相连的关键帧中对应上ORB的点做三角化处理\n     -  Match ki unmatched ORBs in kc with epipolar constraint and triangulate them \n4.   Local Bundle Adjustment  本地捆绑包调整 \n     -  Optimize ki，kc all map points seen in these frames =》all keyframes containing these points 优化ki，kc所有帧中可见map points=》确保所有关键帧都包含这些点\n5.   Local Keyframes culling 关键帧删减\n     -  Discard keyframes in Kc whose 90% points are seen in 3 other keyframes 丢弃掉在其他三个关键帧中90%的点都可见的关键帧\n\n##  ORB-SLAM: Loop Closing \n\n1.  Loop candidates detection 闭环可能性检测\n    -  Query DBoW for loop candidates keyframes withKi(except Kc):{kl}\n2.  Compute Similarity transformations between Ki and {kl}: Sil=[dx,dy,dz,rx,ry,rz,s]计算相似度转化\n    -  Retain loop closure candidate with most inliers in 3D/3D correspondences : Kl\n3.  Loop fusion 闭环融合\n    -  Correct Tiw with Sil and propagate to all neighbors of ki -> Align both sides of the loop 用Sil矫正Tiw并应用与所有临近点\n    -  Fuse map points of kl and ki +kc合并点\n    -  Update keyframes edges of the loop in the visibility graph  更新可见性图表中循环的关键帧边缘 \n4.  Essential graph optimization 基本图优化\n    -  Pose graph optimization on the Essential graph to distribute the loop closing error along the graph  对基本图进行位姿图优化，使闭环误差沿图分布 ","tags":["计算机图形学","SLAM"]},{"title":"Network Programming（复习）","url":"/2019/11/06/Network-Programming（复习）/","content":"\n## UDP  multicast\n\nclient/sender 不变，只需要把地D类广播组地址\n\nserver/revicer 需要添加结构体，设置socket\n\nstruct ip_mreq{\nstrtuct in_addr imr_multiaddr;\nstruct in_addr imr_interface;\n};\n\nstruct ip_mreq multicastGroupInfo;\nmulticastGrouInfo.imr_multiaddrs.s_addr=inet_addr(multicastIPAddr);\nmulticastGroupInfo.imr_interface.s_addr=htonl(INADDR_ANY);\n\nsetsockopt(sock,IPPROTO_IP,IP_ADD_MEMBERSHIP,(void*)&multicastGroupInfo,sizefo(multicastGroupInfo))<0)\n\n## UDP broadcast\n\nclient和server都只需要添加一句\nint boradcast=1;\nif(setsockopt(sock,SOL_SOCKET,SO_BROADCAST,&broadcast,sizeof(broadcast)<0)\n{\nperror();\n...\n}\n\n## Thread\n\nTCP 应用\nclient什么都不变\nserver在listen完后，while(1)中，accept（）后，创建一个thread，在thread中通信，关闭通信\n\n```\npthread_t threadId ;\nwhile(1){\ncode = pthread_create ( &threadId,  0, thread_handler, ( void * ) &new ) ;\nif ( code != 0 )\n\t\t\t{\n\t\t\t  perror ( \"Thread creation\" ) ;\n\t\t\t  close ( new ) ; \n\t\t\t  exit ( 1 ) ;\n\t\t\t} \n```\n\n pthread_create ( &threadId,  0, thread_handler, ( void * ) &new ) ;\n threadid是通过应用传递填充的thread id，0/null表示使用一个default 的 thread不加更改 \nmain以外定义thread_ha ndler\n（void*)&new  传给thread_handler参数\n返回0成功\n\n```\nvoid * thread_handler ( void * threadSock )\n{\nint sock = * ( int * ) threadSock ;\n\tint retThread ;\n\t\n\t。。。\n\t 通信recv（），mirror(),  send（）\n\t pthread_exit ( & retThread ) ;\n}\n```\n\nthread跑完exit就行了\n\n## select\n\nclient不变，server bind地址后，初始化一个desctiptor sockets set\nsocket listen\n在循环中，修改这个set","tags":["Network Programming","笔记"]},{"title":"Network Programming（六）","url":"/2019/11/06/Network-Programming（六）/","content":"\n# Network Programming（六）\n\n**网络编程进阶**\n\n## Network services网络服务\n\n服务与端口相关联\nports分三类：\n\n- well-known ports (0到1023)是基本服务(系统使用，需要超级用户特权)\n- referenced ports 参考端口(1024至49151)由IANA根据请求实体的申请为特定服务关联(在大多数系统上，普通用户可以使用注册端口)。\n- Dynamic or private or ephemeral ports   动态或私有或短暂端口(49152至65535)用于其他目的。\n\n## 与服务相关文件\n\nServices databasefile - /etc/services\n\n## servant 数据结构\n\n有set of functions用于连接服务列表\n其中两个返回一个指向struct的指针，这个struct包含关于service的信息。\n定义在<netdb.h>\nstruct servent{\nchar* s_name;\nchar** s_aliases;\nint s_port;\nchar* s_proto;\n}\n\n- s_name:官方服务名称\n- s_aliases:以NULL结尾的服务替代名称列表\n- s_port:按网络字节顺序给出的服务端口号\n- s_proto:与此服务一起使用的协议的名称\n\n## 获取服务信息（函数）\n\n函数一：\nstruct servent* getservbyname(const char* name,const char* proto)\nname是服务名，proto是协议名\n从数据库返回与使用协议原型匹配的服务名称的条目的servents结构的函数。\n如果protois为NULL，则将匹配任何协议。 \n如有必要，将打开与数据库的连接.\n定义在 netdb.h\n\n返回指向静态分配的servents结构的指针，\n如果发生错误或到达文件末尾，则返回NULL。\n\n函数二：\nstruct servent* getservbyport(int port,const char* proto)\nport是端口号\nproto是协议\n和上一个函数相似，不多加说明\n\n\n## 协议文件\n\n/etc/protocols\n\n## 协议数据结构\n\n同样定义在netdb.h\n\nstruct protoent{\nchar* p_name;\nchar** p_aliases;\nint p_proto;\n}\n\np_name: 协议的官方名\np_aliases: 以NULL结尾的协议其他代替名列表\np_proto: 协议号\n\n## 获取协议信息的函数\n\nstruct protoent* getprotobyname(const char* name)\n name是协议名\n\n struct protoent* getprotobynumber(int proto)\n proto是相关数字\n\n ## 主机文件\n\n /etc/hosts\n\n ## host数据结构\n\n struct hostent{\n char* h_name;\n char** h_aliases;\n int h_addrtype;\n int h_length;\n char** h_addr_list;\n }\n\n h_name: host官方名\n h_aliases: 代替名\n h_addrtype: 地址类型：AF_INET or AF_INET6\n h_length: 地址长度 bytes\n h_addr_list 列表指向主机网络地址的指针数组(按网络字节顺序)，由空指针终止。\n为了保证向后兼容性，h addr(h addr列表中与主机关联的第一个网络地址)被定义为:# define h_addr h_addr_list[0]\n\n## 获取主机信息\n\nstruct hostent* gethostbyname(const char* name)\n如果名称是一个IPv4地址，则不执行查找，gethostbyname()只是将名称复制到返回主机结构的h _ name字段中，并将它的结构添加到h _ addr _ list[0]字段中。\n返回值：hostent structure 出错时，null，h_errno(在netdb.h中定义)变量保存一个错误号。使用herror(char* s)产生相应的错误信息\n\nstruct hostent* gethostbyaddr(const void* addr, socklen_t len,int type)\naddr : IP地址\nlen：长度\ntype： AF_INET or AF_INET6  (#include <sys/socket.h>)\n\nhost_address参数是一个指针，指向一个类型取决于地址类型的结构，例如地址类型AF_INET的结构地址*(可能是通过调用inet_addr(3))获得的。\n返回值：hostent structure 出错时，null，出错时，h_errno(在netdb.h中定义)变量保存一个错误号。使用herror(char* s)产生相应的错误信息\n\n## UDP sockets的multicast多播和broadcast广播\n\n怎么发送data给多个接收者？\n法一：unicast data的copy到每个接收者（没有效率）\n法二：使用network support\nBroadcasting:发送一个datagram所有在到达的子网上的主机都会接受\n子网中的每台主机都必须通过UDP层处理数据报，以防万一，即使主机不参与应用程序。这也可能会造成过多的处理负载\nMulticasting：一个message仅发送给主机的子集\n任何人都可以加入多播组\n任何人都可以发送给多播组\n\n**只有UDP sockets可以广播和多播**\n\n- 两种广播地址：子定向广播地址(example192.168.66.255 for a subnet192.168.66.0/24）受限的广播地址255.255.255.255\n- 不应该由路由器转发\n- 为了使用广播，必须更改套接字的选项\n\n```\nint breadcastPermission=1;\nsetsockopt(sock,SOL_SOCKET,SO_BROADCAST,(void*)&broadcastPermission,sizeof(broadcastPermission));\n```\n\n**SO_BROADCAST**很重要\n\n\n- 对于多播，使用D类地址：224.0.0.0 to 239.255.255.255; IPv4地址的前四位设置为1110\n- 有一些特殊的组播组 - “众所周知的组播组”，由于分配给它们的特殊用途，不应在应用程序中使用：\n- 224.0.0.1是全主机组。\n  –224 . 0 . 0 . 2是全路由器组。\n  –224 . 0 . 0 . 4是全DVMRP路由器，224.0.0.5是全OSPF路由器，224.0.013是全无源互调路由器，等等。\n  –224 . 0 . 0 . 0至224.0.0.255保留用于本地目的(作为管理和维护任务)\n  –239 . 0 . 0 . 0至239.255.255.255也保留用于管理目的。\n\n- 为了发送一个多播UDP数据报：\n  - 打开一个UPDsocket，填充D类地址\n  - 不需要改变socket options\n  - 需要设置TTL（time-to-live），为了限制数据包中继的跳数\n    - setsockopt(sock,IPPROTO_IP,IP_MULTICAST_TTL,(void*)&multicastTTL,sizeof(multicastTTL))\n    - 当TTL为0，packet被丢弃\n  - 使用setsockopt( )关闭环回，这样可以避免接收正在发送的数据包\n\n- 为了接受一个多播UDP数据报：\n  -创建一个SOCK_DGRAM socket()\n  -bind一个多播地址和port\n  - 使用setsockopt()加入多播组，设置**IP_ADD_MEMBERSHIP**\n    - 这告诉系统在网络上接收目的地是多播组地址的数据包。\n    - 使用ip _ mreq structureto指定多播组地址和要使用的接口(使用0.0.0.0表示任何接口)\n  - 使用recvfrom()来接受多播数据报\n\n例子如下\n![ ](../img/network programming/UDP多播例子.png  \"UDP多播例子\")\n\nUDP多播设置\n![ ](../img/network programming/UDP多播设置.png  \"UDP多播设置\")","tags":["Network Programming","笔记"]},{"title":"Network Programming（五）","url":"/2019/11/06/Network-Programming（五）/","content":"\n# Network Programming（五）\n\n之前的例子都是TCP的应用，之后这两个例子是关于UDP的\n\n## UDPsocket使用模式\n\n![ ](../img/network programming/UDP.png  \"UDP\")\n\n## 实例五\n\n写一个client和server，server显示client的端口号和地址，并返回client发送过去的message的镜像（如client发送ALO，server返回OLA）\n\n```\n客户端\n# include <sys/socket.h>\n# include <netdb.h>\n# include <stdio.h>\n# include <stdlib.h>\n# include <string.h>\n# include <unistd.h>\n# include <arpa/inet.h> //inet_addr\n\n# define SERVERPORT 9999\n# define LOCALHOST \"127.0.0.1\"\n\n# define MYMSGLEN   2048\n\n\nvoid question ( int sock, char * msg, struct  sockaddr_in  * addr, struct  sockaddr_in  * from  )\n{\n\tint code, length, ret ;\n\tsocklen_t len;\n\t\n\t// Send the length of the string.\n\tlength = strlen ( msg ) ; // + 1 ;\n\t\n\t// Send the string of characters.\n\tlen = sizeof ( struct  sockaddr_in  ) ;\n\tcode = sendto ( sock, msg, length, 0, ( struct sockaddr * ) addr, len ) ;\n\tif ( code == -1 ) {\n\t\tperror ( \"sendto\" ) ;\n\t\tclose ( sock ) ; \n\t\texit ( 1 ) ;\n\t}\n\n\t// Wait for the answer.\n\tmemset ( msg, 0, length ) ;\n\tlen = sizeof ( * from ) ;\n\t\n\tcode = recvfrom ( sock, ( char * ) msg, length, 0, ( struct sockaddr * ) from, & len ) ;\n\tif ( code == -1 ) {\n\t\tperror ( \"recvfrom\" ) ;\n\t\tclose ( sock ) ;\n\t\texit ( 1 ) ;\n\t}\n\n\t// Empty message!!!! 0 value returned in UDP mode does not mean closing a connection since there is no connection\n\t// We release the resource and exit the program anyway\n\tif ( code == 0 )\n\t{\n\t  // Release ressources.\n\t  code = close ( sock ) ;\n\t  if ( code == -1 ) {\n\t\t  perror ( \"close\" ) ;\n\t\t \n\t  }\n\t  exit ( 1 ) ;\n\t}\n\t \n}\n\n\nint main ( int argc, char * argv [ ] )\n{\n\tint item ;\n\t socklen_t len;\n\t// Ask for the string of characters.\n\tchar string [ MYMSGLEN ] ;\n\t\n\t\n\t// Create UDP socket and init server address structure.\n\tint sock ;\n\tsock = socket ( AF_INET, SOCK_DGRAM, 0 ) ;\n\tif ( sock == -1 ) {\n\t\tperror ( \"socket\" ) ;\n\t\texit ( 1 ) ;\n\t}\n\n\n\n\t// Initialisation of the sockaddr_in data structure\n\n\tstruct sockaddr_in addr ;\n\t\n\t\n\tmemset ( & addr, 0, sizeof ( struct sockaddr_in ) ) ;\n\taddr . sin_family = AF_INET ;\n\taddr . sin_port = htons ( SERVERPORT ) ;\n\taddr . sin_addr . s_addr = inet_addr ( LOCALHOST ) ;\n\n\t\n\twhile ( 1 )\n\t{\n\t  memset ( string, 0, sizeof( string ) ) ;\n\t\n\t  printf ( \"\\n----------------------------------------------------------------------\\n\" ) ;\n\t  printf ( \"Please type a message to transfer for processing:\" ) ;\n\t  item = scanf ( \"%[^\\n]%*c\", string ) ;  //reads a hole line till a new line feed\n\t  //This is in case of empty message\n\t  if ( item == 0 )\n\t  {\n\t    scanf(\"%*c\");\n\t    continue;      \n\t  } \n   \n\t  printf ( \"The message being sent is: '%s' \\n\", string ) ;\n\t  printf( \"----------------------------------------------------------------------\\n\" ) ;\n\n\t\n\t  if ( !memcmp ( \"quit#\", string, 5 ) )\n\t  {\n\t   printf ( \" Client exiting upon user request \\n\" ) ; \n\t   close ( sock ) ;\n\t   exit ( 1 ) ;\n\t  }\n\t  \n\t  // Ask the question and wait for the answer.\n\t  struct sockaddr_in from ;\n\t  \n\t  question ( sock, string, & addr, & from ) ;\n\t\n\t\n\t  // Display the result.\n\t  printf ( \"\\n----------------------------------------------------------------------\\n\" ) ;\n\t  printf ( \"The processed message is received from server %s, with port number: %d \\n\" , inet_ntoa( from.sin_addr ), ntohs( from.sin_port ) ) ;\n\n\t  printf ( \"The message  is : %s\\n\", string ) ;\n\t\n\t  printf ( \"----------------------------------------------------------------------\\n\" ) ;\n\t}\n\t\n\treturn ( 0 ) ;\n}\n```\n\n客户端编程思路：\n第一步：创建socket，**注意：sock = socket ( AF_INET, SOCK_DGRAM, 0 ) ;这时模式是SOCK_DGRAM**\n第二步，bind地址：与TCP相似地址存在sockaddr_in中，记住先把addr各位置0\n第三步，在while（1）中，不断读入字符串scanf(\"%*[^\\n]%*c\")，这里用到了正则表达式**%*[^ n]扫描所有内容，直到 \\n，但不扫描 \\n。星号(*)告诉它丢弃所扫描的任何内容。%*c扫描单个字符，在本例中，该字符是%*[^\\n]所剩余的\\n。星号指示scanf放弃已扫描的字符。**\n第四步，判断client是否输入”quit#\"\n第五步，调用question（），其中利用sendto向server发送msg，利用recvfrom从server接受。\n第六步，输出信息\n\nssize_t sendto(int sockfd,const void* buf,size_t len,int flags,const struct sockaddr* dest_addr,socklen_t addrlen);\n用来向另一个socket传送message\n需要指定目标地址\nflags：特殊设置，通常是0\n返回传送的字节数\n-1 error\n\n\nssize_t recvfrom(int sockfd,void* buf,size_t len,int flags,struct sockaddr* src_addr, socklen_t* addrlen);\n用来从一个socket接受message\nsrc_addr调用之后被填充\nflags：特殊设置，通常是0\n返回接受的字节数\n-1 error\n\n```\n服务器\n# include <sys/socket.h>\n# include <netdb.h>\n# include <stdio.h>\n# include <stdlib.h>\n# include <string.h>\n# include <unistd.h>\n# include <arpa/inet.h> //inet_addr\n\n# define  SERVERPORT  9999\n# define  LOCALHOST   \"127.0.0.1\"\n\n# define MYMSGLEN   2048\n\n\nvoid mirror ( char * msg )\n{\n\tint i ;\n\tint length ;\n\tchar car ;\n\t\n\tlength = strlen ( msg ) ;\n\t\n\tfor ( i = 0 ; i < ( length / 2 ) ; i ++ )\n\t{\n\t    car = msg [ i ] ;\n\t    msg [ i ] = msg [ length - i - 1 ] ;\n\t    msg [ length - i - 1 ] = car ;\n\t}\n}\n\n\n\nvoid answer_client ( int sock )\n{\n\t struct  sockaddr_in  from ;\n\tsocklen_t len;\n\t// Receive the length of the string.\n\tint code, length ;\n\tchar string  [ MYMSGLEN ];\t\n\t\n\t// Receive the string of characters.\t\n\t\n\twhile ( 1 )\n\t{\n\t  memset ( string, 0, MYMSGLEN );\n\t  \n\t  len = sizeof ( from ) ;\n\t  \n\t  length = recvfrom ( sock, string, MYMSGLEN, 0,( struct sockaddr * )  & from, & len ) ;\n\t\n\t  if ( length == -1 ) {\n\t    perror ( \"recvfrom\" ) ;\n\t    close ( sock ) ;\n\t    exit ( 1 ) ;\n\t  }\n\t\n\t  printf ( \"Request received from: %s, with port number: %d \\n\" , inet_ntoa( from.sin_addr ), ntohs( from.sin_port ) ) ;\n\n\t  if ( length == 0 ) {\n\t    printf(\"Ignoring empty message received \\n\");\n\t    \n\t    continue ;\n\t   }\n\t   printf ( \"Received message: %s\\n\", string ) ;\n\t  // Check the string of characters.\n\t\t  \n\t  mirror ( string ) ;\n\n\t  // Prepare the answer\t\n\t\n\t  // Return the answer.\n\t  len = sizeof ( from ) ;\n\t  code = sendto ( sock, string, length, 0, ( struct sockaddr * ) & from, len ) ;\n\t  if ( code == -1 ) {\n\t    perror ( \"sendto\" ) ;\n\t    close ( sock ) ;\n\t    exit ( 1 ) ;\n\t  }\n\n\t// Release ressources.\n\t\n\t}\n\t\n\t\n}\n\nint naming ( )\n{\n\t// Socket creation.\n\tint sock ;\n\tsock = socket ( AF_INET, SOCK_DGRAM, 0 ) ;\n\tif ( sock == -1 ) {\n\t\tperror ( \"socket\" ) ;\n\t\texit ( 1 ) ;\n\t}\n\n\t// Reuse the same port (useful when developing...).\n\tint code, enable = 1;\n\tcode = setsockopt ( sock, SOL_SOCKET, SO_REUSEADDR, & enable, sizeof ( int ) ) ;\n\tif (code == -1 ) {\n\t\tperror ( \"setsockopt\" ) ;\n\t\tclose ( sock ) ;\n\t\texit ( 1 ) ;\n\t}\n\n\t// Initialisation of the sockaddr_in data structure.\n\tstruct sockaddr_in addr ;\n\tmemset ( & addr, 0, sizeof ( struct sockaddr_in ) ) ;\n\taddr . sin_family = AF_INET ;\n\taddr . sin_port = htons ( SERVERPORT ) ;\n\taddr . sin_addr . s_addr = inet_addr ( LOCALHOST ) ;\n\n\t// Name the socket.\n\tcode = bind ( sock, ( struct sockaddr * ) & addr, sizeof ( struct sockaddr_in ) ) ;\n\tif ( code == -1 ) {\n\t\tperror ( \"bind\" ) ;\n\t\tclose ( sock ) ;\n\t\texit ( 1 ) ;\n\t}\n\n\t// Return the socket ID.\n\treturn ( sock ) ;\n}\n\nint main ( int argc, char * argv [ ] )\n{\n\t// Name the socket.\n\tint sock ;\n\t\n\tsock = naming ( ) ;\n\t\n\n\t// Answering incoming requests.\n\tprintf ( \"UDP Mirror server ready to process client requests \\n\" ) ;\n\tanswer_client ( sock ) ;\n\t\t     \n\n\t// This point in the program will never be reached.\n\treturn ( 0 ) ;\n}\n```\n\n服务器编程思路：\n第一步：编写服务器处理程序，这里就是mirror（）\n第二步：通过naming创建socket，设置和bind地址，这一步可以和client一样写在main中\n第三步：调用answer_client()，在while（1）中，接受client的msg，处理，返回结果。","tags":["Network Programming","笔记"]},{"title":"Network Programming（四）","url":"/2019/11/06/Network-Programming（四）/","content":"\n# Network Programming（四）\n\n## Struct\n\n1. struct sockaddr{\n   sa_family_t sa_family;\n   char sa_data[14];}\n\n对于IPv4\n\n2. struct sockaddr_in{\n   sa_family_t  sin_family;\n   in_port_t sin_port;\n   struct in_addr sin_addr;};\n   这个就是我们常用来填充的结构体\n3. struct in_addr{\n   uint32_t s_addr;\n   };\n   s_addr通常用到htonl（INADDR_ANY);\n   htonl就是把本机字节顺序转化为网络字节顺序\n   htonl 是针对32位，4个字节而言\n   htons 是针对16位，2个字节而言\n   htonl()--\"Host to Network Long\"\n   ntohl()--\"Network to Host Long\"\n   htons()--\"Host to Network Short\"\n   ntohs()--\"Network to Host Short\n\n## 实例三\n\n写一个服务器用来接受多个客户端的消息，并判断这个消息是否是回文，返回结果。写一个客户端，用来发送消息，用户输入“quit#”退出连接。\n\n```\n客户端\n# include <sys/socket.h>\n# include <arpa/inet.h>\n# include <netdb.h>\n# include <stdio.h>\n# include <stdlib.h>\n# include <string.h>\n# include <unistd.h>\n\n\n# define SERVERPORT 8888\n# define LOCALHOST \"127.0.0.1\"\n# define MYMSGLEN  2048\n\nint question ( int sock, char * string )\n{\n\tint code, length, ret ;\n\n\t// Send the length of the string.\n\tlength = strlen ( string ) + 1 ;\n\t\n\t// Send the string of characters.\n\tcode = send ( sock, string, length, 0 ) ;\n\tif ( code == -1 ) {\n\t\tperror ( \"send\" ) ;\n\t\texit ( 1 ) ;\n\t}\n\tprintf ( \"Message sent to server, waiting for the answer ..... \\n \" ) ;\n\t// Wait for the answer.\n\tcode = recv ( sock, & ret, sizeof ( int ), 0 ) ;\n\tif ( code == -1 ) {\n\t\tperror ( \"recv\" ) ;\n\t\texit ( 1 ) ;\n\t}\n\n\t//ret返回服务器判断结果\n\treturn ret ;\n}\n\nint connecting ( )\n{\n\t// Socket creation.第一步，创建socket\n\tint sock ;\n\tsock = socket ( AF_INET, SOCK_STREAM, 0 ) ;//TCP直连\n\tif ( sock == -1 ) {\n\t\tperror ( \"socket\" ) ;\n\t\texit ( 1 ) ;\n\t}\n\n\t// Initialisation of the sockaddr_in data structure\n\n\tstruct sockaddr_in addr ;\n\tsocklen_t len ;\n\t\n\tstruct sockaddr_in newAddr ;\n\tstruct sockaddr_in peerAddr ;\n\t\n\t//在初始化地址时，最好先把地址各位归0\n\tmemset ( & addr, 0, sizeof ( struct sockaddr_in ) ) ;\n\taddr . sin_family = AF_INET ;\n\t//SERVERPORT 8888\n\t//之所以需要这些函数是因为计算机数据表示存在两种字节顺序：网络字节顺序NBO(Network Byte Order)与主机字节顺序HBO(Host Byte Order)\n\t//htons()--\"Host to Network Short\"\n\taddr . sin_port = htons(SERVERPORT) ;\n\t//LOCALHOST \"127.0.0.1\"\n\t//in_addr_t inet_addr(const char* strptr);\n//将点分十进制变成IP地址，-1 failure，不能用于广播（255.255.255.2555）\n\taddr . sin_addr . s_addr = inet_addr(LOCALHOST) ;\n\n\t// Name the socket.\n\tint code ;\n\tcode = connect ( sock, ( struct sockaddr * ) & addr, sizeof ( struct sockaddr_in ) ) ;\n\tif ( code == -1 ) {\n\t\tperror ( \"connect\" ) ;\n\t\tclose ( sock ) ;\n\t\texit ( 1 ) ;\n\t}\n\n\tlen = sizeof ( struct sockaddr_in ) ;\n\t//获取sock绑定的本地地址\n\tcode = getsockname ( sock, ( struct sockaddr * ) & newAddr, & len ) ;\n\tif ( code == -1 ) {\n\t      perror ( \"getsockname\" ) ;\n\t      close ( sock ) ;\n\t\t\n\t      exit ( 1 ) ;\n\t}\n\tlen = sizeof ( struct sockaddr_in ) ;\n\t//在TCP的服务器端accept成功后，通过getpeername()函数来获取当前连接的客户端的IP地址和端口号。\n\tcode = getpeername ( sock, ( struct sockaddr * ) & peerAddr, & len ) ;\n\tif ( code == -1 ) {\n\t      perror ( \"getpeername\" ) ;\n\t      close ( sock ) ;\n\t      exit ( 1 ) ;\n\t}\n\t\n\t//char* inet_ntoa(struct in_addr invader);\n//将IP地址转换为ASCII点十进制符号\n\tprintf ( \" The local address bound to the current socket --> %s:%d \\n\" , inet_ntoa ( newAddr.sin_addr ), ntohs ( newAddr.sin_port )  ) ;\n\tprintf ( \" The peer address bound to the peer socket --> %s:%d \\n\" , inet_ntoa ( peerAddr.sin_addr ), ntohs ( peerAddr.sin_port )  ) ;\n\t// Return the socket ID.\n\treturn sock ;\n}\n\nint main ( int argc, char * argv [ ] )\n{\n\t// Ask for the string of characters.\n\tchar string [ MYMSGLEN ];\n\t\n\t\n\n\t// Connect to the server.\n\tint sock ;\n\tsock = connecting ( ) ;\n\t//利用connecting（）实现socket创建，connect\n\n\t// Ask the question and wait for the answer.\n\tint ret ;\n\twhile ( 1 )\n\t{\n\t//每次用到字符串前，先初始化为0\n\t  memset ( string, 0, sizeof( string ) );\n\t  printf ( \"Type a string to check: \" ) ;\n\t  scanf ( \"%s\", string ) ;\n\t  \n\t  //memcmp若两个字符串完全相同返回0，socket关闭\n\t  if ( !memcmp ( \"quit#\", string, 5 ) )\n\t    {\n\t      printf ( \" Client exiting upon user request \\n\" ) ; \n\t      close ( sock ) ;\n\t      exit ( 1 ) ;\n\t    }\n\n\t//在question函数中实现与服务器间的通信send，recv\n\t  ret = question ( sock, string ) ;\n\n\t  // Display the result.\n\t  if (ret == 1)\n\t    printf ( \"Reply received: '%s' is a palindrom.\\n\", string ) ;\n\t  else\n\t    printf ( \"Reply received: '%s' is not a alindrom.\\n\", string );\n\t}\n\t\n\treturn ( 0 ) ;\n}\n```\n\n```\n服务器\n# include <sys/socket.h>\n# include <arpa/inet.h>\n# include <netdb.h>\n# include <stdio.h>\n# include <stdlib.h>\n# include <string.h>\n# include <unistd.h>\n\n# define  SERVERPORT  8888\n# define  LOCALHOST   \"127.0.0.1\"\n# define  MYMSGLEN    2048\n\n//功能函数，用来判断是否是回文\nint palindrom ( char * s )\n{\n\tchar * t = s + strlen ( s ) - 1 ;\n\t\n\twhile ( * s == * t )\n\t\ts ++, t -- ;\n\treturn s >= t ;\n}\n\n//在无限循环中实现客户端数据的接受recv，处理palindrom和返回结果send\nint answer_client ( int sock ) \n{\n\t// Receive the length of the string.\n\tint code, length ;\n\tchar string  [ MYMSGLEN ];\n\t\n\twhile ( 1 )\n\t{\n\t  // Receive the string of characters.\n\t  printf ( \"Waiting for a string to process....\\n\" ) ;\n\t  memset ( string, 0, sizeof( string ) );\n\t  length = recv ( sock, string, sizeof ( string ), 0 ) ;\n\t\n\t  if ( length == -1 ) {\n\t\tperror ( \"recv\" ) ;\n\t\tcode = close ( sock ) ;\n\t\tif ( code == -1 ) \n\t\t  perror ( \"close\" ) ;\n\t\treturn ( -1 ) ;\n\t  }\n\n\t  if ( length == 0 ) {\n\t    \n\t\t// Connection closed by remote peer, release ressources.\n\t\tprintf ( \"Connection closed by remote peer ....\\n\" ) ;\n\t\tcode = close ( sock ) ;\n\t\tif ( code == -1 ) {\n\t\t  perror ( \"close\" ) ;\n\t\t  return ( -1 ) ;\n\t\t  \n\t\t}\n\t\treturn ( 0 ) ;\n\t  }\n\t  \n\t  printf ( \"Going to process the received string '%s'\\n\", string ) ;\n\t  \n\t  // Check the string of characters.\n\t  int ret ;\n\t  ret = palindrom ( string ) ;\n\n\t  \n\t  // Return the answer.\n\t  printf ( \"Processing done, sending back the answer\\n\" ) ;\n\t  code = send ( sock, & ret, sizeof ( int ), 0 ) ;\n\t  if ( code == -1 ) {\n\t\tperror ( \"send\" ) ;\n\t\tclose ( sock ) ;\n\t\treturn ( -1 ) ;\n\t  }\n\t}\n}\n\n//socket创建+设置+bind地址\nint naming ( )\n{\n\t// Socket creation.\n\tint sock ;\n\t//AF_INET：IPv4 protocols。定义在<sys/socket.h>中，\n\t//SOCK_STREAM: connected communication withend to end control flow\n\tsock = socket ( AF_INET, SOCK_STREAM, 0 ) ;\n\tif ( sock == -1 ) {\n\t\tperror ( \"socket\" ) ;\n\t\texit ( 1 ) ;\n\t}\n\n\t// Reuse the same port (useful when developing...).\n\tint code, enable = 1;\n\t//SO_REUSEADDR：Allows other sockets to bind() to this port\n\tcode = setsockopt ( sock, SOL_SOCKET, SO_REUSEADDR, & enable, sizeof ( int ) ) ;\n\tif (code == -1 ) {\n\t\tperror ( \"setsockopt\" ) ;\n\t\tclose ( sock ) ;\n\t\texit ( 1 ) ;\n\t}\n\n\t\n\tcode = setsockopt ( sock, SOL_SOCKET, SO_REUSEPORT, & enable, sizeof ( int ) ) ;\n\tif (code == -1 ) {\n\t\tperror ( \"setsockopt\" ) ;\n\t\tclose ( sock ) ;\n\t\texit ( 1 ) ;\n\t}\n\t\n\t// Initialisation of the sockaddr_in data structure.\n\tstruct sockaddr_in addr ;\n\tmemset ( & addr, 0, sizeof ( struct sockaddr_in ) ) ;\n\taddr . sin_family = AF_INET ;\n\taddr . sin_port = htons(SERVERPORT) ;\n\taddr . sin_addr . s_addr = inet_addr(LOCALHOST) ;\n\n\t// Name the socket.\n\tcode = bind ( sock, ( struct sockaddr * ) & addr, sizeof ( struct sockaddr_in ) ) ;\n\tif ( code == -1 ) {\n\t\tperror ( \"bind\" ) ;\n\t\tclose ( sock ) ;\n\t\texit ( 1 ) ;\n\t}\n\n\t// Return the socket ID.\n\treturn sock ;\n}\n\nint main ( int argc, char * argv [ ] )\n{\n\t// Name the socket.\n\tint sock ;\n\tsock = naming ( ) ;\n\n\t// Set up listening on the port.\n\tint code ;\n\t//backlog为0时在linux上表明允许不受限制的连接数，这是一个缺陷，因为它可能会导致SYN Flooding(拒绝服务型攻击)\n\tcode = listen ( sock, 0 ) ;\n\tif ( code == -1 ) {\n\t\tperror ( \"listen\" ) ;\n\t\tclose ( sock ) ;\n\t\texit ( 1 ) ;\n\t}\n\n\t// Wait for incoming connections and deal with the clients.\n\tint new ;\n\tsocklen_t len ;\n\tstruct sockaddr_in addr ;\n\tstruct sockaddr_in newAddr ;\n\tstruct sockaddr_in peerAddr ;\n\t\n\tfor ( ; ; ) {\n\t\tprintf ( \"Server waiting for a new connection \\n\" ) ;\n\t\tlen = sizeof ( struct sockaddr_in ) ;\n\t\t//获取到用来与客户端通信的socket\n\t\tnew = accept ( sock, ( struct sockaddr * ) & addr, & len ) ;\n\t\tif ( new == -1 ) {\n\t\t\tperror ( \"accept\" ) ;\n\t\t\tclose ( sock ) ;\n\t\t\texit ( 1 ) ;\n\t\t}\n\t\tprintf ( \" A new connection from --> %s:%d \\n\" ,inet_ntoa ( addr.sin_addr ), ntohs ( addr.sin_port )  ) ;\n\t\tlen = sizeof ( struct sockaddr_in ) ;\n\t\tcode = getsockname ( new, ( struct sockaddr * ) & newAddr, & len ) ;\n\t\tif ( code == -1 ) {\n\t\t      perror ( \"getsockname\" ) ;\n\t\t      close ( sock ) ;\n\t\t      close ( new ) ;\n\t\t      exit ( 1 ) ;\n\t\t}\n\t\tlen = sizeof ( struct sockaddr_in ) ;\n\t\tcode = getpeername ( new, ( struct sockaddr * ) & peerAddr, & len ) ;\n\t\tif ( code == -1 ) {\n\t\t      perror ( \"getpeername\" ) ;\n\t\t      close ( sock ) ;\n\t\t      close ( new ) ;\n\t\t      exit ( 1 ) ;\n\t\t}\n\t\t\n\t\tprintf ( \" The local address bound to the new socket --> %s:%d \\n\" , inet_ntoa ( newAddr.sin_addr ), ntohs ( newAddr.sin_port )  ) ;\n\t\tprintf ( \" The peer address bound to the new socket --> %s:%d \\n\" , inet_ntoa ( peerAddr.sin_addr ), ntohs ( peerAddr.sin_port )  ) ;\n\t\t\n\t\t//以上打印连接信息\n\t\t//以下调用answer_client()与client通信\n\t\tif ( answer_client ( new ) == ( -1 ) ) {\n\t\t      close ( sock ) ;\n\t\t      exit ( 0 ) ;\n\t\t}\n\t\t  \n\t}\n\n\t// This point in the program will never be reached.\n\treturn ( 0 ) ;\n}\n```\n\n总结：\n客户端编程思路：\n写2个子函数：connecting（）负责socket创建，connect\nquestioning（）通过参数传入socket和要询问的信息，负责socket的send和recv\n在main（）中循环外使用connecting（）建立连接，循环内每次先判断是否满足断开连接要求，在调用questioning（）。\n**注意：**地址转换和网络字节顺序转换函数的使用。\n\n服务器端编程思路：\n写3个子函数：palindrom（）用来处理收到的信息，判断是否是回文，用在answerclient中\nint naming ( )负责socket创建+设置+bind地址，返回socket\nint answer_client ( int sock ) 在无限循环中实现客户端数据的接受recv，处理palindrom和返回结果send。这里的循环会在客户端断开连接后跳出，是为了让server能处理多条client的消息。\n在main（）中先调用naming（）设置好服务器端socket，并开启监听listen（）\n在无线循环中获取与客户端通信的socketaccept（），打印出各类连接信息，调用answer_client实现通信。这里的循环是为了确保服务器一直运行能与多个客户端相连。\n\n## 获取socket信息\n\n- int getsockname(int sockfd,struct sockaddr* addr,socklen_t* addrlen);\n  通过引用传递，获取sockfd绑定的地址。0,success。-1 error\n- int getpeername(int sockfd,struct sockaddr* addr,socklen_t* addrlen);\n  通过引用传递，获取sockfd对端的地址。0,success。-1 error\n\n## 实例四\n\n在实例三的基础上应用struct保存信息，计算信息的价值\n\n```\n# include <sys/socket.h>\n# include <arpa/inet.h>\n# include <netdb.h>\n# include <stdio.h>\n# include <stdlib.h>\n# include <string.h>\n# include <unistd.h>\n\n\n# define SERVERPORT 8888\n# define LOCALHOST \"127.0.0.1\"\n\n# define MYMSGLEN   2048\n\ntypedef struct {\n      uint16_t ret ;\n      uint16_t msgLen ;\n      uint32_t cost ;   \n      char buff[ MYMSGLEN - 8 ] ; \n} messageCost; \n\nvoid question ( int sock, messageCost * msg )\n{\n\tint code, length, ret ;\n\n\t// Send the length of the string.\n\tlength = strlen ( msg->buff ) ; // + 1 ;\n\t\n\t// Send the string of characters.\n\tcode = send ( sock, msg->buff, length, 0 ) ;\n\tif ( code == -1 ) {\n\t\tperror ( \"send\" ) ;\n\t\texit ( 1 ) ;\n\t}\n\tprintf ( \"Message sent to server, waiting for the answer ..... \\n \" ) ;\n\t// Wait for the answer.\n\tcode = recv ( sock, ( char * ) msg, sizeof ( messageCost ), 0 ) ;\n\tif ( code == -1 ) {\n\t\tperror ( \"recv\" ) ;\n\t\texit ( 1 ) ;\n\t}\n\n\t// Release ressources.  XXX To remove\n\t//code = close ( sock ) ;\n\t//if ( code == -1 ) {\n\t//\tperror ( \"close\" ) ;\n\t//\texit ( 1 ) ;\n\t//}\n\n\t \n}\n\nint connecting ( )\n{\n\t// Socket creation.\n\tint sock ;\n\tsock = socket ( AF_INET, SOCK_STREAM, 0 ) ;\n\tif ( sock == -1 ) {\n\t\tperror ( \"socket\" ) ;\n\t\texit ( 1 ) ;\n\t}\n\n\t// Initialisation of the sockaddr_in data structure\n\n\tstruct sockaddr_in addr ;\n\tsocklen_t len ;\n\t\n\tstruct sockaddr_in newAddr ;\n\tstruct sockaddr_in peerAddr ;\n\n\tmemset ( & addr, 0, sizeof ( struct sockaddr_in ) ) ;\n\taddr . sin_family = AF_INET ;\n\taddr . sin_port = htons ( SERVERPORT ) ;\n\taddr . sin_addr . s_addr = inet_addr ( LOCALHOST ) ;\n\n\t// Name the socket.\n\tint code ;\n\tcode = connect ( sock, ( struct sockaddr * ) & addr, sizeof ( struct sockaddr_in ) ) ;\n\tif ( code == -1 ) {\n\t\tperror ( \"connect\" ) ;\n\t\tclose ( sock ) ;\n\t\texit ( 1 ) ;\n\t}\n\t\n\tlen = sizeof ( struct sockaddr_in ) ;\n\tcode = getsockname ( sock, ( struct sockaddr * ) & newAddr, & len ) ;\n\tif ( code == -1 ) {\n\t      perror ( \"getsockname\" ) ;\n\t      close ( sock ) ;\n\t\t\n\t      exit ( 1 ) ;\n\t}\n\tlen = sizeof ( struct sockaddr_in ) ;\n\tcode = getpeername ( sock, ( struct sockaddr * ) & peerAddr, & len ) ;\n\tif ( code == -1 ) {\n\t      perror ( \"getpeername\" ) ;\n\t      close ( sock ) ;\n\t      exit ( 1 ) ;\n\t}\n\t\t\n\tprintf ( \" The local address bound to the current socket --> %s:%d \\n\" , inet_ntoa ( newAddr.sin_addr ), ntohs ( newAddr.sin_port )  ) ;\n\tprintf ( \" The peer address bound to the peer socket --> %s:%d \\n\" , inet_ntoa ( peerAddr.sin_addr ), ntohs ( peerAddr.sin_port )  ) ;\n\n\t// Return the socket ID.\n\treturn ( sock ) ;\n}\n\nint main ( int argc, char * argv [ ] )\n{\n\n\t// Ask for the string of characters.\n\tchar string [ MYMSGLEN ] ;\n\tmessageCost *msg = (messageCost *) string ;\n\t\n\n\t// Connect to the server.\n\tint sock ;\n\tsock = connecting ( ) ;\n\n\twhile ( 1 )\n\t{\n\t  memset ( string, 0, sizeof( string ) ) ;\n\t\n\t  //printf ( \"String to check: \" ) ;\n\t  //scanf ( \"%s\", msg->buff ) ;\n\t  printf ( \"\\n----------------------------------------------------------------------\\n\" ) ;\n\t  printf ( \"Please type a message to transfer for processing:\" ) ;\n\t  scanf ( \"%[^\\n]%*c\", msg->buff ) ;  //reads a hole line till a new line feed\n\t  printf ( \"The message being sent is: '%s' \\n\", msg->buff ) ;\n\t  printf( \"----------------------------------------------------------------------\\n\" ) ;\n\t\n\t  \n\t  if ( !memcmp ( \"quit#\", string, 5 ) )\n\t    {\n\t      printf ( \" Client exiting upon user request \\n\" ) ; \n\t      close ( sock ) ;\n\t      exit ( 1 ) ;\n\t    }\n\t    \n\t  // Ask the question and wait for the answer.\n\n\t  question ( sock, msg ) ;\n\t\n\t\n\t  // Process the answer\t\n\t  msg->cost = ntohl ( msg->cost ) ;\n\t\n\t  msg->msgLen = ntohs ( msg->msgLen ) ;\n\t\n\t  msg->ret = ntohs ( msg->ret );\n\t\n\t\n\t  // Display the result.\n\t  printf ( \"\\n----------------------------------------------------------------------\\n\" ) ;\n\t\n\t  if ( msg->ret == 1 )\n\t    printf ( \"'%s' is a palindrom.\\n\", msg->buff ) ;\n\t  else\n\t    printf ( \"'%s' is not a palindrom.\\n\", msg->buff );\n\t\n\t  printf ( \"The processed message length is: %d, with a cost of: %.2f Euros\\n\", msg->msgLen, ( ( float ) msg->cost / 100 ) ) ;\n\t\n\t  printf ( \"----------------------------------------------------------------------\\n\" ) ;\n\t\n\t}\n\t  return ( 0 ) ;\n}\n```\n\n```\ntypedef struct {\n      uint16_t ret ;\n      uint16_t msgLen ;\n      uint32_t cost ;   \n      char buff[ MYMSGLEN - 8 ] ; \n} messageCost; \n\nchar string [ MYMSGLEN ] ;\nmessageCost *msg = (messageCost *) string ;\n```\n\n注意这里struct的用法，将字符串强制装换为messageCost，避免了使用malloc（）和free（），msg和string指向同一块地址的起始位置。\n其他与实例三相似，不加赘述。\n\t","tags":["Network Programming","笔记"]},{"title":"Network Programming（三）","url":"/2019/11/06/Network-Programming（三）/","content":"\n# Network Programming（三）\n\n![ ](../img/network programming/socket function.png  \"socket function\")\n\n## 实例 一\n\nApplication client/serveur TCP\nA和B通信，A向B发送message，B收到后，将这个msg在print出来\nA是客户端，B是serveur\n\n```\n程序A\n#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MYMSGLEN 2000\n\nint main(int argc,char* argv[])\n{\n\tint sock;\n\tstruct sockaddr_in server;\n\tchar message[MYMSGLEN],server_reply[MYMSGLEN];\n\n\tsock=socket(AF_INET,SOCK_STREAM,0);\n\t/*int socket(int domain,int type,int protocol);\n\t * 创建一个通信endpoint，返回一个描述符（descriptor）\n\t * 创建成功，一个对应新的socket的文件描述符（file descriptor）\n\t * 错误，-1\n\t *\n\t * domain描述ptotocol family。这些families定义在<sys/socket.h>\n\t * l例如：AF_INET：IPv4协议\n\t *\n\t * type指定服务类型：SOCK_StREAM：点对点控制流通信\n\t * SOCK_DGRAM：未连接的通信\n\t * SOCK_RAW：直接连间到协议（需要超级用户权限）\n\t *\n\t * protocol描述socket使用哪种协议，通常只有一种协议来支持socket类型，对应给协议簇\n\t * 0：default\n\t */\n\tif(sock==-1)\n\t{\n\t\tprintf(\"Could not create socket\\n\");\n\t\treturn(-1);\n\t}\n\n\tprintf(\"socket created\\n\");\n\n/*int connect(int sockfd,const struct sockaddr* addr,socklen_t addrlen);\n*服务器通过connect和server建立连接\n*将client的socket->sockfd和server的地址->addr相关联。\n*\n*sockfd:用于连接的socket\n*addr:被动参与者的地址（server的地址）\n*addrlen:size of addr\n*\n*0,成功连接，否则-1\n*/\n\t\n\tserver.sin_addr.s_addr=inet_addr(\"127.0.0.1\");\n\tserver.sin_family=AF_INET;\n\tserver.sin_port=htons(8888);\n\n\tint res;\n\tif((res=connect(sock,(struct sockaddr*)&server,sizeof(server)))<0)\n\t{\n\t\tperror(\"Connect failed error\\n\");\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tprintf(\"Returned value,%d\\n\",res);\n\tprintf(\"connection established, waiting to be accepted ......\");\n\n\twhile(1)\n\t{\n\t\t//void* memset(void* ptr,int value,size_t num);\n\t\t//将ptr指的内存区域的前num个字节值都设置为value，然后返回指向ptr的指针\n\t\tmemset(message,0,MYMSGLEN);\n\t\tprintf(\"\\nPlease type a message to transfer for processing:\");\n\t\tscanf(\"%s\",message);\n\n\n\t\t/*ssize_t send(int sockfd,const void *buf,size_t len,int flags)\n\t\t * 将一个message传到另一个socket\n\t\t * flags，特殊选项，通常都是0\n\t\t * 成功，返回传送的字节数\n\t\t * 失败 -1\n\t\t */\n\t\tif(send(sock,message,strlen(message),0)<0)\n\t\t{\n\t\t\tprintf(\"send failed\\n\");\n\t\t\tclose(sock);\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemset(server_reply,0,MYMSGLEN);\n\t\t/*ssize_t recv(int sockfd,void* buf,size_t len,int flags);\n\t\t * 和send差不多\n\t\t */\n\t\tif(recv(sock,server_reply,MYMSGLEN,0)<0)\n\t\t{\n\t\t\tprintf(\"recv failed\\n\");\n\t\t\tclose(sock);\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tprintf(\"Server reply:%s\",server_reply);\n\t}\n}\n```\n\n```\n程序B\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MYMSGLEN 2000\n\nint main(int argc,char** argv)\n{\n\tint socket_desc,client_sock;\n\tint socket_size,read_size;\n\tstruct sockaddr_in server,client;\n\tchar client_message[MYMSGLEN];\n\n\tsocket_desc=socket(AF_INET,SOCK_STREAM,0);\n\tif(socket_desc==-1)\n\t{\n\t\tperror(\"Could not create socket\");\n\t\treturn -1;\n\t}\n\n\tprintf(\"Socket created\\n\");\n\n\t/*socket options\n\t * int setsockopt(int socket,int level,int option_name,const void* option_value,socklen_toption_len);\n\t * sock：将要被设置或者获取选项的套接字。\n\t * level：选项所在的协议层。\n\t * optname：需要访问的选项名。\n\t * optval：对于getsockopt()，指向返回选项值的缓冲。对于setsockopt()，指向包含新选项值的缓冲。\n\t * optlen：对于getsockopt()，作为入口参数时，选项值的最大长度。作为出口参数时，选项值的实际长度。对于setsockopt()，现选项的长度。\n\t * level指定控制套接字的层次.可以取三种值:\n\t * 1)SOL_SOCKET:通用套接字选项.\n\t * 2)IPPROTO_IP:IP选项.\n\t * 3)IPPROTO_TCP:TCP选项.　\n\t * optname指定控制的方式(选项的名称),我们下面详细解释　\n\t *  SO_REUSERADDR　　　　　 允许重用本地地址和端口　　　　　　　　　int\n\t */\n\tint code,enable=1;\n\tcode = setsockopt(socket_desc,SOL_SOCKET,SO_REUSEADDR,&enable,sizeof(int));\n\tif(code==-1){\n\t\tperror(\"setsockopr\");\n\t\treturn 1;\n\t}\n\n\tserver.sin_family=AF_INET;\n\tserver.sin_addr.s_addr=INADDR_ANY;\n\tserver.sin_port=htons(8888);\n\n\n/*当一个socket创建后，我们需要将一个本地地址绑定到他\n\t * TCP/IP协议需要一个IP地址和一个端口号对应每个端点地址\n\t * \n\t * int bind(int sock,struct sockaddr* addr,socklen_t len)\n\t * sock:socket descriptor\n\t * addr:用来指定的地址\n\t * len:指定addr数据结构的size\n\t * 返回0,success\n\t * 返回-1,error\n\t *\n\t * addr是一个整体的数据类型，根据address family由不同\n\t * 对于IPv4：\n\t * struct sockaddr_in{\n\t * sa_family_t sin_family; address family:AF_INET\n\t * in_port_t sin_port; port\n\t * struct in_addr sin_addr; internet address\n\t * }\n\t *\n\t * struct in_addr{\n\t * unit32_t s_addr;\n\t * };\n\t *\n\t */\n\t \n\tif(bind(socket_desc,(struct sockaddr*)&server,sizeof(server))<0)\n\t{\n\t\tperror(\"bind failed. Error\");\n\t\tclose(socket_desc);\n\t\treturn -1;\n\t}\n\tprintf(\"bind done\\n\");\n\n\t/*int listen(int sockfd,int backlog)\n\t * sockfd:整数，是一个文件描述符指向类型为SOCK_STREAM的socket\n\t * backlog：整数，主动参与者的数量\n\t * listening 0\n\t * error -1\n\t */\n\tcode=listen(socket_desc,2);\n\t\n\tif(code==-1){\n\t\tperror(\"listen\");\n\t\texit;\n\t}\n\n\tprintf(\"Waiting for incoming connections...\\n\");\n\tsocket_size=sizeof(struct sockaddr_in);\n\n\t/* int accept(int sockfd,struct sockaddr* addr,socklent_t* addrlen)\n\t * sockfd:整数，正在被监听的socket\n\t * addr：struct sockaddr，主动参与者的地址\n\t */\n\tclient_sock=accept(socket_desc,(struct sockaddr*)&client,(socklen_t*)&socket_size);\n\tif(client_sock<0)\n\t{\n\t\tclose(socket_desc);\n\t\tperror(\"accept failed\");\n\t\treturn -1;\n\t}\n\tprintf(\"Connection accepted\\n\");\n\n\twhile((read_size=recv(client_sock,client_message,MYMSGLEN,0))>0)\n\t{\n\t\tclient_message[read_size]='\\0';\n\t\tprintf(\"MSG received: %s,size of the message received %d\\n\",client_message,read_size);\n\t\twrite(client_sock,client_message,read_size);\n\t}\n\n\tif(read_size==0)\n\t{\n\t\tprintf(\"client disconnected\\n\");\n\t\tfflush(stdout);\n\t}\n\telse if(read_size==-1)\n\t{\n\t\tprintf(\"recv failed\\n\");\n\t}\n\n\tclose(socket_desc);\n\tclose(client_sock);\n\n\treturn 0;\n}\n\n```\n\n客户端编程思路：\n\n1. 创建socket：int socket(int 协议簇,int 服务类型,int 协议 ), 返回对应该socket的文件描述符，失败，返回-1\n2. 建立连接：int connect(int 用于连接的socket ,struct sockaddr* 服务器的地址结构, socklen_t addr的大小)，返回0,成功连接，否则-1\n3. 在循环中本地通过scanf输入msg，再发送msg：ssize_t send(int 已经连接的socket和connect中的一样,const void* 待发送的信息这里是字符串指针,size_t strlen(message), int 特殊选项一般为0 )，成功，返回传送的字节数，失败，-1\n4. 同样在这个循环中，跟在send后，接受server的回复：ssize_t recv()和send差不多\n5. 断开连接：close(socket);\n\n\n服务器编程思路：\n\n1. 创建socket：int socket(int 协议簇,int 服务类型,int 协议 ), 返回对应该socket的文件描述符，失败，返回-1\n   1.5 设置socket：int setsockopt(int 要设置的socket,int 选项所在协议层,int 需要访问的选项名,const void* 指向选项值的指针,socklen_t 选项的长度); 返回-1,设置失败\n2. 绑定地址：int bind(int 创建出来的socket,struct sockaddr* 自己设定好的地址,socklen_t len，地址长度sizeof)返回0,success。返回-1,error\n3. 开始监听：int listen(int 用于监听的socket,int 主动参与者数量)。0正在监听，-1 error\n4. 接受连接：int accept(int 用于监听的socket,struct sockaddr* 主动参与者的地址通过应用传递在return语句之后被填充,socklent_t* 地址长度)，返回客户端的socket，-1 error\n5. 在循环中不停接受来自客户端的message，recv()同客户端一样\n6. 处理接收到的数据，这里就是输出\n7. 把message送回给client write(client_sock,client_message,read_size);\n8. 断开连接：close(socket);\n\n## 实例二\n\nProgramme client HTTP\n编写一个客户端程序，向指定网站发送请求并获取数据\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n\n#define MYMSGLEN 2000\n\nint main(int argc,char** argv)\n{\n\tint socket_desc;\n\tstruct sockaddr_in server;\n\tchar *message,server_reply[MYMSGLEN];\n\n\tstruct hostent *he;\n\n\tstruct in_addr inaddr;\n\n\tsocket_desc=socket(AF_INET,SOCK_STREAM,0);\n\tif(socket_desc==-1)\n\t{\n\t\tperror(\"Could not create socket\");\n\t\treturn -1;\n\t}\n\n\tprintf(\"Socket created\\n\");\n\n\t//把DNS主机名变成IP地址（使用DNS）\n\tif((he=gethostbyname(\"httpd.apache.org\"))==NULL)\n\t{\n\t\tperror(\"gethostbyname\");\n\t\treturn 2;\n\t}\n\n\tmemcpy((char*)&inaddr,he->h_addr,sizeof(struct in_addr));\n\tprintf(\"IP address for httpd.apache.org is %s \\n\",inet_ntoa(inaddr));\n\n\tserver.sin_family=AF_INET;\n\tserver.sin_addr.s_addr=inet_addr(inet_ntoa(inaddr));\n\tserver.sin_port=htons(80);\n\n\tif(connect(socket_desc,(struct sockaddr*)&server,sizeof(server))<0)\n\t{\n\t\tprintf(\"connect error\");\n\t\treturn 1;\n\t}\n\tprintf(\"Connection\\n\");\n\n\tmessage=\"GET / HTTP/1.1\\r\\nhost: httpd.apache.org \\r\\n\\r\\n\";\n\n\tif(send(socket_desc,message,strlen(message),0)<0)\n\t{\n\t\tputs(\"Send failed\");\n\t\treturn -1;\n\t}\n\tputs(\"message request sent\");\n\n\tint res;\n\tmemset(server_reply,0,MYMSGLEN);\n\n\twhile((res=recv(socket_desc,server_reply,MYMSGLEN,0))!=0)\n\t{\n\t\tif(res <0)\n\t\t{\n\t\t\tputs(\"recv failed\");\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%s\",server_reply);\n\t\t\tmemset(server_reply,0,MYMSGLEN);\n\t\t}\n\t}\n\n\tclose(socket_desc);\n\treturn 0;\n}\n\t\n```\n\n### 主机名和地址转换功能\n\n- struct hostent* gethostbyname(const char* hostname);\n  把DNS主机名变成IP地址（使用DNS）\n- strcut hostent* gethostbyaddr(const char* addr,size_t len,int family);\n  把IP地址变成DNS主机名\n- char* inet_ntoa(struct in_addr invader);\n  将IP地址转换为ASCII点十进制符号\n- in_addr_t inet_addr(const char* strptr);\n  将点分十进制变成IP地址，-1 failure，不能用于广播（255.255.255.2555）\n- int inet_aton(const char* sttrptr,struct in_addr inaddr);\n  将点十进制表示法转换为IP地址;成功返回1，失败返回0\n- int inet_pton(int af,const char* src, void* dst);\n  将IPv4和IPv6地址从文本转换为二进制形式\n- const char* inet_ntop(int af,const void* src,char* dst,socklen_t size);\n  将IPv4和IPv6地址从二进制转换为文本形式\n\n\n### 其他一些有用函数\n\n- void bzero(void* s,size_t n);\n  将区域的前n个字节设置为从零开始\n- void* memset(void* s,int c,size_t n);\n  用常量字节c填充指向的存储区的前n个字节\n  返回指向内存区域s的指针\n- void* memcpy(void* dest,const void* src,size_t n);\n  将n个字节从内存区域src复制到内存区域dest。内存区域不能重叠","tags":["Network Programming","笔记"]},{"title":"Network Programming（二）","url":"/2019/11/06/Network-Programming（二）/","content":"\n# Network Programming（二）\n\n## Client/server communication 客户端/服务器通信\n\n - 服务器：\n   被动地等待和响应客户\n    passive socket\n\n - 客户端：\n   开始通信\n    必须知道服务器的地址和端口\n    active socket\n\n - 功能说明:\n   –指定本地和远程通信端点\n    –启动连接\n    –等待传入连接\n    –发送和接收数据\n    –正常终止连接\n    –错误处理\n\n ## Network API\n\n api：application programming interface 应用程序接口\n  API是由程序系统提供的一组功能/服务。\n\n  Network API：\n  服务(通常由操作系统提供)\n  提供应用程序和协议软件之间的接口\n\n 有各种各样的应用程序接口可用于TCP / IP :\nSockets by Berkeley\nXTI (X/Open Transport Interface) by AT&T\nWinsock -Windows Sockets API by Microsoft\nMacTCP/ Open Transport by Apple\n\n## Sockets\n\n- 用于通信的编程接口 \n- 提供此服务的一组原语 \n- 通用•可以适应不同的通信需求 \n- 独立的特定网络或协议，•最初在4.2BSD系统中开发用于因特网通信，于1983年发布。 \n- 不需要使用网络进行通信•本地机器通信：Unix域\n\n套接字:\n–应用程序进程发送和接收数据的入口点\n–唯一标识通过\n互联网地址\n端到端协议(例如，TCP或UDP )\n端口号\n\n两种类型的( TCP/IP )套接字\n—流套接字/连接模式(例如使用TCP )\n提供可靠的字节流服务\n—数据语法套接字/非连接模式(例如使用UDP )\n提供尽力而为的数据报服务\n最多65.500字节的消息\n\n## 套接字用于客户端/服务器通信\n\n套接字的使用方法如下：\n\n- 每个应用程序:\n  创建一个套接字–想法:两个应用程序之间的通信将通过一个将两个套接字连接在一起的假想“管道”进行。\n  关闭一个socket套接字\n\n- 服务器: 将其套接字绑定到一个已知的地址\n- 客户端：找到服务器套接字（通过其已知的地址）并与服务器“发起通信”\n\n![ ](../img/network programming/socket.png  \"socket\")\n\n","tags":["Network Programming","笔记"]},{"title":"Network Programming（一）","url":"/2019/11/06/Network-Programming（一）/","content":"\n# Network Programming（一）\n\n## 介绍\n\n计算机网络是set of hosts，routers 和 intermediate devices（主机，路由器和中间设备）\n主机运行通信连接到端到端applications\n路由relay（转发）数据包（data packets）\nPackets：一系列字节\n包含用户数据+控制信息（如：目标主机）\n一次通信（数据交换）遵循一个预定义的通信协议\n\n## TCP/IP Generalities（概述）\n\n针对不同问题的几个协议：协议簇：TCP/IP\nTCP/IP提供点到点连接并指定数据应该如何格式化、寻址、传输、路由和在目的地接收\n可用于互联网和独立的专用网络\n它被组织成层\n\n![ ](../img/network programming/OSI model.png  \"OSI模型和TCP/IP模型\")\n![ ](../img/network programming/数据包封装.png  \"数据包封装\")\n\nIP地址：是分配给网络接口以标识自身的唯一地址。用于与他人通信，并找到中继数据包的路由。长度：4bytes。类型：unicast单播，broadcast广播，multicast多播\n\n\n## TCP和UDP\n\nTCP：Transmission Control Protocol传输控制协议\n\n-  可靠的字节流通道(有序，全部到达，无重复)，类似于文件输入/输出\n-  流量控制\n-  面向连接的\n-  双指向性\n\nTCP用于具有大数据容量和持久连接的服务。\n\nUDP：User Datagram Protocol用户数据报协议\n\n- no acknowledgements没有确认\n- no retransmissions没有重传\n- out of order乱序执行\n- 无连接，即app指示每个数据包的目的地\n\nUDP更常用于快速查找和一次性查询回复操作。\n\n## 端口号Ports numbers\n\n- TCP和UDP都使用端口号\n  用作通信的特定于应用的构造。\n  端点16位无符号整数，范围从0到65535。\n  提供端到端传输。\n\n- 端口分为三类\n  所有已知端口( 0到1023 )用于基本服务(系统使用，需要超级用户权限)。\n  参考端口( 1024至49151 )由IANA根据请求实体的申请为特定服务关联(在大多数系统中，注册端口可由普通用户使用)\n  动态或私有或短暂端口( 49152至65535 )用于其他目的。\n\n- TCP和UDP的一些常见示例以及它们的默认端口：\n  DNS查阅 UDP 53\n  FTP TCP 21\n  HTTP TCP 80\n  POP3 TCP 110\n  Telnet TCP 23\n\n- 保留端口的详细信息：\n  列在/ etc / services文件中的大多数系统上\n   能通过 http://www.iana.org/assignments/port-numbers  找到\n\n \n\n ","tags":["Network Programming","笔记"]},{"title":"SDL学习（一）","url":"/2019/03/16/SDL学习（一）/","content":"\n# SDL（Specification and Description Languag）学习\n\n## 基础概念\n\n**System**：系统，是要开发的应用总体\n\n**environment**：环境，是任何处于系统外部的东西\n\n### Architecture（体系结构）\n\nsystem可被分解成功能块（functional **blocks**）\n\nblock可被分解为子块（**sub-blocks**)\n\nblcok通过一个或多个进程（**processes**），实现功能，通过信息/信号（**messages/signals**）来互相通信。\n\nprocess是一个任务（**task**），有一个隐式的消息队列（implicit **message queue**）来从其他tasks接受messages。不必定义这个队列。\n\n*block在最终程序中不直接实现，是程序的组织和架构者*\n\nblocks和process也叫代理（**agents**）\n\n![SDL1](../img/SDL/SDL1.PNG)\n\n### Communication（通信）\n\nAgents通过管道（**channels**）交换messages\n\n*channels在最终程序中不直接实现，他们用于架构软件和定义接口*\n\n### Behavior（行为）\n\n进程行为（**process behavior**）图形化地定义为有限状态机（**finite state machine**）Internalprocess  states,  events  (messages),  decisions,  timer  manipulations,  semaphoremanipulations \n\n![SDL2](../img/SDL/SDL2.PNG)\n\n### Data and syntax（数据和语法）\n\n**SDL和SDL-RT的主要不同之处：**\n\n- SDL，data通过ADT（Abstract Data Types）定义，使用特定概念和符号。data实现也有特定语法\n- SDL-RT，使用C语言","tags":["SDL","建模"]},{"title":"Android学习（二）","url":"/2019/03/16/Android学习（二）/","content":"\n# Android（二）\n\n## 活动生命周期（le cycle de vie des activite)\n\n### 进程（processus）\n\n**进程管理**\n\n- 在不同的GNU/LInux系统中不同\n- 目的：优化应用程序；节省资源；管理任务优先级\n\n**一个Android应用是一个Unix进程**\n\n- 可能有一个虚拟据（Dalvik）执行\n\n- 一个虚拟机aspects的闭包（运行时ART android runtime）\n\n  这个进程有一个特殊的生命周期\n\n**几个活动生命周期的示例图**\n\n![活动的生命周期图](D:\\共享图片\\笔记\\Android\\活动的生命周期图.PNG)\n\n![活动的生命周期图2](D:\\共享图片\\笔记\\Android\\活动的生命周期图2.PNG)\n\n![活动的生命周期图3](D:\\共享图片\\笔记\\Android\\活动的生命周期图3.PNG)\n\n*注意：执行AlterDialog弹出警告框，这不是一个新的activity，所以没有onPause（*）*\n\n**进程销毁**\n\nonDestory（）\n\n 优先级等级\n\n1. 屏幕显示的进程\n2. 可见的进程\n3. 服务进程\n4. 后台任务进程\n5. 空进程（已结束，存在cache中的进程）\n\n## Taches asynchrones（同步的任务）\n\n**主进程（le thread principal）**\n\n- 刷新界面\n- 处理用户相关事务\n- 处理messages\n- 执行services\n\n不要阻断UI线程\n\n不要从UI线程外部access到UI toolkit\n\n**管理线程冲突**\n\n两种解决方法：\n\n- 给图像界面元素加锁\n- 只用一个Thread管理图形界面元素\n\n委托图形界面处理：\n\n- Activity.runOnUiThread(Runnable)\n- View.post(Runnable)\n- View.postDelayed(Runnable,long)\n\n## 异步任务AsyncTask<U,V,W>\n\n![AsyncTask](D:\\共享图片\\笔记\\Android\\AsyncTask.PNG)\n\n## JSON\n\n### 用HTTP读JSON objets：1. 把请求写入一个异步任务 2. 使用这个AsyncTask类\n\n要使用HTTP，有一个封装好的类：HttpURLConnection\n\n![HttpURLConnection类示例图](D:\\共享图片\\笔记\\Android\\HttpURLConnection类示例图.PNG)\n\n自己写一个readStream（）方法用来读入数据流（flux de donnees）来构建结果\n\n```java\nprivate String readStream(InputStream is) throws IOException {\n\n    StringBuilder sb = new StringBuilder();  \n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is),1000);  \n\n    for (String line = r.readLine(); line != null; line =r.readLine()){  \n\n        sb.append(line);  \n\n    }  \n\n    is.close();  \n\n    return sb.toString();\n\n}\n```\n\n\n\n","tags":["Android"]},{"title":"Android学习（一）","url":"/2019/03/16/Android学习（一）/","content":"\n# Android学习（一）\n\n## 日志\n\n- Log. v()。 用于 打印 那些 最为 琐碎 的、 意义 最小 的 日志 信息。 对应 级别 verbose， 是 Android 日志 里面 级别 最低 的 一种。 \n- Log. d()。 用于 打印 一些 调试 信息， 这些 信息 对 你 调试 程序 和 分析 问题 应该 是有 帮助 的。 对应 级别 debug， 比 verbose 高 一级。 \n- Log. i()。 用于 打印 一些 比较 重要的 数据， 这些 数据 应该 是你 非常 想 看到 的、 可以 帮你 分析 用户 行为 数据。 对应 级别 info， 比 debug 高 一级。 \n- Log. w()。 用于 打印 一些 警告 信息， 提示 程序 在这 个 地方 可能 会有 潜在 的 风险， 最好 去 修复 一下 这些 出现 警告 的 地方。对应 级别 warn， 比 info 高 一级。 \n- Log. e()。 用于 打印 程序 中的 错误 信息， 比如 程序 进入 到了 catch 语句 当中。 当 有错误 信息 打印 出来 的 时候， 一般 都 代表 你的 程序 出现 严重 问题 了， 必须 尽快 修复。 对应 级别 error， 比 warn 高 一级。\n\n## 活动（Activity）\n\n活动（ Activity） 是最 容易 吸引 用户 的 地方， 它是 一种 可以 包含 用户 界面 的 组件， 主要 用于 和 用户 进行 交互。\n\n1. 在 java/ com. example. activitytest中新建一个activity\n2. 在 src/layout中创建一个布局文件, 在activity中加载布局（）回到 FirstActivity， 在 onCreate() 方法 中 加入 如下 代码： `setContentView( R. layout. first_ layout);`\n3. 在 AndroidManifest 文件 中 注册\n\n配置 主 活动 的 方法 其 实在 第 1 章 中 已经 介绍 过了， 就是 在< activity> 标签 的 内部 加入< intent- filter> 标签， 并在 这个 标签 里 添加< action android: name=\" android. intent. action. MAIN\"/> 和< category android: name=\" android. intent. category. LAUNCHER\" />这 两句 声明 即可。\n\n## Toast(短暂出现的提示框)\n\n首先 需要 定义 一个 弹出 Toast 的 触发 点， 正好 界面 上有 个 按钮， 那 我们 就让 点击 这个 按钮 的 时候 弹出 一个 Toast 吧。 在 onCreate()中添加\n\n```java\nprotected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button button=(Button) findViewById(R.id.button);\n        button.setOnClickListener(new View.OnClickListener(){\n            public void onClick(View v){\n                Toast.makeText(MainActivity.this,\"You clicked Button\", Toast.LENGTH_SHORT).show();\n            }\n        });\n    }\n```\n\n得到 按钮 的 实例 之后， 我们 通过 调用 setOnClickListener() 方法 为 按钮 注册 一个 监听器， 点击 按钮 时 就会 执行 监听器 中的 onClick() 方法。\n\n静态方法makeText() 创建 出 一个 Toast 对象， 然后 调用 show() 将 Toast 显示 出来 就可以 了。 这里 需要 注意 的 是， makeText() 方法 需要 传入 3 个 参数。 第一个 参数 是 Context， 也就是 Toast 要求 的 上下文， 由于 活动 本身 就是 一个 Context 对象， 因此 这里 直接 传入 FirstActivity. this 即可。 第二个 参数 是 Toast 显示 的 文本 内容， 第三 个 参数 是 Toast 显示 的 时 长， 有两 个 内置 常量 可以 选择 Toast. LENGTH_ SHORT 和 Toast. LENGTH_ LONG。\n\n\n\n## Menu\n\n1. 在res/menu中新建Menu resource file\n\n2. 在新建出来的menuxml文件中添加items\n\n3. 在activity中重写onCreateOptionsMenu()方法\n\n   ```java\n       public boolean onCreateOptionsMenu(Menu menu) {\n           getMenuInflater().inflate(R.menu.main,menu); return true;\n       }\n   ```\n\n   inflate() 方法 接收 两个 参数， 第一个 参数 用于 指定 我们 通过 哪一个 资源 文件 来 创建 菜单， 这里 当然 传入 R. menu. main。 第二个 参数 用于 指定 我们 的 菜单项 将 添加 到 哪一个 Menu 对象 当中， 这里 直接 使用 onCreateOptionsMenu() 方法 中 传入 的 menu 参数。 然后 给 这个 方法 返回 true， 表示 允许 创建 的 菜单 显示 出来， 如果 返回 了 false， 创建 的 菜单 将 无法 显示。\n\n4. 定义菜单响应事件。在acticity中重写onOprionsItemsSelected()方法：\n\n   ```java\n   public boolean onOptionsItemSelected(MenuItem item) {\n           switch (item.getItemId())\n           {\n               case R.id.add_item:\n                   Toast.makeText(this,\"You clicked Add\", Toast.LENGTH_SHORT).show();\n                   break;\n               case R.id.remove_item:\n                   Toast.makeText(this,\"You clicked Remove\", Toast.LENGTH_SHORT).show();\n                   break;\n               default:\n                   Toast.makeText(this,\"Default\",Toast.LENGTH_SHORT).show();\n           }\n           return true;\n       }\n   ```\n\n## 销毁事件\n\n只要 按 一下 Back 键 就可以 销毁 当前 的 活动 了。 不过 如果 你 不想 通过 按键 的 方式， 而是 希望 在 程序 中 通过 代码 来 销毁 活动， 当然 也可以， Activity 类 提供 了 一个 finish() 方法， 我们 在 活动中 调用 一下 这个 方法 就可以 销毁 当前 活动 了。\n\n\n\n## Intent(连接各个活动)\n\nIntent 是 Android 程序 中 各组 件 之间 进行 交互 的 一种 重要 方式， 它不 仅可 以指 明 当前 组件 想要 执行 的 动作， 还可 以在 不同 组件 之间 传递 数据。 Intent 一般 可被 用于 启动 活动、启动 服务 以及 发送 广播 等 场景。\n\n### 显示Intent\n\nIntent 有多 个 构造 函数 的 重载， 其中 一个 是 Intent( Context packageContext, Class<?> cls)。 这个 构造 函数 接收 两个 参数， 第一个 参数 Context 要求 提供 一个 启动 活动 的 上下文， 第二个 参数 Class 则是 指定 想要 启动 的 目标 活动， 通过 这个 构造 函数 就可以 构建 出 Intent 的“ 意图”。 然后 我们 应该 怎么 使用 这个 Intent 呢？ Activity 类 中 提供 了 一个 startActivity() 方法， 这个 方法 是 专门 用于 启动 活动 的， 它 接收 一个 Intent 参数， 这里 我们将 构建 好的 Intent 传入 startActivity() 方法 就可以 启动 目标 活动 了。\n\n修改MainActivity中按钮点击事件\n\n```java\n button.setOnClickListener(new View.OnClickListener(){\n            public void onClick(View v){\n                    Intent intent=new Intent(MainActivity.this,Test1Activity.class);\n                    startActivity(intent);\n            }\n        });\n```\n\nMainActivity.this作为上下文，Test1Activity.class作为目标活动。通过startActivity来执行Intent。\n\n### 隐式Intent\n\n它 并不 明确 指出 我们 想要 启动 哪一个 活动， 而是 指定 了 一系列 更为 抽象 的 action 和 category 等 信息， 然后 交由 系统 去 分析 这个 Intent， 并 帮我 们 找出 合适 的 活动 去 启动。\n\n1. 在AndroidManifest.xml中指定活动能够响应的action和category\n\n   ```xml\n   <activity android:name=\".Test1Activity\">\n               <intent-filter>\n                   <action android:name=\"com.example.activitytest.ACTION_START\"/>\n                   <category android:name=\"android.intent.category.DEFAULT\"/>\n               </intent-filter>\n           </activity>\n   ```\n\n   在< action> 标签 中 我们 指明 了 当前 活动 可以 响应 com. example. activitytest. ACTION_ START 这个 action， 而< category> 标签 则 包含 了 一些 附加 信息， 更 精确 地 指明 了 当前 的 活动 能够 响应 的 Intent 中 还可 能带 有的 category。 只有< action> 和< category> 中的 内容 同时 能够 匹配 上 Intent 中指 定的 action 和 category 时， 这个 活动 才能 响应 该 Intent。\n\n2. 修改按钮的点击事件\n\n   ```java\n   button.setOnClickListener(new View.OnClickListener(){\n               public void onClick(View v){\n                       Intent intent=new Intent(\"com.example.activitytest.ACTION_START\");\n                       startActivity(intent);\n               }\n           });\n   ```\n\n   每个 Intent 中 只能 指定 一个 action， 但却 能 指定 多个 category\n\n------\n\n### 更多隐式Intent用法\n\n使用 隐式 Intent， 我们 不仅 可以 启动 自己 程序 内 的 活动， 还可以 启动 其他 程序 的 活动， 这 使得 Android 多个 应用 程序 之间 的 功能 共享 成为 了 可能。 比如说 你的 应用 程序 中 需要 展示 一个 网页， 这时 你 没有 必要 自己 去 实现 一个 浏览器（ 事实上 也不 太 可能）， 而是 只需 要 调用 系统 的 浏览器 来 打开 这个 网页 就 行了。\n\n```java\nbutton1.setOnClickListener(new View.OnClickListener(){\n            public void onClick(View v)\n            {\n                Intent intent=new Intent(Intent.ACTION_VIEW);\n                intent.setData(Uri.parse(\"http://www.google.com\"));\n                startActivity(intent);\n            }\n        });\n```\n\n了 Intent 的 action 是 Intent. ACTION_ VIEW， 这是 一个 Android 系统 内置 的 动作， 其 常 量值 为 android. intent. action. VIEW。 然后 通过 Uri. parse() 方法， 将 一个 网址 字符串 解析 成 一个 Uri 对象， 再 调用 Intent 的 setData() 方法 将 这个 Uri 对象 传递 进去。\n\nsetData()方法，它 接收 一个 Uri 对象， 主要 用于 指定 当前 Intent 正在 操作 的 数据， 而这 些 数据 通常 都是 以 字符串 的 形式 传入到 Uri. parse() 方法 中 解析 产生 的。 \n\n与此 对应， 我们 还可 以在< intent- filter> 标签 中 再 配置 一个< data> 标签， 用于 更 精确 地 指定 当前 活动 能够 响应 什么 类型 的 数据。< data> 标签 中 主要 可以 配置 以下 内容。 \n\n- android: scheme。 用于 指定 数据 的 协议 部分， 如上 例 中的 http 部分。 \n- android: host。 用于 指定 数据 的 主机 名 部分， 如上 例 中的 www. baidu. com 部分。 \n- android: port。 用于 指定 数据 的 端口 部分， 一般 紧随 在 主机 名 之后。 \n- android: path。 用于 指定 主 机名 和 端口 之后 的 部分， 如一 段 网址 中 跟在 域名 之后 的 内容。 \n- android: mimeType。 用于 指定 可以处理 的 数据 类型， 允许 使用 通配符 的 方式 进行 指定。\n\n除了 http 协议 外， 我们 还可以 指定 很多 其他 协议， 比如 geo 表示 显示 地理 位置、 tel 表示 拨 打电话。\n\n","tags":["Android"]},{"title":"C#数据库工具开发（十三）","url":"/2019/01/09/C-数据库工具开发（十三）/","content":"\n# C#数据库工具开发（十三）\n\n## 问题（08/01）\n\n单行同步，容易实现，只要判断选择的行状态做操作就行。\n如何撤销？用栈存储已执行的sql指令以及执行前的字段状态，对应每个指定，做反操作。\n\n做同步操作，全过程\n\n1. 根据差异同步DB\n2. 清空dblists\n3. 取更新后的dblists\n4. 用新的dblists填充dataDB\n5. 更新新的infolists\n6. 按照新的dblists顺序，对infolists排序，并删除已经选择去掉的项\n7. 用新的infolists填充dataxml\n8. 同步索引项","tags":["C#实战"]},{"title":"C#数据库工具开发（十二）","url":"/2019/01/09/C-数据库工具开发（十二）/","content":"\n# C#数据库工具开发（十二）\n\n## 问题（07/30）\n\n### 1. 如何实现同步两个DGV的滚动条\n\n```\nprivate void dataXML_Scroll(object sender, ScrollEventArgs e)       \n{               \nthis.dataDB.FirstDisplayedScrollingRowIndex = this.dataXML.FirstDisplayedScrollingRowIndex;\n}\n\nprivate void dataDB_Scroll(object sender, ScrollEventArgs e)\n{ \nthis.dataXML.FirstDisplayedScrollingRowIndex = this.dataDB.FirstDisplayedScrollingRowIndex; \n}\n```\n\n### 2. 如何实现一次删除DGV中的多行\n\n```\nforeach (DataGridViewRow row in dataXML.Rows)\n{\n    if((row.Cells[0].Value==null||row.Cells[0].Value.ToString()==\"\")&&row.Index!=dataXML.Rows.Count-1)\n    {\n        row.Selected = true;\n    }\n    else\n    {\n        row.Selected = false;\n    }\n}\nforeach (DataGridViewRow row in dataXML.SelectedRows)\n{\n    dataXML.Rows.Remove(row);\n}\n```\n\n在if条件中写要删除的行应该满足的条件，设置行被选中（利用Selected这个property），再删除选中的行。\n\n注意：不能用foreach每一行，加上判断，直接删除。因为每一次删除后，实际上Rows已经改变，循环不能遍历到所有满足条件的行。（先存行号，后删除的做法也一样，同理，每一次删除，行号已经改变）\n\n### 3. 避免事件无意间调用\n\n问题背景：我想要按下delete后，不删除这一行，只清空改行所有数据。想到的解决方法是在删除这一行后，在同一个index新建一行，但是总是出现各种问题。后来发现，因为我在`dataXML_RowsAdded`（行增加事件）中有完成其他功能，而实际上，我每次新建一行，都会触发这个事件，这就导致出现问题。<br>\n解决方法：设定一个bool标签deleting，在删除触发的方法中，设定deleting一开始为true，最后设回false，并在增加行触发的方法中，判断deleting的值，若为true则不执行任何操作。","tags":["C#实战"]},{"title":"C#数据库工具开发（十一）","url":"/2019/01/09/C-数据库工具开发（十一）/","content":"\n# C#数据库工具开发（十一）\n\n## 问题（07/26-07/27）\n\n### 1. 删除数据库中的一列，会自动删除与其关联的索引吗？\n\nMySQL是这样的，[详情](https://stackoverflow.com/questions/4341897/what-happens-if-i-drop-a-mysql-column-without-dropping-its-index-first)\n\nSQLServer经实践发现，必须先删除索引再删除列。因为索引依赖于列。\n\n### 2. 索引命名引起的异常\n\n问题背景：在新增索引时总是按照`表名_INDEX_数字`来给索引命名，数字是从0开始往上递增。问题在于，假设我们在test表中分别给三个字段添加了三个索引，即生成索引`TEST_INDEX_0/1/2`，那么如果我们删除了第一个索引`TEST_INDEX_0`，保留了索引`TEST_INDEX_1/2`，再次新建索引时，这个索引名字应该是0还是3结尾？而且我目前的实现，未考虑上述情况，只是在建立索引前查询表中索引数目，以这个数目作为新索引的结尾名，因此现在若创建一个新的索引会命名为`TEST_INDEX_2`，与表中已存在的索引冲突，发生异常。\n\n解决方案一：<br>\n每次删除一个索引，把它编号之后的索引编号减一，这涉及到索引的查找和修改。<br>\n`sp_rename 'tabName.old_indName','new_indName','INDEX'`\n\n解决方案二：<br>\n换一种命名方式：编号可用随机值<br>\n生成真随机数的方法：\n\n```\n public static string GenerateRandomCode(int length)\n    {\n        var result = new System.Text.StringBuilder();\n        for (var i = 0; i < length; i++)\n        {\n            var r = new Random(Guid.NewGuid().GetHashCode());\n            result.Append(r.Next(0, 10));\n        }\n        return result.ToString();\n    }\n```\n\n解决方案三：<br>\n不考虑名称的连续性，直接在最大值基础上往上加。\n\n### 3. 字段有索引时，不能修改字段类型\n\n解决方法：先删除索引，修改字段后，再新建索引。<br>\n这里会引起一个额外的问题：如何确认要修改的字段是否已存在索引。<br>\n有以下几种情况：<BR>\n\n1. 字段有索引，checkbox已勾选=>先删除索引，修改字段，再新建索引。\n2. 字段有索引，checkbox不勾选=>先删除索引，再修改字段\n3. 字段无索引，checkbox已勾选=>先修改字段，再添加索引\n4. 字段无索引，checkbox不勾选=>直接修改字段\n\n还有两种情况<BR>\n新增字段：先增加字段，根据checkbox值，选择是否添加索引。<BR>\n删除字段：先删除索引，再删除字段<BR>\n\n**此外，若只增删索引，则会重复修改字段操作。**<br>\n设定bool标识justindex，每次调用compareList（）方法时，确认行有差异，是否是因为只有索引列发生变化，如是则设为true，否则有其他引起行的差异则设为false。这样，在做同步操作前，先根据bool标识，获知引起行差异的原因，可省去没必要的修改字段操作。\n\n一共有八钟可能的操作<br>\n\n1. 只增加字段，不增加索引 OK\n2. 只修改字段，不增加索引 OK\n3. 不修改字段，增加索引 OK\n4. 不修改字段，删除索引 OK\n5. 既增加字段，又增加索引 OK\n6. 既修改字段，又增加索引 OK\n7. 既修改字段，又删除索引 OK\n8. 既删除字段，又删除索引 OK","tags":["C#实战"]},{"title":"C#数据库工具开发（十）","url":"/2019/01/09/C-数据库工具开发（十）/","content":"\n# C#数据库工具开发（十）\n\n## 问题（07/24-07/25）\n\n### 1. 如何实现一个页面关闭触发上级页面的响应？\n\n问题背景：我有一个页面显示某个数据库中所有表名和表结构，在此页面可以打开另一个修改或创建新表的页面，完成后，我想立即在显示页面刷新，让刚刚修改或生成的表也能出现在列表中。<br>\n解决方法：由于修改添加页面是在显示页面生成的：\n\n```\nformxml = new FormXMLExecute(\"*Oracle*\", filePath.Text);\nformxml.Show();\n```\n\n我们只需要在创建formxml时添加一个页面关闭事件即可：\n\n```\nformxml = new FormXMLExecute(\"*Oracle*\", filePath.Text);\nformxml.FormClosing += new FormClosingEventHandler(this.FromXMLExecute_FormClosing);\nformxml.Show();\n```\n\n在页面关闭事件中：\n\n```\nprivate void FromXMLExecute_FormClosing(object sender, FormClosingEventArgs e)\n{\n    //Do your stuff here.\n}\n```\n\n实现想要完成的功能（如刷新页面等）\n\n### 2. DataGridViewCheckBox的响应事件\n\n问题背景：想要实现点击DataGridViewCheckBox后，刷新页面\n解决方法：这个的即时响应和DataGridViewTextBox或DataGridViewComboBox相比简单很多，能直接用现有事件\n\n```\nprivate void dataXML_CellContentClick(object sender, DataGridViewCellEventArgs e)\n{\n    if (e.ColumnIndex == 3 && e.RowIndex != -1)\n    {\n        //Do your stuff here.\n    }\n}\n```\n\n唯一需要注意的和之前提到的一样：用单元格`EditedFormattedValue`属性而不是`Value`属性。\n\n### 3. 如何查询某个表中所有设置了索引的字段？\n\nOracle：\n​\t\n\n```\nselect a.column_name from all_ind_columns a, all_indexes b where a.index_name=b.index_name and a.table_name = upper('\"+tableName+\"') order by a.table_name\";\n```\n\nSQLServer：\n\n```\n\"USE \" + DBName+\" ;SELECT colname=d.name FROM   sysindexes  a  JOIN   sysindexkeys   b   ON   a.id=b.id   AND   a.indid=b.indid  JOIN   sysobjects   c   ON   b.id=c.id  JOIN   syscolumns   d   ON   b.id=d.id   AND   b.colid=d.colid  WHERE   a.indid   NOT IN(0,255)  AND   c.name='\"+tableName+\"'\";\n```\n\n### 3.1 更好的查询表中所有索引以及对应列名的sql查询语句\n\n```\nuse GMP_BF;\nSELECT\ntab.name AS [表名],\nidx.name AS [索引名称],\ncol.name AS [列名]\nFROM\nsys.indexes idx\nJOIN sys.index_columns idxCol \n  ON (idx.object_id = idxCol.object_id \n      AND idx.index_id = idxCol.index_id \n      )\nJOIN sys.tables tab\n  ON (idx.object_id = tab.object_id)\nJOIN sys.columns col\n  ON (idx.object_id = col.object_id\n      AND idxCol.column_id = col.column_id)\nWHERE tab.name='TEST2';\n```","tags":["C#实战"]},{"title":"C#数据库工具开发（九）","url":"/2019/01/09/C-数据库工具开发（九）/","content":"\n# C#数据库工具开发（九）\n\n## 问题（07/20）\n\n### 1. 如何实现DataGridView更改Cell值实时同步（像TextBox的效果）？\n\n具体实现：\n\n```\n\tprivate void dataXML_EditingControlShowing(object sender, DataGridViewEditingControlShowingEventArgs e)\n    {\n        if (e.Control.GetType().Equals(typeof(DataGridViewComboBoxEditingControl)))//cell为类ComboBox时\n        {\n            e.CellStyle.BackColor = Color.FromName(\"window\");\n            DataGridViewComboBoxEditingControl editingControl = e.Control as DataGridViewComboBoxEditingControl;\n            editingControl.SelectedIndexChanged += new EventHandler(EditingTB_TypeChanged);\n        }\n        else if (e.Control.GetType().Equals(typeof(DataGridViewTextBoxEditingControl)))//cell为类TextBox时\n        {\n            e.CellStyle.BackColor = Color.FromName(\"window\");\n            DataGridViewTextBoxEditingControl editingControl = e.Control as DataGridViewTextBoxEditingControl;\n            editingControl.TextChanged += new EventHandler(EditingTB_LengthChanged);\n        }\n        \n    }\n\n    private void EditingTB_TypeChanged(object sender,EventArgs e)\n    {\n\n        //添加操作\n    }\n\n    private void EditingTB_LengthChanged(object sender,EventArgs e)\n    {\n        //添加操作\n    }\n```\n\n参考：[DataGridView的单元格内容即时更新方法](https://blog.csdn.net/lllljz/article/details/7717730)<br>\n注意点：要用dataGridView1.CurrentCell.EditedFormattedValue而不是dataGridView1.CurrentCell.Value\n\n### 2. string删除空格\n\n三种方式：\n​\tstring trim = Regex.Replace( text, @\"\\s\", \"\" ); \n\n```\nstring trim = text.Replace( \" \", \"\" );  \ntrim = trim.Replace( \"\\r\", \"\" );  \ntrim = trim.Replace( \"\\n\", \"\" );  \ntrim = trim.Replace( \"\\t\", \"\" ); \n\nstring text = \"  My test\\nstring\\r\\n is\\t quite long  \";  \nstring trim = text.Trim(); \n```\n\n### 3. 获取系统时间\n\n`DateTime.Now.ToString(\"f\");//不显示秒`\n\n参考：[C#获取当前系统时间](https://blog.csdn.net/lingyb011/article/details/5946351)\n\n### 4. 导出文件不能立即在目标目录显示文件\n\n解决方法：将包含savefiledialog的窗体显示从showdialog改为show\n\n### 5. 如何实现DataGridViewTextBox自动把小写转化为大写？\n\n同样用到EditingControlShowing这个事件，另外在DataGridViewTextBox中只需要设置某一列的CharacterCasing为Upper就行。<br>\n具体实现\n​\t\n\n```\n DataGridView dgv = (DataGridView)sender;\n        if (e.Control is DataGridViewTextBoxEditingControl)\n        {\n            DataGridViewTextBoxEditingControl editingControl = (DataGridViewTextBoxEditingControl)e.Control;\n            if (dgv.CurrentCell.OwningColumn.Name == \"fieldName\")\n            {\n                editingControl.CharacterCasing = CharacterCasing.Upper;\n            }\n            else\n            {\n                editingControl.CharacterCasing = CharacterCasing.Normal;\n            }\n        }\n```\n\n","tags":["C#实战"]},{"title":"C#数据库工具开发（八）","url":"/2019/01/09/C-数据库工具开发（八）/","content":"\n# C#数据库工具开发（八）\n\n## 问题（07/19）\n\n### 1. 如何实现拖拽文件到textbox获取文件路径？\n\n利用textbox两个事件：dragenter和dragdrop\n具体实现\n\n```\n\tprivate void filePath_DragEnter(object sender, DragEventArgs e)\n    {\n        if (e.Data.GetDataPresent(DataFormats.FileDrop))\n        {\n            e.Effect = DragDropEffects.Link;\n        }\n        else\n        {\n            e.Effect = DragDropEffects.None;\n        }\n    }\n```\n\n```\nprivate void filePath_DragDrop(object sender, DragEventArgs e)\n{\nstring path = ((System.Array)e.Data.GetData(DataFormats.FileDrop)).GetValue(0).ToString();\n        filePath.Text = path;\n}\n```\n\n### 2. 数据库如何增删改字段？\n\n只考虑SQLServer和Oracle，增加和删除字段可用相同sql语句,修改字段略有不同：<br>\n增加：\n`sql = @\"use \" + DBName + \"; ALTER TABLE \" + tableName + \" ADD \" + fieldName + \" \" + fieldType + \"(\" + fieldLength + \");\";`<br>\n删除：\n`sql = @\"use \" + DBName + \"; ALTER TABLE \" + tableName + \"  DROP COLUMN \" + fieldName + \";\";`<br>\n修改：<br>\nSQLSerer：`sql = @\"use \" + DBName + \"; ALTER TABLE \" + tableName + \" ALTER COLUMN \" + fieldName + \" \" + fieldType + \"(\" + fieldLength + \");\";`<br>\nOracle:`sql = @\"ALTER TABLE \" + tableName + \" modify(\" + fieldName + \" \" + fieldType + \"(\" + fieldLength + \"))\";`\n\n### 3. 如何导出文件？\n\n使用SaveFileDialog控件<br>\n具体实现：\n\n```\n\t\tSaveFileDialog saveFileDialog1 = new SaveFileDialog();\n        saveFileDialog1.Filter = \"TXT|*.txt\";\n        saveFileDialog1.Title = \"选择导出sql记录的存储路径\";\n        saveFileDialog1.ShowDialog();\n\n        // If the file name is not an empty string open it for saving.  \n        if (saveFileDialog1.FileName != \"\")\n        {\n            // Saves the Image via a FileStream created by the OpenFile method.  \n            System.IO.FileStream fs =\n               (System.IO.FileStream)saveFileDialog1.OpenFile();\n            // Saves the Image in the appropriate ImageFormat based upon the  \n            // File type selected in the dialog box.  \n            // NOTE that the FilterIndex property is one-based.  \n            StreamWriter sw = new StreamWriter(fs);\n            foreach(string result in sqlcommands)\n            {\n                sw.WriteLine(result);\n            }\n\n            //清空缓冲区\n            sw.Flush();\n            //关闭流\n            sw.Close();\n            \n            fs.Close();\n        }\n```\n\n### 4. 如何给DataGridView增加行号\n\n```\nprivate void dataXML_RowPostPaint(object sender, DataGridViewRowPostPaintEventArgs e)\n    {\n        var grid = sender as DataGridView;\n        var rowIdx = (e.RowIndex + 1).ToString();\n\n        var centerFormat = new StringFormat()\n        {\n            // right alignment might actually make more sense for numbers\n            Alignment = StringAlignment.Center,\n            LineAlignment = StringAlignment.Center\n        };\n\n        var headerBounds = new Rectangle(e.RowBounds.Left, e.RowBounds.Top, grid.RowHeadersWidth, e.RowBounds.Height);\n        e.Graphics.DrawString(rowIdx, this.Font, SystemBrushes.ControlText, headerBounds, centerFormat);\n    }\n```","tags":["C#实战"]},{"title":"C#数据库工具开发（七）","url":"/2019/01/09/C-数据库工具开发（七）/","content":"\n# C#数据库工具开发（七）\n\n## 问题（07/18）\n\n### 1. 返回登录界面\n\n程序入口是登录界面，登录成功后隐藏登陆界面，显示主界面。现在想要实现点击主界面的按钮，返回登录界面。\n\n思路一：\n登录成功后，hide登录界面，new主界面。点击back按钮，hide主界面，show登陆界面。再次点击登陆，更新（reload）主界面<br>\n有两个问题，第一为了防止之后反复创建新的主界面，我把主界面先作为登陆界面属性创建，在login按钮事件中，只是添加参数，将其显示出来。可以增加一个静态变量isShown表示主界面是hide还是show。问题在于，主界面的load方法只在一开始调用，要想办法实现主界面的重新加载。<br>\n第二，主界面hide之后如何重新show登录界面。已知能用委托实现。\n\n思路二：\n登录成功后，hide登陆界面，new主界面。点击back按钮，close主界面，show登录界面。再次点击登录，新建(new)主界面<br>\n同样有两个问题，第二，我想保留当主界面close时，整个程序exit这个特性，所以我在FormMainOrcl_FormClosed事件中，有`Application.Exit();`，但是form.close()方法，也会引起这个事件的响应，这就导致点击back按钮后，整个程序都退出了。<br>\n第二，与思路一第二点一致\n\n目前暂时能想到的解决方案：<br>\n不保留主界面close，程序exit这个设定，程序只有在登陆界面退出时才退出。\n\n**改进的实现思路二的方案：**<br>\n在主界面添加变量justback，默认false，若点击back按钮，将justback设为true，在formclosed事件中判断justback，可以跳过程序退出。\n对于第二点，不用委托，更简单的实现方法\n在登录界面中\n\n```\nthis.Hide();\nFormMainTableShow formMain = new FormMainTableShow();\nformMain.Tag = this;\nformMain.Show();\n```\n\n在主界面中\n\n```\nFormLogin login = (FormLogin)this.Tag;\nlogin.Show();\nthis.Close();\n```\n\n### 2. 设置16进制颜色值\n\n例子：\n`Color color=ColorTranslator.FromHtml(\"#CE76D1\");`\n\n### 3. 调用资源文件\n\n例子：\n`XElement root = XElement.Parse(Resources.ResourceManager.GetObject(\"XMLTypeOracle\") as string);`","tags":["C#实战"]},{"title":"C#数据库工具开发（六）","url":"/2019/01/09/C-数据库工具开发（六）/","content":"\n# C#数据库工具开发（六）\n\n## 问题（07/17）\n\n### 1. 两个list的互相比较\n\n背景：我要比较两个DataGridView中多列值，可转变为两列list的互相比较<br>\n\n我的简单实现：<br>\n用多次foreach循环，设置一个标签find=false；找到改为ture；实现查找两个lists中有哪些不同项。<br>\n这样做能在循环中找到不同项和差项时，直接进行操作。可能存在问题是对于大量数据效率低，好在我这里只要比较数据库某个表中的字段名称，类型和长度。\n\n其他实现：<br>\n[C# Linq获取两个List或数组的差集交集](https://www.cnblogs.com/greatverve/archive/2012/03/29/csharp-list-linq-Intersection.html)<br>\n这样做的话，要先把DataGridView中的列存入list，linq取到差集后，再在DataGridView中定位差集中的元素，再进行操作。好处是linq在普通方法实现list比较时，效率高，对大量数据也适用。<br>\n*考虑之后学习linq，尝试实现。*\n\n### 2. CHARACTER_MAXIMUM_LENGTH返回值为空\n\n`string length = (reader.IsDBNull(2)) ?  \"\": Convert.ToString(reader.GetInt32(2));`<br>\nsqlserver数据库中，CHARACTER_MAXIMUM_LENGTH查询结果为空，但是返回值不能用reader.GetInt32(2)==null来判断。原因是数据库中的null和字符串中的null是不同类型的值，所以要用IsDBNULL来判断。","tags":["C#实战"]},{"title":"C#数据库工具开发（五）","url":"/2019/01/09/C-数据库工具开发（五）/","content":"\n# C#数据库工具开发（五）\n\n## 问题（07/16）\n\n### 1. `xml.load()`方法引发web exception未处理：远程服务器返回错误： ( 503 ) 服务器不可用异常\n\n解决方法：<br>\n\n1. 尝试从XHTML文件中删除 DOCTYPE，可能你有指向外部DTD的链接。<br>\n2. doc.XmlResolver = null;//this忽略 DTD\n\n### 2. sqlDataReader未关闭引发错误\n\n之前是直接拿sqlDataReader作返回值，但是sqlDataReader需要及时关闭，不然会导致二次调用同一方法引起异常。<br>\n好的写法是：把sqlDataReader读到的数据存入dataTable中，关闭sqlDataReader，返回dataTable。","tags":["C#实战"]},{"title":"C#数据库工具开发（四）","url":"/2019/01/09/C-数据库工具开发（四）/","content":"\n# C#数据库工具开发（四）\n\n## 问题（07/13）\n\n### 1. SQL查询某个表中所有字段名和字段类型\n\nSQLServer：<br>\n\n```\nstring sql = @\"USE \" + DBName+ \"; select COLUMN_NAME,DATA_TYPE,CHARACTER_MAXIMUM_LENGTH,IS_NULLABLE from INFORMATION_SCHEMA.COLUMNS t where t.TABLE_NAME =  '\" + TableName+\"';\";\n```\n\nOracle:<br>\n\n```\nstring sql = @\"select column_name, data_type from user_tab_columns where table_name = '\"+TableName+\"'\";\n```\n\n### 2. Linq to XML解析半闭合标签的XML文件有问题\n\n**看（五）**<br>\nlinq需要学习\n\n### 3. XML Document System.Net.WebException异常\n\n在`XmlDocument doc = new XmlDocument();doc.Load(path);`之间加断点调试会引发上述异常。正常调试没问题。\n\n### 4. C#string操作\n\n常用方法<br>\nsplit：按字符分割返回一个string数组<br>\nsubstring：获取部分字符串\n\n","tags":["C#实战"]},{"title":"C#数据库工具开发（三）","url":"/2019/01/09/C-数据库工具开发（三）/","content":"\n# C#数据库工具开发（三）\n\n## 问题（07/11-07/12）\n\n### 1. 在实现ConfigerManager时，把实现都放在了登陆界面的事件函数中，没能很好的分离功能（待解决）\n\n虽然尝试了把这部分功能分离出来，但是最多把保存登陆信息和伴随用户选择更改登陆信息这两部分放到Configer工具类中，后者要用至少4个引用参数来为窗口中的控件提供Text值。而对于登录界面默认加载最近登录信息的功能，则需要更多参数来实习，考虑了一下又改回之前的实现方案。\n\n### 2. 连接oracle服务器时，提示System.ComponentModel.Win32Exception: 安全包中没有可用的凭证异常。\n\n应该是安全认证方面的问题，解决方法是：win10用户退出微软登录账号，改用本地账号。不理解是为什么。\n\n### 3. ORA-00911:无效字符\n\n连接成功后执行Oracle的sql语句，报错信息包含这样的错误。解决方法是：去掉sql语句结束的`;`分号。分号对与SQL Server的语句执行无影响。","tags":["C#实战"]},{"title":"C#数据库工具开发（二）","url":"/2019/01/09/C-数据库工具开发（二）/","content":"\n# C#数据库工具开发（二）\n\n## 问题（07/09-/07/11）\n\n### 1. 数据库连接的开关，需要确认连接状态\n\n为了避免之后执行sql查询等操作时反复连接数据库，我把数据库连接打开和关闭分成两个方法，在登录成功时打开连接，一直到程序结束前断开连接。同时为了避免多次打开同一连接，需要在打开前先确认连接状态。\n\n### 2. 执行SQL语句是忽略关键字GO\n\n问题发生在使用SQL语句进入特定数据库时。虽然在实际数据库中可以使用，但用C#连接的SQL server不识别GO。\n解决方法也很简单，`use 数据库名`之后不加GO，加`;`就行。<br>\n更好的解决方法：[处理批量sql语句](http://jingpin.jikexueyuan.com/article/45383.html)<br>\nps：记录一种查询服务器中所有数据库 和 两种查询特定数据库中所有表的SQL语句：\n查数据库：`Select Name FROM Master.dbo.SysDatabases ORDER BY Name;`\n查表法一：`select name from sysobjects where xtype='U' order by name;`\n查表法二：`SELECT table_name FROM information_schema.tables WHERE table_type = 'base table'`\n[详细1](https://blog.csdn.net/u012643122/article/details/44039155#t5)\n[详细2](https://www.quora.com/What-is-the-SQL-query-to-find-all-table-names-present-in-a-database#)\n\n### 3. 存储sql执行语句结果的两种方式\n\n法一用SqlDataAdapter\n\n```\n\tDataSet ds = new DataSet();\n\tSqlDataAdapter sAdapter = new SqlDataAdapter(sql, sqlConnection);\n\tsAdapter.Fill(ds);\n```\n\n法二用SqlDataReader<br>\n`SqlDataReader sRead = cmd.ExecuteReader();`<br>\n这两种方法的[主要区别](https://www.cnblogs.com/carekee/articles/2094789.html)\n\n### 4. 查询结果如何在主窗口正确显示？\n\n最开始使用的ListView控件，通过添加listviewitem显示字段。具体方法如下：\n\n```\nListViewItem li = new ListViewItem();\n            li.SubItems.Clear();\n            li.SubItems[0].Text = reader[\"name\"].ToString();\n            li += new EventHandler(this.dbItem_DoubleClick);\n            DBList.Items.Add(li);\n```\n\n这种方法问题在于，我想实现点击item（字段）显示对应的表名或表结构，但是很难为item添加事件。<br>\n解决措施：\n换用DataGridView控件，好处在于:第一，这个控件本来就是为数据库显示服务的，获得DataSet之后用`dataView.DataSource = ds.Tables[0].DefaultView;`就可以显示完整表单。第二，通过CurrentCellChanged事件就可以很方便实现点击显示对应表单的效果。","tags":["C#实战"]},{"title":"C#数据库工具开发（一）","url":"/2019/01/09/C-数据库工具开发（一）/","content":"\n# C#数据库工具开发（一）\n\n## 源码\n\n查询我的Github：[DBTool](https://github.com/xiaotong1996/DBTool)\n\n## 开发日程\n\n1. 2019/07/09-/07/11</br>\n   sql server数据库连接+登录界面<br>\n   主界面+表单查询和显示\n2. 07/11-07/12</br>\n   登录配置文件<br>\n   oracle数据库连接\n3. 07/13-07/13<br>\n   读取保存数据库字段属性<br>\n   读取保存xml解析数据<br>\n   部分实现利用xml解析数据同步数据库（添加表）<br>\n   为主界面添加控件\n4. 07/13-07/13<br>\n   部分实现xml字段到sql字段映射<br>\n   xml导入配置页面<br>\n   部分实现利用xml解析数据同步数据库\n5. 07/16-07/16<br>\n   sql server和oracle数据库连接重构（sqlDataReader改用）<br>\n   xml导入创建新表<br>\n   部分实现xml与DB字段比较\n6. 07/17-07/17<br>\n   为比较页面（xml执行页面）添加字段长度项<br>\n   优化xml与DB字段比较<br>\n   用配置文件实现XML中字段类型映射<br>\n   界面优化\n7. 07/18-07/18<br>\n   增加logo<br>\n   增加数据库检索<br>\n   将SQL和Oracle显示table界面合二为一，删除SQL显示table界面中显示数据库的表（该功能与数据库检索重复)<br>\n   将字符串映射文件加入资源中\n8. 07/19-07/19<br>\n   更换logo，调整窗体<br>\n   增加拖拽文件直接加载功能<br>\n   优化字符串映射功能，避免bug<br>\n   对比界面自动刷新,优化显示<br>\n   增加同步数据库功能<br>\n   增加导出sql语句功能<br>\n9. 07/20-07/20<br>\n   优化对比界面更改字段事件<br>\n   优化导出sql语句功能，避免线程卡死<br>\n   添加xml显示界面手动添加或删除字段并刷新比对的功能\n10. 07/24-07/24<br>\n    优化添加表完成后字段页面同步刷新<br>\n    优化添加表完成后导出sql语句<br>\n    优化添加表完成后表显示页面刷新<br>\n    修复修改字段不显示的bug<br>\n    新增特性返回表显示页面自动定位到最新改动的table\n11. 07/25-07/27<br>\n    添加索引列，新增设置索引功能<br>\n    增加索引同步功能（包括索引的增加、删除）<br>\n    重写数据库同步xml部分，优化索引的建立删除，使其能像其他字段一样简单使用<br>\n    xml执行界面添加用户误操作的警告和提示（如，用户添加字段名相同的行）\n12. 07/30-08/01<br>\n    优化对比界面(更好的对比显示，实现左右页面同步滚动）<br>\n    简化用户操作(现在不用点击就可以选到鼠标指定行，删除操作也更方便）<br>\n    更改logo\n13. 08/01-08/03<br>\n    添加单行同步与撤销操作功能\n\n## 主要构成\n\n1. DBconnection：<br>\n   **SQLServer数据库连接工具类**<br>\n   主要功能：配置连接信息；打开、关闭数据库连接；执行sql语句获得结果（以ShowDatabaseList方法为例，用sql语句查询服务器中所有数据库名，将该结果存入sRead供前端窗口调用显示）\n2. FormLogin：<br>\n   **登录窗口**<br>\n   主要功能：获取连接信息\n   更新：\n   - 保存连接信息（记住密码）\n   - 检索数据库（用于选择登入那个数据库） \n3. FormMainTableShow：<br>\n   **主窗口**<br>\n   主要功能：主要逻辑业务的展示和执行界面，包含各种响应事件（第一阶段后可查看连接到远程数据库中所有表格）<br>\n   更新：\n   - 改为只用来展示数据库中所有表名和显示表信息\n   - 提供选择xml文件的入口\n4. ConfigerManager：<br>\n   **登陆信息实体类**<br>\n   主要功能：方便实现存储登录记录*实现写在FormLogin各种事件中*\n5. DBconnnectionOracle：<br>\n   **Oracle数据库连接工具类**<br>\n   主要功能：与DBconnection相似\n6. FormXMLExecute：<br>\n   **主要功能窗口**<br>\n   主要功能：解析显示xml表结构，提供添加或同步数据库表/表结构的功能,提供修改xml列表实时验证两表差异性的功能<br>\n7. MappingTool：<br>\n   **映射java类型到数据库的字段类型的工具类**\n   主要功能：解析保存映射信息的xml，将java类型，转换成保存数据库字段类型和对应默认字段长度的Dictionary。\n8. XMLParsing：<br>\n   **解析提供表结构的xml的工具类**<br>\n   主要功能：将xml保存的表结构，解析出表名和字段名，字段类型\n9. ParsedInfo：<br>\n   **xml信息的实体类**<br>\n   主要功能：保存xml解析出来的表结构信息\n10. DBmodify：<br>\n    **执行增删改数据库字段、增删索引的工具类**<br>\n11. RowRecord:<br>\n    **记录DGV中行信息的实体类**<br>\n    主要功能：保存对xml显示部分增删改之前的行信息，用于实现撤销操作\n\n\n\n## 参考页面\n\n1. [关于数据库表结构](https://www.xxling.com/blog/article/58.aspx)\n\n","tags":["C#实战"]},{"title":"深入理解C#（十六）：Lambda表达式和表达树","url":"/2019/01/09/深入理解C-（十六）：Lambda表达式和表达树/","content":"\n# 深入理解C#（十六）\n\n*第九章（C# 3：Lambda表达式和表达树）<br>\nlambda=λ\n\n## 作为委托的lambda表达式\n\n### Func<...>委托类型简介\n\n.NET3.5的System命名空间中，有5个泛型Func委托类型。\n每个委托签名都获取0~4个参数，其类型使用类型参数来指定。最后一个类型参数用作每种情况下的返回类型。<br>\n例如：Func<string,double,int>等价于`public delegate int SomeDelegate(string arg1,double arg2)`\n\n### 转换成lambda表达式\n\n用匿名方法来创建委托实例\n\n```\nFunc<string,int> returnLength;\nreturnLength=delegate(string text){return text.Length;};\nConsole.WriteLine(returnLength(\"Hello\"));\n```\n\nLambda表达式最冗长的形式是：<br>\n`(显示类型的参数列表）=》{语句}`\n例子：\n\n```\nFunc<string, int> returnLength;\nreturnLength = (string text) => { return text.Length; };\n\nConsole.WriteLine(returnLength(\"Hello\"));\n```\n\nLambda表达式有着和匿名方法控制返回语句一样的规则：不能从Lambda表达式返回void类型\n\n### 使用单一表达式作为主体\n\n大多数情况可以用一个表达式来表示整个主体，该表达式的值是Lambda的结果\n\n```\n（string text)=>text.Length\n```\n\n### 隐式类型的参数列表\n\n编译器能推断出参数类型，可以不用显示声明参数类型，**注意：**隐式和显示类型参数不能一起用。此外要是有out或ref参数，只能使用显示参数。\n\n```\n(text)=>text.Length\n```\n\n### 单一参数的快捷语法\n\n如果lambda表达式只需要一个参数，且那个参数可以隐式指定类型，可以省略圆括号\n\n```\ntext=>text.Length\n```\n\n现在，例子简化成：\n\n```\n Func<string, int> returnLength;\nreturnLength =  text =>  text.Length;\n\nConsole.WriteLine(returnLength(\"Hello\"));\n```\n\n*高阶函数*<br>\nLambda表达式主体可以包含另一个Lambda表达式，另外，Lambda表达式的参数可以是另一个委托\n\n## 使用List<T>和事件的简单例子\n\n### 列表的过滤、排序和操作\n\nList<T>的FindAll方法，获取一个Predicate<T>,并返回一个新列表，包含原始列表中与谓词匹配的所有元素。Sort方法获取一个Comparison<T>,并相应地对列表进行排序。ForEach方法获取一个Action<T>,并对每个元素执行特定行为。\n\n```\nvar films = new List<Film>\n{\n    new Film {Name=\"Jaws\", Year=1975},\n    new Film {Name=\"Singing in the Rain\", Year=1952},\n    new Film {Name=\"Some like it Hot\", Year=1959},\n    new Film {Name=\"The Wizard of Oz\", Year=1939},\n    new Film {Name=\"It's a Wonderful Life\", Year=1946},\n    new Film {Name=\"American Beauty\", Year=1999},\n    new Film {Name=\"High Fidelity\", Year=2000},\n    new Film {Name=\"The Usual Suspects\", Year=1995}\n};\n\nAction<Film> print =\n    film => Console.WriteLine(\"Name={0}, Year={1}\", film.Name, film.Year);\n\n// Note: extra lines added for clarity when running\nConsole.WriteLine(\"All films\");\nfilms.ForEach(print);\nConsole.WriteLine();\n\nConsole.WriteLine(\"Oldies\");\nfilms.FindAll(film => film.Year < 1960)\n     .ForEach(print);\nConsole.WriteLine();\n\nConsole.WriteLine(\"Sorted\");\nfilms.Sort((f1, f2) => f1.Name.CompareTo(f2.Name));\nfilms.ForEach(print);\n\nConsole.Read();\n```\n\n创建委托实例,用来打印列表中的项，因为之后会使用三次，所以用变量print来保存，而不用每次都单独使用一个Lambda表达式。它可以打印一个film类型，通过foreach就能打印整个列表。\n`Action<Film> print = film => Console.WriteLine(\"Name={0}, Year={1}\", film.Name, film.Year);`\n\n```\n`films.ForEach(print);`\n```\n\n### 在事件处理程序中进行记录\n\n```\nstatic void Log(string title, object sender, EventArgs e)\n{\n    Console.WriteLine(\"Event: {0}\", title);\n    Console.WriteLine(\"  Sender: {0}\", sender);\n    Console.WriteLine(\"  Arguments: {0}\", e.GetType());\n    foreach (PropertyDescriptor prop in\n             TypeDescriptor.GetProperties(e))\n    {\n        string name = prop.DisplayName;\n        object value = prop.GetValue(e);\n        Console.WriteLine(\"    {0}={1}\", name, value);\n    }\n}\n\nstatic void Main()\n{\n    Button button = new Button();\n    button.Text = \"Click me\";\n    button.Click += (src, e) => Log(\"Click\", src, e);\n    button.KeyPress += (src, e) => Log(\"KeyPress\", src, e);\n    button.MouseClick += (src, e) => Log(\"MouseClick\", src, e);\n\n    Form form = new Form();\n    form.AutoSize = true;\n    form.Controls.Add(button);\n    Application.Run(form);\n}\n```\n\n## 表达式树\n\n### 以编程方式构建表达式树，编译并执行\n\n```\nExpression firstArg = Expression.Constant(2);\nExpression secondArg = Expression.Constant(3);\nExpression add = Expression.Add(firstArg, secondArg);\n\nFunc<int> compiled = Expression.Lambda<Func<int>>(add).Compile();\nConsole.WriteLine(compiled());\nConsole.Read();\n```\n\n### 将C# Lambda表达式转换成表达式树\n\n```\nExpression<Func<int>> return5 = () => 5;\nFunc<int> compiled = return5.Compile();\nConsole.WriteLine(compiled());\n```\n\n（）=》 5是Lambda表达式","tags":["C#"]},{"title":"深入理解C#（十五）：智能编译器","url":"/2019/01/09/深入理解C-（十五）：智能编译器/","content":"\n# 深入理解C#（十五）\n\n*第八章（C# 3：用智能的编译器来防错）<br>\n\n## 自动实现的属性\n\n简化普通属性的代码<BR>\n普通属性：可读/可写并将值存储到一个非常直观的私有变量中的属性。\n\n```\npublic string Name{get;set;}\n```\n\n仍然可以为取值和赋值方法指定不同的访问权限。\n\n静态自动属性：取值方法是共有的，赋值方法是私有的，且赋值方法只能在类型初始化程序中使用。\n\n**定义struct时，使用自动属性，需要显式地调用无参构造函数**\n\n```\npublic struct Foo\n{\n\tpublic int Value{get;private set;}\n\tpublic Foo(int value):this()\n\t{\n\t\tthis.Value=value;\n\t}\n}\n```\n\n自动属性仍有几个小问题：\n\n1. 没办法在声明时，设定初始的默认值\n2. 没法把它们设定成真正的只读属性（使用私有赋值方法来解决）\n\n## 隐式类型的局部变量\n\n### 使用var声明局部变量\n\n**var并没有把C#变成动态类型或者弱类型的语言，只是类型由编译器推断**<br>\n编译器获取初始化表达式在编译时的类型，并使变量也具有那种类型。\n\n### 隐式类型的限制\n\n只有在一下情况能使用：\n\n- 局部变量，不是静态字段和实例字段\n- 声明的同时被初始化\n- 初始化表达式不是方法组和匿名函数\n- 初始化表达式不是null\n- 语句中之声明了一个变量\n- 初始化表达式不包含正在声明的变量\n\n对于第三点，显示声明变量是可以的，如：\n`var starter = (ThreadStart)delegate(){ Console.WriteLine();}`\n对于null也可以做强制类型转换，但是无意义。\n\n最常见应用：用方法调用的结果来初始化一个变量。\n\n### 隐式类型的优缺点\n\n优点：增强可读性，改变代码重心\n缺点：类型不明确\n\n## 简化的初始化\n\n### 定义示例类型\n\n`new Person{Name=\"Jon\",Age=36}`\n\n### 为嵌入对象设置属性\n\n```\nPerson tom=new Person(\"Tom\"){\nAge=9,\nHome={Country=\"UK\",Town=\"Reading\"}\n};\n```\n\n### 集合初始化程序\n\n1. 使用集合初始化程序来创建新集合\n   `List<string> names=new List{ \"Holly\",\"Jon\",\"Tom\"};`\n   任何实现了IEnumerable类型，只要它为初始化列表中出现的每个元素都提供了一个恰当的公共的Add方法，就可以使用这个特性。\n2. 在其他对象初始化程序中填充集合\n\n## 隐式类型的数组\n\n对于`void MyMethod(string[] names)`\nC#3 这样使用：<br>\n`MyMethod(new[] {\"Holly\",\"Jon\",\"Tom\"});`\n\n## 匿名类型\n\n实例：使用匿名类型，填充数组\n\n```\nvar family = new[]\n{\n    new { Name = \"Holly\", Age = 37 },\n    new { Name = \"Jon\", Age = 36 },\n    new { Name = \"Tom\", Age = 9 },\n    new { Name = \"Robin\", Age = 6 },\n    new { Name = \"William\", Age = 6 }\n};\n\nint totalAge = 0;\nforeach (var person in family)\n{\n    totalAge += person.Age;\n}\nConsole.WriteLine(\"Total age: {0}\", totalAge);\n```\n\nfamily中所有人具有相同的类型，否则编译器无法推断出何时类型。\n\n### 匿名类型的成员\n\n- 一个获取所有初始值的构造函数\n- 共有的只读属性\n- 属性的私有只读字段\n- 重写的Equals、GethashCode和ToString\n\n### 投影初始化程序\n\n实际使用时，往往希望从别的对象复制属性用以新建一个新的对象。 例如：`new { Name=person.Name,IsAdult=(person.Age>=18)}`\nC# 3支持一种简化的语法：如果不指定属性名称，而只指定用于求指的表达式，它会使用表达式的最后一个部分作为名称，前提是它只是一个简单字段或属性。<br>\n应用：`new { person.Name, IsAdult=(Person.Age>=18)}`","tags":["C#"]},{"title":"深入理解C#（十四）：其他特性","url":"/2019/01/09/深入理解C-（十四）：其他特性/","content":"\n# 深入理解C#（十四）\n\n*第七章（C# 2：其他特性）<br>\n**分部类型，静态类，独立的取值方法，命名空间别名，Pragma指令，固定大小的缓冲区，InternalsVisibleToAttribute（友元程序集）**\n\n## 分部类型\n\n### 在多个文件中创建一个类型\n\n创建分部类型，只需要加上partial关键字。编译器实际上是在编译之前把所有源文件合并在一起。（这就是为什么C#文件名和类名可以不一致了，同样一个class Example，可以用分部类型，写多个Example1/2/...cs文件\n\n举例：\n\n```\n partial class Example<TFirst, TSecond>\n    : IEquatable<string>\n    where TFirst : class\n{\n    public bool Equals(string other)\n    {\n        return false;\n    }\n}\n```\n\n在这个文件中声明接口和类型参数约束\n\n```\n partial class Example<TFirst, TSecond>\n    : EventArgs, IDisposable\n{\n    public void Dispose()\n    {\n    }\n}\n```\n\n在这个文件中声明基类和接口\n\n### 分布类型的使用\n\n分布类型的用途：<br>\n\n1. 主要联接设计器和其他代码生成器\n2. 辅助进行重构\n3. 单元测试\n\n## C# 3的分部方法\n\n分部方法的声明与抽象方法相同:<br>\n使用partial修饰符无须实现，在实际的实现部分也要partial修饰符。<br>\n分部方法可以不被实现，这些未被实现的分部方法的调用会被编译器移除。<br>\n由于方法可能不存在，分部方法返回类型必须为void，且不能获取out参数。必须是私有的\n\n## 静态类型\n\n## 独立的取值方法/赋值方法属性访问器\n\n举例：\n​\t\n\n```\nstring name;\npublic string Name\n{\n\tget{return name;}\n\tprivate set{ name=value;}\n}\n```\n\nName属性对于其他所有类型都是只读的，但在类型内部能用属性语法设置。<br>\n**大部分的默认访问修饰符是私有的，但对于取值/赋值方法，访问修饰符和属性本身整体上保持一致**<br>\n**另外不能把属性设为私有，但把取值方法设为公有**\n\n## 命名空间别名\n\n### 限定的命名控件别名\n\nC# 1例子：\n​\t\n\n```\nusing System;\nusing System.ComponentModel;\nusing WebForms = System.Web.UI.WebControls;\nusing WinForms = System.Windows.Forms;\n\nnamespace Chapter07\n{\n[Description(\"Listing 7.05\")]\nclass SimpleAliases\n{        \n    static void Main()\n    {\n        Console.WriteLine (typeof (WinForms.Button));\n        Console.WriteLine (typeof (WebForms.Button));\n    }\n}\n}\n```\n\n若有一个类也叫WinForms，那编译器该如何区分？\nC# 2改进：\n\n```\nusing System;\nusing System.ComponentModel;\nusing WebForms = System.Web.UI.WebControls;\nusing WinForms = System.Windows.Forms;\n\nnamespace Chapter07\n{\n[Description(\"Listing 7.06\")]\nclass DoubleColonForAliases\n{\n    class WinForms\n    {\n    }\n    \n    static void Main()\n    {\n        Console.WriteLine (typeof (WinForms::Button));\n        Console.WriteLine (typeof (WebForms::Button));\n    }\n}\n}\n```\n\n引入“::“来区分命名空间和类型\n\n### 全局命名空间别名\n\n无法为命名空间层级的根或全局命名空间定义别名。<BR>\n可以使用`global::`\n\n### 外部别名\n\n## pragma指令\n\npragma指令是一个由`#pragma`开头的代码行所表示的预处理指令，它后面能包含任何文本。\n\n### 警告pragma\n\n举例：例如我们使用了一个从未使用的变量，但想要忽略编译器警告\n\n```\n#pragma warning disable 0169\nint x;\n#pragma warning restore 0169\n```\n\n### 校验和pragma\n\n## 非安全代码中固定大小的缓冲区\n\n## 把内部成员暴露给选定的程序集\n\n\n\n","tags":["C#"]},{"title":"深入理解C#（十三）：迭代器","url":"/2019/01/09/深入理解C-（十三）：迭代器/","content":"\n# 深入理解C#（十三）\n\n*第六章（C# 2：实现迭代器的捷径）<br>\n\n## 知识简介\n\n迭代器模式：行为模式的一种范例，允许访问一个数据项序列中的所有元素，而不用关心序列的类型。能有效构建一个数据管道。(数据项序列进入数据管道后，经过一系列不同的转换或过滤后再从另一端出来）<br>\n行为模式：一种简化对象之间通信的设计模式\n\n迭代器模式通过IEnumerator和IEnumerable接口以及它们的泛型等价物来封装。若某个类型实现了IEnumerable接口，就意味着它可以被迭代访问。\n\n难点在于怎么自建迭代器\n\n## C# 2：利用yield语句简化迭代器\n\n利用C# 2和yield return来迭代实例集合：\n\n```\npublic IEnumerator GetEnumerator()\n{\n\tfor(int index=0;index<values.Length;index++)\n\t{  yield return values[(index+startingPoint)%values.Length];\n\t}\n}\n```\n\n这是一个实现迭代器块的方法，这个方法被声明为返回一个\nIEnumerator接口，所以就只能使用迭代器块来实现返回类型为IEnumerable、IEnumerator等的方法。如果方法声明的返回类型是非泛型接口，那么迭代器块的生成类型(yield type)是object，否则就是泛型接口的类型参数。如：方法声明返回IEnumerable<string>,就会得到string类型的生成类型。<BR>\n*在迭代器块中存在try/catch或try/finally代码块时，不能在try和finally中使用yield return*<BR>\n**编写迭代器块代码实际上是在请求编译器创建一个状态机**<BR>\n当编译器看到迭代器块时，会为状态机创建一个嵌套类型，来正确记录块中的位置，以及局部变量（包括参数）的值。<BR>\n这个状态机实现一下功能：\n\n- 必须具有某个初始状态\n- 每次调用MoveNext，提供下一个值之前（执行到yield return语句之前），执行GetEnumerator方法中的代码\n- 使用Current属性时，返回生成的上一个值\n- 知道何时完成生成值的操作，以便MoveNext返回false\n\n### 迭代器的工作流程\n\n- 在第一次调用MoveNext之前，CreateEnumerable不会被调用\n- 所有工作在调用MoveNext时就完成了，获取Current的值，不执行任何代码\n- 在yield return的位置，代码就停止执行，在下一次调用MoveNext时又继续执行\n- 在一个方法中的不同地方可以编写多个yield return语句\n- 代码不会在最后的yield return处结束，而是通过返回false的MoveNext调用来结束\n\n### 进一步了解\n\nyield return语句临时推出了方法，知道再次调用MoveNext后继续执行，根本没有检查finally代码块的行为。<BR>\n*迭代器块不能实现具有ref或out参数的方法*<BR>\nyield break结束迭代器的执行,类似于普通方法中的return语句<BR>\nfinally在迭代器块中常用于释放资源，通常与using语句配合使用\n\n## 迭代器示例\n\n### 迭代时刻表中的日期\n\nC# 1\n\n```\nfor(DataTime day=timetable.StartDate;\n\tday<=timetable.EndDate;\n\tday=day.AddDays(1))\n```\n\nC# 2\n​\tforeach(DateTime day in timetable.DateRange)\n想要手动实现迭代器很麻烦，但用迭代器块就很方便。为表示时刻表的类添加一个属性：\n\n```\npublic IEnumerable<DateTime> dateRange\n{\n\tget\n\t{\n\t\tfor(DateTime day=StartDate；\n\t\t\tday<=EndDate;\n\t\t\tday=day.AddDays(1))\n\t\t{\n\t\t\tyield return day;\n\t\t}\n\t}\n}\n```\n\n### 迭代文件中的行\n\n在.NET 4中，框架提供了reader.ReadLines来实现,如何自己轻松实现？\nC# 1\n\n```\nusing(TextReader reader=File.OpenText(filename))\n{\n\tstring line;\n\twhile((line=reader.ReadLine()) != null)\n\t{\n\t\t//针对line进行操作\n\t}\n}\n```\n\n- 获取TextReader\n- 管理TextReader的生命周期（using）\n- 迭代TextReader.ReadLine返回的行\n- 对这些行处理\n\n生命周期管理和迭代机制都是样板代码，有两种方法改进。<br>\n一。使用委托，编写一个工具方法，将阅读器和委托作为参数，为文件中的每一行调用该委托，最后关闭阅读器。<br>\n二。使用迭代器一次返回文件中的一行，如下\n\n```\npublic static IEnumerable<string> ReadLines(string filename)\n    {\n        using (TextReader reader = File.OpenText(filename))\n        {\n            string line;\n            while ((line = reader.ReadLine()) != null)\n            {\n                yield return line;\n            }\n        }\n    }\n\nforeach (string line in ReadLines(@\"文件路径\"))\n        {\n            Console.WriteLine(line);\n        }\n```\n\n进一步改进：如果我们想从网络流中读取文本或使用UTF-8以外的编码格式，最简单的想法是重新修改方法签名，使其接受一个TextReader。但这个方案很糟糕，问题是，如果在第一次调用MoveNext（）之前发生了异常，就没有机会清理了。另外，若GetEnumerate人（）被调用两次，但它们使用相同的阅读器。\n\n```\nstatic IEnumerable<String> ReadLines（Func <TextReader> provider)\n{\n\tusing (TextReader reader=provider())\n\t{\n\t\t。。。\n```\n\n### 使用迭代器块和谓词对进行延迟过滤\n\n**看过linq后回来重看**\n\n### CCR实现伪同步代码\n\nCCR（Concurrency and Coordination Runtime，并发和协调运行时）\n**看完异步开发回来看**\n\n​\t","tags":["C#"]},{"title":"深入理解C#（十二）：匿名方法","url":"/2019/01/09/深入理解C-（十二）：匿名方法/","content":"\n# 深入理解C#（十二）\n\n*第五章（C# 2：进入快速通道的委托（下））<br>\n**匿名方法**\n\n## 使用匿名方法的内联委托操作\n\nC# 1中的问题：用特定签名来实现委托是很常见的情况。有时只需要一个委托来做一件很简单的事，但是必须创建一个完整的新方法。\n\n匿名方法允许指定一个内联委托实例的操作，作为创建委托实例表达式的一部分。\n\n## 简单的匿名方法实例：处理一个参数\n\n.NET 2.0有一个泛型委托类型Action<T>,它的签名如下：<BR>\n`public delegate void Action<T>(T obj)`<br>\nAction<T>就是对T的一个实例执行某些操作。如Action<string>可以反转字符串并打印出来，Action<int>可以打印传给它的那个数的平方根，Action<IList<double>>可以计算出传给它的所有数的平均值并打印。<br>\n实例：\n\n```\nAction<string> printReverse = delegate (string text)\n{\nchar[] chars = text.ToCharArray();\nArray.Reverse(chars);\nConsole.WriteLine(new string(chars));\n};\n```\n\n匿名方法的语法：<br>\ndelegate关键字，参数，代码块（定义对委托实例的操作）匿名方法的结果是一个委托实例，和调用普通方法一样调用委托。\n\n```\nprintReverse(\"hello world\");\n```\n\n**逆变性不适用于匿名方法：必须指定和委托类型完全匹配的参数类型**\n\n匿名方法的是实现，是在IL中为源代码中断每个匿名方法创建一个方法\n\n一个更精简的极端例子：体现匿名方法的一般用法，即作为传给另一个方法的参数使用。\n\n```\nList<int> x = new List<int>();\nx.Add(5);\nx.Add(10);\nx.Add(15);\nx.Add(20);\nx.Add(25);\n\nx.ForEach(delegate (int n) { Console.WriteLine(Math.Sqrt(n)); });\n```\n\n### 匿名方法的返回值\n\n```\nPredicate<int> isEven = delegate (int x)\n        { return x % 2 == 0; };\n\nConsole.WriteLine(isEven(1));\nConsole.WriteLine(isEven(4));\n```\n\n没有必要再声明一个返回类型，因为编译器会检查是否所有可能返回值都兼容于委托类型声明的返回类型。\n\n### 忽略委托参数\n\n```\n class IgnoredParametersAnonymousMethods\n{\n    static void Main()\n    {\n        Button button = new Button();\n        button.Text = \"Click me\";\n        button.Click += delegate { Console.WriteLine(\"LogPlain\"); };\n        button.KeyPress += delegate { Console.WriteLine(\"LogKey\"); };\n        button.MouseClick += delegate { Console.WriteLine(\"LogMouse\"); };\n\n        Form form = new Form();\n        form.AutoSize = true;\n        form.Controls.Add(button);\n        Application.Run(form);\n    }\n}\n```\n\n一般写法：`button.Click+=delegate(object sender,EventArgs e){...}`\n\n## 匿名方法中的捕获变量\n\n匿名方法外部对变量的更改在匿名方法内部是可见的，反之亦然。\n\n```\nstatic void Main()\n{\nstring captured = \"before x is created\";\n\nMethodInvoker x = delegate\n{\n    Console.WriteLine(captured);\n    captured = \"changed by x\";\n};\n\ncaptured = \"directly before x is invoked\";\nx();\n\nConsole.WriteLine(captured);\n\ncaptured = \"before second invocation\";\nx();\nConsole.Read();\n}\n```\n\n**创建委托实例不会导致执行**<br>\n**在整个方法中，我们使用的始终是同一个captured变量**\n\n### 捕获变量的实际用处\n\n能简化避免专门创建一些类来存储一个委托需要处理的信息（除了作为参数传递信息之外）\n\n```\nList<Person> FindAllYoungerThan(List<Person> people,int limit)\n{\n\treturn people.FinaAll(delegate(Person person){ return person.Age<limit;});\n}\n```\n\n我们在委托实例内部捕获了limit参数，若不支持捕获变量，就不能使用作为参数传递的limit\n\n### 捕获变量的延长生存期\n\n**对于一个捕获变量，只要还有任何委托实例在引用它，它就会一直存在**\n\n### 局部变量实例化\n\n每声明一次局部变量，它就被实例化一次。\n\n### 捕获变量的使用规则和小结\n\n- 只在复杂情况下使用\n- 捕获有for或foreach语句声明的变量之前，思考委托是否需要在循环迭代结束后延续，不是则在循环内另建一个变量来复制想要的值。\n- 若创建多个委托实例，且捕获了变量，思考是否希望它们捕捉同一个变量\n- 如果捕获的变量不发生改变，无需担心","tags":["C#"]},{"title":"深入理解C#（十一）：改进的委托","url":"/2019/01/09/深入理解C-（十一）：改进的委托/","content":"\n# 深入理解C#（十一）\n\n*第五章（C# 2：进入快速通道的委托（上））<br>\n\n## 回顾C# 1中我们的做法\n\n总是先定义事件/委托实际要处理的方法，如：\n\n```\n  static void LogKeyEvent(object sender, KeyPressEventArgs e)\n    {\n        Console.WriteLine(\"LogKey\");\n    }\n```\n\n然后new一个新的事件/委托实例，把这个方法加到委托列表中，如：\n​\t\n\n```\n  button.KeyPress += new KeyPressEventHandler(LogKeyEvent);\n```\n\n我们总是要把委托实例实际执行的代码做参数穿给委托实例，这样绕弯子会使代码难以阅读，且使得类中填充了大量只用于委托的方法。\n\n## 方法组转换\n\nC# 2支持从方法组到一个兼容委托类型的隐式转换。方法组（method  group）其实就是一个方法名，可以选择添加一个目标，也就是说和C# 1中创建委托实例使用的表达式相同（含义不同，一个是类型加参数，一个是方法组）。新的隐式转换：\n​\t\n\n```\nbutton.KeyPress+=LogkeyEvent;\n```\n\n一个创建线程的代码：\n\n```\nThread t=new Thread(MyMethod);\n```\n\n为什么表达式如`LogKeyEvent`属于方法组，因为如果有重载的话，可能不止一个方法适用。隐式转换会将一个方法组转换为具有兼容签名的任意委托类型。<BR>\n假定有以下两个方法签名：\n\n```\nvoid MyMethod()\nvoid MyMethod(object sender,EventArgs e)\n```\n\n那么在向一个ThreadStart或EventHandler赋值时，都可以将MyMethod作为方法组使用：\n\n```\nThreadStart x=MyMethod;\nEventHandler y=MyMethod；\n```\n\n对于本身已重载成可以获取一个ThreadStart或EventHandler的方法，不能把它作为方法的参数使用。同样，不能利用隐式方法组转换来转换成普通的System.Delegate类型。可用辅助方法、强制转换或中间变量来解决。\n\n## 协变性和逆变性\n\n### 委托参数的逆变性\n\n举例说明：\n\n```\npublic delegate void EventHandler(object sender,EventArgs e)\npublic delegate void KeyPressEventHandler(object sender, KeyPressEventArgs e)\npublic delegate void MouseEventHandler(object sender,MouseEventArgs e)\n```\n\n有三个委托类型的签名：KeyPressEventArgs和MouseEventArgs都是从EventArgs派生\n利用方法组转换和委托逆变性：\n\n```\nstatic void LogPlainEvent(object sender, EventArgs e)\n{\n    Console.WriteLine (\"An event occurred\");\n}\n\nstatic void Main()\n{\n    Button button = new Button();\n    button.Text = \"Click me\";\n    button.Click += LogPlainEvent;\n    button.KeyPress += LogPlainEvent;\n    button.MouseClick += LogPlainEvent;\n\n    Form form = new Form();\n    form.AutoSize = true;\n    form.Controls.Add(button);\n    Application.Run(form);\n}\n```\n\n用一个事件处理方法来处理所有事件。\n\n*关于事件处理方法的参数说明：*<BR>\n第一个参数是object类型，代表事件来源；第二个参数则负责携带与事件有关的任何额外信息\n\n在有委托参数协变性后，我们可以使用一个具有EventHandler签名的方法，作为符合约定的所有委托类型的操作。\n\n### 委托返回类型的协变性\n\n举例：<BR>\n首先声明一个委托类型\n\n```\ndelegate Stream StreamFactory();\n```\n\n然后声明一个方法返回一个特定的流类型。\n\n```\nstatic MemoryStream GenerateSampleData()\n{\n    byte[] buffer = new byte[16];\n    for (int i = 0; i < buffer.Length; i++)\n    {\n        buffer[i] = (byte)i;\n    }\n    return new MemoryStream(buffer);\n}\n```\n\n利用协变性转换方法组\n\n```\nstatic void Main()\n{\n    StreamFactory factory = GenerateSampleData;\n\n    using (Stream stream = factory())\n\t//调用委托\n    {\n        int data;\n        while ((data = stream.ReadByte()) != -1)\n        {\n            Console.WriteLine(data);\n        }\n    }\n    Console.Read();\n}\n```\n\n注意：委托的返回类型是stream\n,但声明的方法的返回类型是MemoryStream。<br>\n`StreamFactory factory = GenerateSampleData;`这句话用到了方法组的转换，并利用返回类型的协变性来允许GenerateSampleData用于StreamFactory，等到调用委托实例时，实际返回的是委托声明的类型，也就是说返回类型已从MemoryStream协变成stream\n\n利用协变性和逆变性，还可以基于一个委托实例来构造另一个委托实例。\n\n```\nEventHandler general=new EventHandler(HandleEvent);\nKeyPressEventHandler key=new KeyPressEventHandler(general);\n```\n\n### 不兼容的风险\n\n可能发生在派生类中。\n\n","tags":["C#"]},{"title":"深入理解C#（十）：可空类型","url":"/2019/01/09/深入理解C-（十）：可空类型/","content":"\n# 深入理解C#（十）\n\n*第四章（C# 2：可空类型）<br>\n\n## C# 1中表示空值的模式\n\n1. 魔值：牺牲一个值来表示空值（DBNull.Value表示数据库返回null的情况，这个魔值表示所有类型的空值）\n2. 引用包装类型：直接用object作为变量类型，并根据需要进行装箱和拆箱\n3. 额外的布尔标志：使用一个普通的值类型的值，同时使用另一个布尔标志来表示值是“真正”存在还是被忽略。要么在代码中维护两个单独的变量，要么将值和标志封装到另一个值类型中。\n\n## `System.Nullable<T>`和System.Nullable\n\n`Nullable<T>`是一个有着值类型约束的泛型类型。T的类型称为可空类型的基础类型(underlying type)。<br>\n`Nullable<T>`有两个重要属性：HasValue和Value。就是采用上面第三种实现模式。<br>\n**`Nullable<T>`仍为值类型，值将直接包含一个bool和一个int，而不是其他对象的引用**<br>\n`Nullable<T>`引入一个名为GetValueOrDefault的新方法。存在值就返回值否则返回默认值/自己指定的返回值。<br>\n`Nullable<T>`覆盖了其他方法：GetHashCode,ToString和Equals。GetHashCode在没有值时返回0，ToString在没有值时返回空字符串<br>\n**再次强调`Nullable<T>`是一个结构（值类型),如果把它转换成引用类型，需要对它装箱**<br>\n调用first.Equals(second)的具体规则：\n​\t\n\n- first没有值，second为null，相等\n- first没有值，second不为null，不相等\n- first有值，second为null，不相等\n- 否则，若first的值等于second，相等\n\nSystem.Nullable类是一个静态类，只包含静态方法。\n提供三个有用方法：\n\n```\npublic static int Compare<T>(Nullable<T> n1,Nullable<T> n2)\npublic static bool Equals<T>(Nullable<T> n1,Nullable<T> n2)\npublic static Type GetUnderlyingType(Type nullableType)\n```\n\nCompare使用Comparer<T>.Default来比较两个基础值，Equals使用EqualityComparer<T>.Default。空值与空值相等，小于其他所有值。<br>\n第三个方法如果参数是一个可空类型，方法就返回它的基础类型；否则返回null。\n\n## C# 2为可空类型提供的语法糖\n\n### ？修饰符\n\n`Nullable<byte>`与`byte?`可相互转换\n\n### 使用null进行赋值和比较\n\n### 可空转换和操作符\n\n如果一个非可空的值类型支持一个操作符或一种转换，且那个操作符或转换只涉及其他非可空的值类型时，那么对应可空的值类型也支持同样的操作符或转换。举例：int=》long，int？=》long？<br>\n*具体细节待看*\n\n### 可空逻辑\n\n### 对可空类型使用as操作符\n\n在C# 2之前，as只能用于引用类型。在C# 2中，也可以用于可空类型。\n\n### 空合并操作符（？？）\n\nfirst？？second<br>\n\n1. 对first进行求值；\n2. 如结果非空，该结果就是表达式的结果\n3. 否则求second的值，其结果为整个表达式的结果\n   这个操作符还可用于可空值类型+引用类型<br>\n   这个操作符是右结合的<br>\n\n用法案例：<br>\n假设有一个在线订购系统，有billing address（账单寄送地址），contact address（联系地址），以及shipping address（送货地址）等，任何用户都必须有一个billing address，但contact address是可选的。对于一个订单来说，送货地址也是可选的，默认为billing address。遇到送货问题，要找联系人时。<br>\nC# 1实现：\n​\t\n\n```\nAddress contact=user.ContactAddress;\nif(contact==null)\n{\n\tcontact=order.ShippingAddress;\n\tif(contact==null)\n\t{\n\t\tcontact=user.BillingAddress;\n\t}\n}\n```\n\nC# 2改进：\n\n```\nAddress contact=user.ContactAddress??\n\t\t\t\torder.ShippingAddress??\n\t\t\t\tuser.BilllingAddress;\n```\n\n## 可空类型的新奇用法\n\n### 尝试一个不使用输出参数的操作\n\n输出参数的常规用法：用一个返回值来判断一个操作是否成功，并用一个输出参数来返回真正的结果。<br>\n返回引用类型的方法经常使用这样一种模式：失败时返回null，成功是返回非空值。但是，假如在方法执行成功的前提下，null也是一个有效的返回值，这样就不行了。\n\n```\nArrayList list=hash[key];\nif(list==null)\n{\n\tlist=new ArrayList();\n\thash[key]=list;\n}\nlist.Add(newItem);\n```\n\n*假设HashTable和Dictionary<Tkey,TValue>可以获取一个委托，每次查找到一个不存在的键时就调用这个委托来添加一个新值。使用这个模式适用这种情况。*\n使用可空类型，能将这种模式扩展至值类型。\n\n具体实例：\n\n```\npublic static bool TryParse(string s, out Int32 result);\n```\n\n这个int的方法的传统用法如下：\n\n```\nint result; \nif (int.TryParse(\"Not valid\", out result))\n{\n    Console.WriteLine(\"Parsed to {0}\", result);\n}\nelse\n{\n    Console.WriteLine(\"Couldn't parse\");\n}\nConsole.Read();\n```\n\n如果我们用可空类型：\n\n \tclass NullableTryParse\n​    {\n​        static int? TryParse(string data)\n​        {\n​            int ret;\n​            if (int.TryParse(data, out ret))\n​            {\n​                return ret;\n​            }\n​            else\n​            {\n​                return null;\n​            }\n​        }\n\n```\n    static void Main()\n    {\n        int? parsed = TryParse(\"Not valid\");\n        if (parsed != null)\n        {\n            Console.WriteLine(\"Parsed to {0}\", parsed.Value);\n        }\n        else\n        {\n            Console.WriteLine(\"Couldn't parse\");\n        }\n    }\n}\n```\n\n这样做的好处是它将返回值与解析是否成功封装在一个变量中，还把做和测试分离了。<br>\n还有一个好处是可以和空合并操作符配合使用。<br>\n**小结一下：**<BR>\n上述模式的要点在于：先定义并获取方法返回值（做），再判断返回值（测试）。<BR>\n如返回值是引用类型，我们可以通过判断是否为null，很容易实现这个模式，但若是值类型，就不好办了（除非我们定义一个特殊值，但这样会导致语义不明，就像魔数一样），所以就用到了可空类型，这样我们也能像使用引用类型一样，使用值类型。<BR>\n更好的做法：在.NET 4中包含了Tuple类型，使用元祖可以使返回值含义更明确。\n\n### 空合并操作符简化比较\n\n问题背景：假设要写一个电子商务网站，且有一个产品列表。希望按流行度，价格，名称依次排序。<BR>\nC# 1的实现：\n\n```\npublic int Compare(Product first,Product second)\n{\n\tint ret=second.Popularity.CompareTo(first.Popularity);\n\tif( ret !=0)\n\t{\n\t\treturn ret;\n\t}\n\tret=first.Price.CompareTo(second.Price);\n\tif(ret ！=0）\n\t{\n\t\treturn ret；\n\t}\n\treturn first.Name.CompareTo(second.Name);\n}\n```\n\n我们往往这样写Compare方法。但若是属性返回为null，我们在比较前还要先判断非空，这样代码就太复杂了。我们可以用空合并操作符来简化代码。\n\nC# 2 ？？操作符实现：\n\n```\npublic static class PartialComparer\n{\n    public static int? Compare<T>(T first, T second)\n    {\n        return Compare(Comparer<T>.Default, first, second);\n    }\n\n    public static int? Compare<T>(IComparer<T> comparer,T first,T second)\n    {\n        int ret = comparer.Compare(first, second);\n        return ret == 0 ? new int?() : ret;\n    }\n\n    public static int? ReferenceCompare<T>(T first, T second)\n        where T : class\n    {\n        return first == second ? 0\n             : first == null ? -1\n             : second == null ? 1\n             : new int?();\n    }\n\n    public static bool? ReferenceEquals<T>(T first, T second)\n        where T : class\n    {\n        return first == second ? true\n             : first == null ? false\n             : second == null ? false\n             : new bool?();\n    }\n}\n```\n\n先实现一个用于比较的辅助类。可注意ReferenceCompare方法中的条件操作符用法。<BR>\n现在可以重写Compare方法：\n\n```\npublic int Compare(Product first, Product second)\n    {\n\t\treturn PartialComparer.ReferenceCompare(first, second) ??\n\t\t// Reverse comparison of popularity to sort descending\n\t\tPartialComparer.Compare(second.Popularity, first.Popularity) ??\n\t\tPartialComparer.Compare(first.Price, second.Price) ??\n\t\tPartialComparer.Compare(first.Name, second.Name) ??\n\t\t0;\n    }\n```\n\n最后的0指明前面所有比较都通过，这两个Product相等。也可用`Comparer<string>.Default.Compare(first.Name,second.Name)`作比较。","tags":["C#"]},{"title":"深入理解C#（九）：泛型","url":"/2019/01/09/深入理解C-（九）：泛型/","content":"\n# 深入理解C#（九）\n\n*第三章（C# 2：泛型实现参数化类型）<br>\n\n## 理解泛型类型和方法\n\n## 泛型方法的类型推断\n\n例子：\n\n```\nstatic List<T> MakeList<T>(T first,T second)\n...\nList<string> list=MakeList<string>(\"Line 1\",\"Line 2\");\n```\n\n使用编译器的类型推断：\n\n```\nList<string> list=MakeList(\"Line 1\",\"Line 2\");\n```\n\n## 类型约束\n\n如List<int>等，所有类型参数都可以指定为任意类型，它们**未被约束**。我们想制定规则，从而判断哪些是泛型类型或泛型方法呢能接受的有效类型实参。<br>\n用**约束**来实现。约束放在泛型方法或泛型类型声明的末尾，有上下文关键字where引入。\n\n1. 引用类型约束<br>\n   确保使用的类型实参是引用类型：必须是第一个约束<br>\n   `struct RefSample<T> where T:class`<br>\n   以这种方式约束一个类型参数后，可以使用==和！=来比较引用（包括null）\n2. 值类型约束<br>\n   确保使用的类型实参是值类型:<br>\n   `class ValSample<T> where T:struct`br>\n   设定值类型约束后，不允许使用==和！=进行比较。<br>\n   以上两种约束比较少用，后两者更有用。\n3. 构造函数类型约束<br>\n   检查类型实参是否有一个可用于创建类型实力的无参构造函数。必须是最后一个约束。<br>\n   `public T CreateInstance() where T : new()\n   {\treturn new T();\t}`<br>\n   在使用工厂风格的设计模式时，这个约束非常有用。\n4. 转换类型约束<br>\n   指定另一个类型，类型实参必须可以通过一致性、引用或装箱隐式地转换为该类型。还可以规定一个类型实参必须可以转换为另一个类型实参。<br>\n   这个约束意味着“在类型参数的实例上使用指定类型的成员”\n\n## 实现泛型\n\n假装T是一个真正的类型名称。额外要注意：<br>\n\n1. 默认值表达式：<br>\n   例子：Dictionary<TKey,TValue>有一个TryGetValue方法：用一个输出参数来接受你打算获取的值，用boolean返回值显示是否成功。这意味着方法必须用TValue类型的值来填充输出参数。<br>\n   C# 2提供了默认值表达式(default value expression)。<br>\n   例子：以泛型方式将一个给定的值和默认值进行比较\n\n   class DefaultValueComparison\n    {\n   ​     static int CompareToDefault<T>(T value)\n   ​         where T : IComparable<T>\n   ​     {\n   ​         return value.CompareTo(default(T));\n   ​     }\n\n   ```\n    static void Main()\n    {\n        Console.WriteLine(CompareToDefault(\"x\"));\n        Console.WriteLine(CompareToDefault(10));\n        Console.WriteLine(CompareToDefault(0));\n        Console.WriteLine(CompareToDefault(-10));\n        Console.WriteLine(CompareToDefault(DateTime.MinValue));\n    }\n   ```\n\n    }\n\n这个泛型方法规定了只能使用实现了IComparable<T>接口的类型，这样才能为传入的值调用CompareTo（T）\n\n类型推断只能用于泛型方法，有一个泛型类型，其中不包含任何泛型方法，怎么实现类型推断？<br>\n`Pair<int,string> pair=new Pair<int,string>(10,\"value\");`\n解决方法是使用包含泛型方法的非泛型辅助类。\n​\t\n\n```\npublic static class Pair\n{\n\tpublic static Pair<T1,T2> Of<T1,T2>(T1 first,T2 second)\n\t{\n\t\treturn new Pair<T1,T2>(first,second);\n\t}\n}\n\nPair<int,string> pair=Pair.Of(10,\"value\");\n```\n\n等到第七章再回看\n\n1. 直接比较\n   如果一个类型参数是未约束的（即没有对其应用约束），那么只能在该类型的值与null比较时才能使用==和！=操作符。不能直接比较两个T类型的值。如果一个类型参数被约束成值类型，就完全不能为它使用==和！=。如果被约束成引用类型，具体比较将完全取决于类型参数被约束成什么类型。\n\n## 高级泛型\n\n### 静态字段和静态构造函数\n\n**每个封闭类型都有它自己的静态字段集**<br>\n同样的规则也适用于静态初始化程序和静态构造函数。\n\n### JIT(just in time即时)编译器如何处理泛型\n\n暂略\n\n### 泛型迭代\n\n对集合执行的最常见操作之一是便利（迭代）所有元素。最简单的办法使用foreach语句。<br>\n当需要为自己的某个类型实现迭代时，由于IEnumerable<T>扩展了旧的IEnumerable接口，所以要实现两个不同方法：<br>\nIEnumerator<T> GetEnumerator();\nIEnumerator GetRnumerator();\n\n## 反射和泛型\n\n反射的一切都是围绕“检查对象及其类型”展开的。<br>\ntypeof可通过两种方式作用于泛型类型。一种方式是获取泛型类型定义，另一种方式是获取特定的已构造类型。<br>\ntypeof(Dictionary<,>)或typeof(Dictionary<string,X>)<br>\n\n获取泛型和已构造Type对象的各种方式<br>\n​\t\n\n```\nstring listTypeName = \"System.Collections.Generic.List`1\";\n\nType defByName = Type.GetType(listTypeName);\n\nType closedByName = Type.GetType(listTypeName + \"[System.String]\");\nType closedByMethod = defByName.MakeGenericType(typeof(string));\nType closedByTypeof = typeof(List<string>);\n\nConsole.WriteLine(closedByMethod == closedByName);\nConsole.WriteLine(closedByName == closedByTypeof);\n\nType defByTypeof = typeof(List<>);\nType defByMethod = closedByName.GetGenericTypeDefinition();\n\nConsole.WriteLine(defByMethod == defByName);\nConsole.WriteLine(defByName == defByTypeof);\n```\n\n反射泛型方法<br>\n\n```\npublic static void PrintTypeParameter<T>()\n{\nConsole.WriteLine(typeof(T));\n}\n\nstatic void Main()\n{\nType type = typeof(GenericMethodReflection);\nMethodInfo definition = type.GetMethod(\"PrintTypeParameter\");\nMethodInfo constructed;\nconstructed = definition.MakeGenericMethod(typeof(string));\nconstructed.Invoke(null, null);\n}\n```\n\n1. 获取泛型方法定义\n2. 使用MakeGenericMethod返回一个已构造的泛型方法。\n3. 后去已构造的方法后，就可以调用了。\n\n## 泛型在C#和其他语言中的一些限制\n\n为什么不能将List<string>转换成List<object>?<br>\n泛型是不变的，但为什么数组是协变的？<br>\n为了支持从JAVA中编译来的代码，因为Java有协变数组。\n\n使用泛型辅助类解决逆变性缺乏问题\n\n缺乏操作符约束或者数值约束<br>\n解决方法：<br>\n\n1. [表达式树，第九章](http://mng.bz/9m8i)\n2. C# 4的动态特性，14章有例子\n\n为什么泛型只限于类型（包括类、结构、委托和接口）和方法?\n\n1. 缺乏泛型属性、索引器和其他成员类型\n\n## 第三章小结\n\n泛型的三个优点：<br>\n\n1. 编译时的类型安全性\n2. 性能\n3. 代码的表现力\n   IDE和编译器能提前验证代码\n\n值类型性能上获益最大。在强类型的泛型API中，不再需要装箱和拆箱。\n使用泛型，代码能更清楚地表达其意图。","tags":["C#"]},{"title":"深入理解C#（八）：类型系统","url":"/2019/01/09/深入理解C-（八）：类型系统/","content":"\n# 深入理解C#（八）\n\n*第二章（C# 类型系统）<br>\n**C# 1的类型系统是静态的、显示的和安全的**\n\n静态：描述表达式的编译时类型，使用**不变的**数据来分析哪些操作可用。\n\n## C# 1的类型系统何时不够用\n\n.NET 1.1内建了三种集合类型：\n\n- 数组--强类型--内建到语言和运行时中\n- System.Collections命名空间中的弱类型集合\n- System.Collections.Specialized命名空间中的强类型集合\n\n*引用类型的数组支持协变（covariance），只要元素的类型之间允许转换，就能隐式将一种数组类型转换成另一种*\n\n**方法覆盖和接口实现不允许协变性/逆变性**<br>\n参数类型的逆变性：使用一个放宽限制的签名如：`void Process(object x)`\n\n## 值类型和引用类型\n\n类是引用类型；结构是值类型<br>\n数组是引用类型；枚举是值类型<br>\n委托类型是引用类型；接口类型是引用类型，但可由值类型实现\n\n### 变量存储\n\n1. 变量的值在它声明时的位置存储\n2. 局部变量的值总是存储在栈（stack）中（C# 1中完全成立，高级版本可能存在堆中）\n3. 实例变量的值总是存储在实例本身存储的地方\n4. 引用类型实例总是存储在堆（heap）中，静态变量也是。\n\n### 关于引用传递和值传递\n\n无论是引用传递还是值传递，永远不会传递对象本身。\n详见[Parameter passing in C#](http://jonskeet.uk/csharp/parameters.html)\n\n### 关于装箱和拆箱\n\n- 对于引用类型的变量，它的值永远是一个引用\n\n- 对于值类型的变量，它的值永远是该值类型的一个值\n\n  int i=5;\n  object o=i;\n  int j=(int) o;\n\n第二行，发生了装箱操作：运行时在堆上创建一个包含值（5）的对象，o的值是对该新对象的一个引用。该对象的值是原始值的一个副本，改变i不会改变箱内的值。\n\n第三行，执行相反操作，拆箱。必须告诉编译器将object拆箱成什么类型。\n\n装箱什么时候方式？<br>\n为一个类型的值调用ToString、Equals或GetHashCode方法时，如果该类型没有覆盖这些方法，也发生装箱。另外，将值作为接口表达式使用时也会发生装箱。\n\n太过频繁的装拆箱会增大程序的操作开销，还会创建数量众多的对象，加重垃圾回收器的负担。","tags":["C#"]},{"title":"深入理解C#（七）：委托","url":"/2019/01/09/深入理解C-（七）：委托/","content":"\n# 深入理解C#（七）\n\n*第二章（C# 1的核心基础）<br>\n**委托，类型系统的特征，值/引用类型**\n\n## 委托（delegate）\n\n1. 类似于C语言的函数指针\n2. 不指定一个要执行的行为，将这个行为用某种方式“包含在一个对象中”\n\n### 1. 委托的构成\n\n- 声明委托类型\n\n- 必须有一个方法包含了要执行的代码\n\n- 必须创建一个委托实例\n\n- 必须调用invoke委托实例\n  ​\t\n  namespace Chapter02\n  ​\t{\n  ​\t//声明委托类型\n  ​\tdelegate void StringProcessor(string input);\n  ​\t\n\n  ```\n  class Person\n  {\n  string name;\n  \n  public Person(string name)\n  {\n  this.name = name;\n  }\n  \n  //声明兼容的实例方法\n  public void Say(string message)\n  {\n  Console.WriteLine(\"{0} says: {1}\", name, message);\n  }\n  }\n  \n  class Background\n  {\n  //声明兼容发静态方法\n  public static void Note(string note)\n  {\n  Console.WriteLine(\"({0})\", note);\n  }\n  }\n  \n  [Description(\"Listing 2.1\")]\n  class SimpleDelegateUse\n  {\n  static void Main()\n  {\n  Person jon = new Person(\"Jon\");\n  Person tom = new Person(\"Tom\");\n  //创建三个委托实例\n  StringProcessor jonsVoice, tomsVoice, background;\n  jonsVoice = new StringProcessor(jon.Say);\n  tomsVoice = new StringProcessor(tom.Say);\n  background = new StringProcessor(Background.Note);\n  //调用委托实例\n  jonsVoice(\"Hello, son.\");\n  tomsVoice.Invoke(\"Hello, Daddy!\");\n  background(\"An airplane flies past.\");\n  }\n  }\n  \n  }\n  ```\n\n  具体步骤：<br>\n\n1. 声明一个委托类型。\n2. 找到或写一个方法，具有和委托类型相同的签名，并能做我们想做的事情。\n3. 创建委托实例，指定在调用委托实例时，执行该方法。（创建委托实例，取决于操作使用实例方法还是静态方法。具体做法就是new一个我们声明的委托类型，把任意匹配的方法，作为参数传入）\n4. 调用委托实例，可以显示用Invoke方法调用，也可用简化语句直接调用。\n\n类比：委托就像提前请律师打官司，声明委托类型就像指明要处理那种类型的案件，找到或写一个方法就像找到一个满足要求的律师，创建委托实例就像和律师签订协议，在需要时调用委托实例，就像遇上官司了，就要请律师出门解决。所以实际执行的方法是律师在做，委托只是提前签好协定，这样我们就可以在任何有需求的时候解决问题。\n\n### 合并和删除委托\n\n实际使用时，委托实例往往有一个操作列表（invocation list）与之关联。Combine负责将两个委托实例的调用列表连接到一起，Remove负责从一个委托实例中删除另一个实例的调用列表。一般使用+和+=操作符代替Combine。<br>\n注意： 委托和string一样是不易变的。Combine和String.Concat很像，合并现有实例来形成新的实例。<br>\n可用-和-=简写Remove操作<br>\n注意：若委托的签名有一个非void的返回类型，则Invoke的返回值是最后一个操作的返回值。除非使用GetInvocationList获取操作列表时，都显示调用某个委托，否则只能看到最后一个操作的返回值。<br>\n注意：如果调用列表中断任何操作爆出一个异常，都会组织执行后续操作。\n\n### 事件的简单讨论\n\n基本思想：让代码在发生某事时作出响应。<br>\n**注意：事件不是委托类型的字段，但C#允许使用字段风格的时间（field-like event）**<br>\n可以将事件看作类似属性的东西。两者都声明具有一种特定的类型，对于事件来说，是一个委托类型。(即：事件之于委托，就像属性之于字段）使用属性，实际是在调用方法。实现属性，可在方法中添加别的功能（校验机制之类）。同样订阅或取消订阅事件，实际是在调用（add和remove方法）<br>\n既然能用委托实现为什么还要事件？<br>\n和属性类似，事件添加了一个封装层，实现发布/订阅模式。[Delegates and Events](http://csharpindepth.com/Articles/Chapter2/Events.aspx)\n\n字段风格的事件，只需要一个声明。编译器将声明转换成一个具有默认add/remove实现的事件和一个私有委托类型的字段。表面上调用一个事件，实际调用存储在字段中的委托实例。","tags":["C#"]},{"title":"深入理解C#（六）：大致了解-异步代码","url":"/2019/01/09/深入理解C-（六）：大致了解-异步代码/","content":"\n# 深入理解C#（六）\n\n*第一章（大致了解C#各个版本的特性：异步代码）\n\n**C# 5特性：异步函数**\n可以用它来中断代码执行，而不阻塞线程。\n\nWindows Forms中有两条规范：<br>\n\n1. 不能阻塞UI线程\n\n2. 不能在任何其他线程中访问UI元素\n\n   private async void CheckProduct(object sender, EventArgs e)\n   ​     {\n   ​         try\n   ​         {\n   ​             // Only permit one lookup at a time\n   ​             productCheckButton.Enabled = false;\n   ​             statusLabel.Text = \"Checking...\";\n   ​             nameValue.Text = \"\";\n   ​             priceValue.Text = \"\";\n   ​             stockValue.Text = \"\";\n\n   ```\n            string id = idInput.Text;\n            Task<Product> productLookup = directory.LookupProductAsync(id);\n            Task<int> stockLookup = warehouse.LookupStockLevelAsync(id);\n   \n            Product product = await productLookup;\n            if (product == null)\n            {\n                statusLabel.Text = \"Product not found\";\n                // We don't care about the result of the stock check\n                return;\n            }\n            nameValue.Text = product.Name;\n            priceValue.Text = product.Price.ToString(\"c\");\n   \n            int stock = await stockLookup;\n            stockValue.Text = stock.ToString();\n            statusLabel.Text = \"Ready\";\n        }\n        finally\n        {\n            // However we finish this method, allow another lookup\n            productCheckButton.Enabled = true;\n        }\n    }\n   ```\n\n新的语法：**方法的async修饰符和两个await表达式**\n\n说明：现在产品目录和库存中查询产品详细信息和当前库存。等待（await）直到找到产品信息，如果目录中没有条目与给定ID对应，就退出。否则，将产品名称和价格显示在UI元素上，然后再等待获得库存信息并显示。","tags":["C#"]},{"title":"深入理解C#（五）：大致了解-COM和动态类型","url":"/2019/01/09/深入理解C-（五）：大致了解-COM和动态类型/","content":"\n# 深入理解C#（五）\n\n*第一章（大致了解C#各个版本的特性：COM和动态类型）\n\n**C# 4特性：互操作性**<br>\n包括：处理旧的COM技术和在DLR（Dynamic Language Runtime，动态语言运行时）上执行全新动态语言。\n\n## 简化COM互操作\n\n用COM控制让数据出现在Excel中\n例子：\n\n```\nvar app = new Application { Visible = false };\nWorkbook workbook = app.Workbooks.Add();\nWorksheet worksheet = app.ActiveSheet;\nint row = 1;\nforeach (var product in Product.GetSampleProducts()\n.Where(p => p.Price != null))\n{\nworksheet.Cells[row, 1].Value = product.Name;\nworksheet.Cells[row, 2].Value = product.Price;\nrow++;\n}\nworkbook.SaveAs(Filename: \"demo.xls\",\nFileFormat: XlFileFormat.xlWorkbookNormal);\napp.Application.Quit();\n```\n\n## 与动态语言互操作\n\n问题：产品能通过WEb服务访问，但只能用Python代码。Web服务使用了Python特性来构建结果，没有声明我们要访问的属性类型。但要我们指定类型，怎么办？\n\n使用新的类型dynamic<br>\n可以将dynamic类型隐式转换为其他类型\n\n例子：从IronPython中获取产品列表并打印出来。\n\n```\nScriptEngine engine = Python.CreateEngine();\nScriptScope scope = engine.ExecuteFile(@\"CSharp4\\FindProducts.py\");\ndynamic products = scope.GetVariable(\"products\");\nforeach (dynamic product in products)\n{\nConsole.WriteLine(\"{0}: {1}\", product.ProductName, product.Price);\n}\n```\n\nproducts和product为动态类型，编译器允许我们对产品列表迭代打印，但是它不确保是否能执行成功。如果有错误，只有执行时才会知道失败。","tags":["C#"]},{"title":"深入理解C#（四）：大致了解-LINQ简介","url":"/2019/01/09/深入理解C-（四）：大致了解-LINQ简介/","content":"\n# 深入理解C#（四）\n\n*第一章（大致了解C#各个版本的特性：LINQ简介）\n\n## LINQ简介\n\nLINQ（Language Integrated Query，语言集成查询）<br>用于简化查询\n\n### 查询表达式和进程内查询\n\n例子：\n查询所有供应商和对应产品，先连接产品和供应商，再按价格筛选，然后按先供应商名再产品名的优先级排序，最后打印每个供应商名称和产品名称\n\n```\nList<ProductWithSupplierID> products = ProductWithSupplierID.GetSampleProducts();\nList<Supplier> suppliers = Supplier.GetSampleSuppliers();\nvar filtered = from p in products\n               join s in suppliers on p.SupplierID equals s.SupplierID\n               where p.Price > 10\n               orderby s.Name, p.Name\n               select new\n               {\n                   SupplierName = s.Name,\n                   ProductName = p.Name\n               };\nforeach (var v in filtered)\n{\n    Console.WriteLine(\"Supplier={0}; Product={1}\",v.SupplierName, v.ProductName);\n}\n```\n\n**特性：隐式类型局部变量（implicitly typed local variable）**<br>\n使用var关键字说明，编译器根据变量的初始值推断其类型\n\n### LINQ to XML\n\n例子：\n\n```\nXDocument doc = XDocument.Load(\"data.xml\");\nvar filtered = from p in doc.Descendants(\"Product\")\n               join s in doc.Descendants(\"Supplier\")\n               on (int)p.Attribute(\"SupplierID\")\n                   equals (int)s.Attribute(\"SupplierID\")\n               where (decimal)p.Attribute(\"Price\") > 10\n               orderby (string)s.Attribute(\"Name\"),\n                       (string)p.Attribute(\"Name\")\n               select new\n               {\n                   SupplierName = (string)s.Attribute(\"Name\"),\n                   ProductName = (string)p.Attribute(\"Name\")\n               };\nforeach (var v in filtered)\n{\n    Console.WriteLine(\"Supplier={0}; Product={1}\",\n                      v.SupplierName, v.ProductName);\n}\n}\n```\n\n### LINQ to SQL\n\n例子：\n\n```\nusing (LinqDemoDataContext db = new LinqDemoDataContext())\n    {\n        var filtered = from p in db.Products\n                       join s in db.Suppliers\n                       on p.SupplierID equals s.SupplierID\n                       where p.Price > 10\n                       orderby s.Name, p.Name\n                       select new\n                       {\n                           SupplierName = s.Name,\n                           ProductName = p.Name\n                       };\n        foreach (var v in filtered)\n        {\n            Console.WriteLine(\"Supplier={0}; Product={1}\",\n                              v.SupplierName, v.ProductName);\n        }\n    }\n```\n\n虽然查询是用C#代码来表示的，但却是用SQL执行。\n实际发出一个数据库请求，被转化为SQL查询。","tags":["C#"]},{"title":"深入理解C#（三）：大致了解-处理未知数据","url":"/2019/01/09/深入理解C-（三）：大致了解-处理未知数据/","content":"\n# 深入理解C#（三）\n\n*第一章（大致了解C#各个版本的特性：处理未知数据）\n\n## 表示未知的值类型\n\n问题描述：decimal表示产品价格，是值类型，若某个产品价格未知，该如何表示？（若是引用类型，可用null表示）\n\n### C# 1解决方案：\n\n- 给decimal建一个引用类型包装器\n- 用一个单独的bool标志，表示价格是否已知\n- 使用一个魔数（magic value）来表示，如decimal.MinValue\n\n### C# 2:\n\nNullable<T>结构，提供一些语法糖来简化。\n例子：\n\n```\ndecimal? price;\npublic decimal? Price\n{\n\tget{return price;}\n\tprivate set{price=value;}\n}\n```\n\nPrice=null;\n**null现在表示“没有其他数据的任意可空类型的一个特殊值”**<br>\n所有引用类型和基于Nullable<T>的类型为可空类型<br>\n*与null值作比较，结果总是false*\n\n## 可选参数和默认值\n\n问题描述：对一个方法或构造函数，有时我们会自己设定参数，这时往往需要重构来减少参数量，并设置我们的默认值。有什么方法能简化？\n\n### C#4：\n\n可选参数和默认值：\n例子：\n\n```\npublic Product(string name,decimal? price=null)\n{\n\tthis.name=name;\n\tthis.price=price;\n}\n```\n\n这里对于可空类型的参数price，我们设定他为可选参数，默认值为null，这样我们就不需要重载这个构造函数，但我们依然能使用形如：`Product p=new Product(\"Unreleased product\");`这样的方式构造一个Product实例，因为price被设定有默认值null。","tags":["C#"]},{"title":"深入理解C#（二）：大致了解-排序和过滤","url":"/2019/01/09/深入理解C-（二）：大致了解-排序和过滤/","content":"\n# 深入理解C#（二）\n\n*第一章（大致了解C#各个版本的特性：排序和过滤）\n\n## 按字母顺序打印产品列表\n\n*按名称排序，找出最贵的产品*\n*这里只摘录C# 3的实现方法*\n\n### Lambda表达式使用Comparison<Product>进行排序\n\n```\nList<Product> products=Product.GetSampleProducts();\t\nproducts.Sort((x,y)=>x.Name.CompareTo(y));\nforeach(Product product in products)\n{\n\tConsole.WriteLine(product);\n}\t\n```\n\n### 使用一个扩展方法对List<Product>进行排序\n\n```\nList<Product> products=Product.GetSampleProducts();\nforeach(Product product in products.OrderBy(p=>p.Name))\n{\n\tConsole.WriteLine(product);\n}\n```\n\n## 查询集合\n\n### C# 1\n\n需要循环，测试每个元素，操作符合条件的元素（这里是打印元素）\n\n### C# 2\n\n测试和打印分开\n\n```\nList<Product> products=Product.GetSampleProducts();\n\nPredicate<Product> test=delegate(Product p) { return p.Price>10m;};\nList<Product> matches=products.FinaAll(test);\n\nAction<Product> print=Console.WriteLine;\nmatces.ForEach(print);\n```\n\n用FinaAll和ForEach分解问题\n另一个版本：\n\n```\nList<Product> products=Product.GetSampleProducts();\nproducts.FindAll(delegate(Product p){return p.Price>10;}}.\n\t\t.ForEach(Console.WriteLine);\n```\n\n### C# 3\n\n用Lambda表达式来测试\n\n```\nList<Product> products=Product.GetSampleProducts();\nforeach(Product product in products.Where(p=>p.Price>10))\n{\n\tConsole.WriteLine(product);\n}\n```\n\n## 小结\n\n1. C# 1，传统方法\n2. C# 2, 匿名方法：有助于问题的分离性（将测试和打印分开）\n3. C# 3， Lambda表达式：增强了可读性","tags":["C#"]},{"title":"深入理解C#（一）：大致了解-数据类型","url":"/2019/01/09/深入理解C-（一）：大致了解-数据类型/","content":"\n# 深入理解C#（一）\n\n*第一章（大致了解C#各个版本的特性：数据类型）\n\n## **产品/名称/价格**的例子\n\n### C# 1实现\n\n```\npublic class Product\n{\nstring name;\npublic string Name{ get { return name;} }\n\ndecimal price;\npublic decimal Price { get { return price; }}\n\npublic Product(string name,decimal price)\n{\n\tthis.name=name;\n\tthis.price = price;\n}\n\npublic static ArrayList GetSample()\n{\n\tArrayList list = new ArrayList();\n\tlist.Add(new Prodect(\"west side\",9.99m));\n\tlist.Add(new Prodect(\"Assassins\",14.99m));\n\treturn list;\n}\n\npublic override string ToString()\n{\n\treturn string.Format(\"{0}: {1}\",name,price);\n}\n```\n\n存在以下问题：<br>\n\n1. ArrayList 没有 提供 与其 内部 内容 有关 的 编译 时 信息。 不慎 在 GetSampleProducts 创建 的 列表 中 添加 一个 字符串 是 完全 有可能 的， 而 编译器 对此 没有 任何 反应。\n   (例如`list.Add(\"this is a string\");`编译器不能发现错误）\n2. 代码 中为 属性 提供 了 公共 的 取值 方法， 这 意味着 如果 添加 对应 的 赋值 方法， 那么 赋值 方法 也 必须 是 公共 的。\n3. 用于 创建 属性 和 变量 的 代码 很复杂—— 封装 一个 字符串 和 一个 十进制 数 应该 是一 个 十分 简单 的 任务， 不该 这么 复杂。\n\n### C# 2实现\n\n```\npublic class Product\n{\nstring name;\npublic string Name{\n\t get { return name;}\n\tprivate set { name=value;}\n```\n\n \t}\n​\t\n\n```\ndecimal price;\npublic decimal Price { get { return price; }}\n\npublic Product(string name,decimal price)\n{\n\tthis.name=name;\n\tthis.price = price;\n}\n\npublic static List GetSample()\n{\n\tList<Product> list = new List();\n\tlist.Add(new Prodect(\"west side\",9.99m));\n\tlist.Add(new Prodect(\"Assassins\",14.99m));\n\treturn list;\n}\n\npublic override string ToString()\n{\n\treturn string.Format(\"{0}: {1}\",name,price);\n}\n```\n\nC# 2提出泛型\nList<Product> list = new List();<br>\n且属性拥有私有赋值方法 private set { name=value;} <br>\n这样就解决了C# 1中前两个问题\n\n### C# 3实现\n\n特性1：自动实现的属性和简化的初始化\n\n```\npublic class Product\n{\npublic string Name{ get; private set;\n```\n\n \t}\n​\t\n\n```\npublic decimal Price { get; private set; }\n\npublic Product(string name,decimal price)\n{\n\tName=name;\n\tPrice = price;\n}\n\nProduct() {}\n\npublic static List GetSample()\n{\n\treturn new List{\n\tnew Prodect{ Name=”West Side\",Price=9.99m},\n\tnew Prodect{Name=\"Assassins\", Price=14.99m}\n\t};\n}\n\npublic override string ToString()\n{\n\treturn string.Format(\"{0}: {1}\",Name,Price);\n}\n```\n\n用属性代替变量，删除了所有与变量关联的代码，在类中处处使用属性，增强了一致性。<br>\n有一个私有的无参构造函数，用于基于属性的初始化。\n\n### C# 4实现\n\n为了移除易变形,使用只读属性<br>\n在调 用 构造 函数 时 指定 实 参 的 名称， \n**关于只读属性**\n\n1. readonly是一个用于以下三种上下文的修饰符：\n\n2. 在字段定义中：readonly表示这个字段的实例化只能发生在<1>变量声明时<2>在所属类的构造器中\n\n3. 在只读段落（readonly struct）中：为一个struct加上readonly表示这个struct是不变的（immutable）。\n\n4. 在方法返回ref readonly中，表示这个方法返回一个reference，这个ref不可写\n\n   using System.Collections.Generic;\n   ​\tpublic class Product\n   ​\t{\n   ​\treadonly string name;\n   ​\tpublic string Name{ get { return name;}\n    \t}\n\n   ```\n   readonly decimal price;\t\n   public decimal Price { get{return price;} }\n   \n   public Product(string name,decimal price)\n   {\n   \tthis.name=name;\n   \tthis.price = price;\n   }\n   \n   Product() {}\n   \n   public static List GetSample()\n   {\n   \treturn new List{\n   \tnew Prodect{ name:\"West Side\",price:9.99m},\n   \tnew Prodect{name:\"Assassins\", price:14.99m}\n   \t};\n   }\n   \n   public override string ToString()\n   {\n   \treturn string.Format(\"{0}: {1}\",name,price);\n   }\n   ```\n\n指定实参名称的好处是：在方法或构造函数包含多个参数时，使代码更清楚。另外可以不按顺序添加参数，而按照名称添加。这是C# 4为每个方法或构造函数自动添加的，直接使用。\n\n### 小结一下：<br>\n\n除了用到readonly的时候，大部分时候选用C# 3的属性自动实现的特性，隐藏变量，在方法中始终使用属性，保持一致性。对于拥有多个复杂参数的函数或构造函数，用命名实参来调用方法。","tags":["C#"]},{"title":"C#review补档","url":"/2019/01/08/C-review/","content":"\n# C#回顾\n\n## 与java明显不同\n\n1. WriteLine()\n2. 文件名可以不同于类的名称\n3. 动态（Dynamic）类型\n   您可以存储任何类型的值在动态数据类型变量中。这些变量的类型检查是在运行时发生的。 声明动态类型的语法：`dynamic <variable_name> = value;`\n4. 指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能。\n5. 常量是使用 const 关键字来定义的\n6. ? : 运算符\n   我们已经在前面的章节中讲解了 条件运算符 ? :，可以用来替代 if...else 语句。它的一般形式如下：`Exp1 ? Exp2 : Exp3;`\n7. for(;;) 结构来表示一个无限循环。\n8. return 语句可用于只从函数中返回一个值。但是，可以使用 输出参数 来从函数中返回两个值。输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。 关键字 out\n9. 在 C# 中，使用 ref 关键字声明引用参数。\n10. 数组：`double[] balance = new double[10];`\n11. foreach (int j in n )\n12. C# 参数数组:params 关键字 当声明一个方法时，您不能确定要传递给函数作为参数的参数数目\n    在使用数组作为形参时，C# 提供了 params 关键字，使调用数组为形参的方法时，既可以传递数组实参，也可以只传递一组数组。params 的使用格式为：`public 返回类型 方法名称( params 类型名称[] 数组名称 )`\n13. C# 中的析构函数\n    类的 析构函数 是类的一个特殊的成员函数，当类的对象超出范围时执行。\n    析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。\n    析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。\n\n## 注意点\n\n1. C# string 字符串的前面可以加 @（称作\"逐字字符串\"）将转义字符（\\）当作普通字符对待，比如：`string str = @\"C:\\Windows\";`等价于：`string str = \"C:\\\\Windows\";`\n2. Console.ReadLine() 只接受字符串格式的数据。\n3. 可空类型：在处理数据库和其他包含可能未赋值的元素的数据类型时，将 null 赋值给数值类型或布尔型的功能特别有用：`< data_type> ? <variable_name> = null;`\n4. 我们可以使用 static 关键字把类成员定义为静态的。当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本。\n   关键字 static 意味着类中只有一个该成员的实例。\n5. 您也可以把一个成员函数声明为 static。这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在。\n6. 抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。\n\n## 待详细看\n\n1. [namespace命名空间](https://www.w3cschool.cn/csharp/csharp-namespace.html):using System;命名空间的设计目的是为了提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。\n2. [可空类型](https://www.w3cschool.cn/csharp/csharp-nullable.html)\n3. [多维数组和交错数组](https://www.w3cschool.cn/csharp/csharp-multi-dimensional-arrays.html):C# 支持多维数组。多维数组又称为矩形数组。交错数组是数组的数组。\n4. [Array 类](https://www.w3cschool.cn/csharp/csharp-array-class.html)是 C# 中所有数组的基类，它是在 System 命名空间中定义。Array 类提供了各种用于数组的属性和方法。*直接调用array中的方法能实现数组的逆转和排序等*\n5. [结构](https://www.w3cschool.cn/csharp/csharp-struct.html)在 C# 中，结构是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。struct 关键字用于创建结构。\n6. [动态多态性](https://www.w3cschool.cn/csharp/csharp-polymorphism.html)\n\n## 委托（delegate)\n\nC# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。委托（Delegate） 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。\n\n委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 System.Delegate 类。","tags":["C#"]},{"title":"2018-7-26-JavaEE-WEB-2","url":"/2018/07/26/2018-7-26-JavaEE-WEB-2/","content":"\n# JAVA EE WEB学习（二）\n\n**创建第一个Servlet**\n\n## Servlet作用\n\n1. 直接处理和响应用户请求\n2. 将处理工作委托给应用中其他部分的类\n3. WEB容器会有一个或多个Servlet，用于处理JSP、显示目录列表、访问静态资源\n\n## 继承的servlet类\n\n1. 继承HttpServlet\n2. 接收HttpServletRequest和HttpServletResponse参数\n\n## 简单例子\n\n```\npackage servlet;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class Demo3 extends HttpServlet {\n\tprivate static final String DEFAULT_USER=\"Guest\";\n\t/**\n\t * Constructor of the object.\n\t */\n\tpublic Demo3() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Destruction of the servlet. <br>\n\t */\n\tpublic void destroy() {\n\t\tsuper.destroy(); // Just puts \"destroy\" string in log\n\t\t// Put your code here\n\t\tSystem.out.println(this.getServletInfo());\n\t\tSystem.out.println(\"fin\");\n\n\t}\n\n\t/**\n\t * The doGet method of the servlet. <br>\n\t *\n\t * This method is called when a form has its tag value method equals to get.\n\t * \n\t * @param request the request send by the client to the server\n\t * @param response the response send by the server to the client\n\t * @throws ServletException if an error occurred\n\t * @throws IOException if an error occurred\n\t */\n\tpublic void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tString user =request.getParameter(\"user\");\n\t\tif(user==null)\n\t\t{\n\t\t\tuser=Demo3.DEFAULT_USER;\n\t\t}\n\t\tresponse.setContentType(\"text/html\");\n\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\t\t\n\t\tPrintWriter out = response.getWriter();\n\t\tout.append(\"<!DOCTYPE HTML>\\r\\n\")\n\t\t   .append(\"<HTML>\\r\\n\")\n\t\t   .append(\"  <HEAD>\\r\\n\")\n\t\t   .append(\"    <TITLE>A Servlet</TITLE>\\r\\n\")\n\t\t   .append(\"  </HEAD>\\r\\n\")\n\t\t   .append(\"  <BODY>\\r\\n\")\n\t\t   .append(\"     Hello, \").append(user).append(\"!<br/><br/>\\r\\n\")\n\t\t   .append(\"     <form action=\\\"demo3\\\" method=\\\"POST\\\">\\r\\n\")\n\t\t   .append(\"       Enter your name:<br/>\\r\\n\")\n\t\t   .append(\"       <input type=\\\"text\\\" name=\\\"user\\\"/><br/>\\r\\n\")\n\t\t   .append(\"       <input type=\\\"submit\\\" value=\\\"Submit\\\"/>\\r\\n\")\n\t\t   .append(\"       </form>\\r\\n\")\n\t\t   .append(\"  </BODY>\\r\\n\")\n\t\t   .append(\"</HTML>\\r\\n\");\n\n\n\t}\n\n\t/**\n\t * The doPost method of the servlet. <br>\n\t *\n\t * This method is called when a form has its tag value method equals to post.\n\t * \n\t * @param request the request send by the client to the server\n\t * @param response the response send by the server to the client\n\t * @throws ServletException if an error occurred\n\t * @throws IOException if an error occurred\n\t */\n\tpublic void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\tthis.doGet(request, response);\n\t}\n\n\t/**\n\t * Initialization of the servlet. <br>\n\t *\n\t * @throws ServletException if an error occurs\n\t */\n\tpublic void init() throws ServletException {\n\t\t// Put your code here\n\t\tSystem.out.println(\"start\");\n\t\tSystem.out.println(this.getServletName());\n\t}\n\n}\n\n```\n\n**注意点**\n\n1. init方法在构造完成之后，响应第一个请求之前调用\n2. 调用init方法时，Servlet中所有属性都已设置完，提供了对ServletConfig和SercletContext对象的访问。\n3. 可以使用init方法读取属性文件或使用JDBC连接数据库\n4. destory方法在Servlet不再接受请求之后立即调用，即web应用程序被停止或卸载，或Web容器关闭时。因此：**应该使用destory方法清理servlet持有的资源**\n\n## 配置可部署的Servlet\n\n1. 在web.xml中部署，一般IDE会在创建时自动部署。\n2. \n\n```\n<servlet>\n\t.....\n\t.....\n\t<load-on-startup>x</load-on-startup>\n</servlet>\n```\n\nServlet按照x大小顺序启动，越小优先级越高。\n\n1. 将Servlet映射到URL\n   `<servlet-name>`对应`<url-pattern>`一个servlet可以映射到多个url\n\n## 了解doGet、doPost和其他方法\n\n### HttpServletRequest\n\n1. 功能：从客户端发送的请求中获取参数。参数有两种形式：查询参数和请求正文（post请求）。查询参数在HTTP请求的第一行数据中如`GET /index.jsp?id=412&category=Books HTTP/1.1`中有两个查询参数:id和category  或  作为post变量保存在请求正文中\n2. **获取请求参数：**方法getParameter返回参数单个值，或多个参数第一个值；getParameterValues返回参数值的数组；getParameterMap返回包含所有参数名值对；getparameterNames返回所有可用参数的名字的枚举。后两种方法一般用于遍历所有请求参数。\n3. **确定与请求内容相关的信息：**getContentType返回请求的内容类型；getContentLength返回请求正文长度。\n4. **读取请求的内容：**getInputStream读二进制格式；BufferedReader读基于字符编码。**不要在同一请求上同时使用这两种方法；不要在含post变量的请求上使用这些方法**\n5. **获取请求特有的数据**getRequestURL：返回完整URL；getRequestURI：返回服务器路径；getServletPath：只返回Servlet映射的URL;\n\n### HttpServletResponse\n\n1. 功能：提供了对响应中与HTTP协议相关属性的访问。可用于：设置响应头、编写相应正文、重定向请求、设置HTTP状态码等\n2. **编写响应正文：**将内容输出到响应正文中。getOutputStream和getWritter都可以向响应中输出数据。**不要对同一响应对象同时使用这两种方法。**\n3. **设置内容类型或编码格式：**使用setContentType和setCharacterEncoding方法。必须放在getWritter方法之前，否则返回到writer使用容器默认编码。\n4. **设置头和其他响应属性：**暂略\n\n## 使用初始化参数配置应用程序\n\n### 使用上下文初始化参数\n\n1. 在web.xml文件中用`<context-param>`标签声明上下文初始化参数 *在`<servlet>`外部*\n2. 在Servlet代码中获得和使用这些参数：先获得servletcontext（getServletContext），用这个实例的getInitParameter方法，参数为param-name可得到param-value。\n\n### 使用servlet初始化参数\n\n1. 将`<init-param>`添加到*`<servlet>`内部*\n2. 在Servlet代码中获得和使用这些参数：先获得ServletConfig（getServletConfig），用这个实例的getInitParameter方法，参数为param-name可得到param-value。\n3. **通常用这种方式改变数据库服务器的IP地址**\n\n## 通过表单上传文件","tags":["JavaEE"]},{"title":"2018-7-25-JavaEE-WEB-1","url":"/2018/07/25/2018-7-25-JavaEE-WEB-1/","content":"\n\n\n# JAVA EE WEB学习（一）\n\n**基本结构**\n\n## Servlet等\n\n1. servlet：接收响应HTTP请求\n2. 过滤器：拦截发送给servlet的请求，用于：数据格式化，对返回的数据压缩、认证和授权\n3. 监听器：通知代码多种事件，如：程序启动、关闭，HTTP会话创建和销毁\n4. JavaServer Pages/JSP：创建图形用户界面\n\n## 目录结构和归档文件WAR\n\n1. Java归档文件：JAR  Java EE WEB归档文件：WAR\n2. ![目录结构](/img/post/目录结构.png)\n3. ![目录结构2](/img/post/目录结构2.png))\n\n## 部署描述符\n\n1. 用于描述Web应用程序的元数据，为服务器部署和运行Web应用程序提供指令。\n2. 来自于/WEB-INF/web.xml\n3. 包含Servlet、监听器和过滤器的定义+HTTP会话、JSP和应用程序的配置选项。\n4. *可用注解配置Web应用程序*\n\n## 类加载器架构（ClassLoader)\n\n1. Java SE 平台中，java.*类加载到根类加载器->JRE中的扩展JAR加载到扩展类加载器->其他所有类加载到Class Loader\n2. 双亲优先类加载委托模式：低级别加载器申请加载一个类时，将委托不断向上传递至根加载器，确认成功。未能找到，则从自己的JAR文件和目录中尝试加载。\n3. Java EE WEb中，使用子女优先类加载委托模式：公共的服务器类加载器给每个WEB应用程序分配一个自由的相互隔离的类加载器。在自己无法加载某个类时，请求它的父类加载器帮助加载。\n\n","tags":["JavaEE"]},{"title":"Java POI开发小结","url":"/2018/07/02/2018-07-02-Apache-POI/","content":"\n# 关于POI以及一些想法\n\nApache POI是Apache软件基金会提供的100％开源库。大多数中小规模的应用程序开发主要依赖于Apache POI（HSSF+ XSSF）。它支持Excel 库的所有基本功能; 然而，呈现和文本提取是它的主要特点。 [官网链接](http://poi.apache.org/guidelines.html)\n\nJava Excelapi有很多，除了Apahce POI，网上教程较多的Jexcel等。虽然没有使用过其他java excelapi，就本人使用Apahce POI开发感受和其他人的提醒，能用VB操作excel就尽量不要用java了。\n\nApache   POI提供的基本功能，简单的读写ｅｘｃｅｌ文档没有问题，但是没有实现复制单元格(cell)，复制电子表格(Sheet)等功能（也有可能提供了但我没找到，毕竟没有很详细地完整看完官方Guide）。学习基本功能和了解POI实现机制，可以看上面官网链接或[易百中文教程](https://www.yiibai.com/apache_poi/apache_poi_core_classes.html)。\n\n我在下面会列出一些我在开发时自己编写的ＰＯＩ工具类中一些常用函数，具体代码可以在我的GitHub [JavaPOI](https://github.com/xiaotong1996/JavaPOI)项目中找到。\n\n#  代码实现\n\n ## 获取有效行数\n\n```java\n/********************************************************\n\t * function : count the number of valid rows in a given sheet \n\t * *******************************************************\n\t * parameters:\n\t * wb : workbook which contains the sheet we want\n\t * indexSheet : the index of the sheet in the xb (start from 0)\n\t *************************************************************** */\n\tpublic static int getSheetRowNumber(XSSFWorkbook wb,int indexSheet)\n\t{\n\t\tXSSFSheet sheet=wb.getSheetAt(indexSheet);\n\t\tint count=0;\n\t\tint begin = sheet.getFirstRowNum();  \n\t\t  \n\t    int end = sheet.getLastRowNum();  \n\t  \n\t    for (int i = begin; i <= end; i++) {  \n\t        if (null == sheet.getRow(i)|| getCellValue(sheet.getRow(i).getCell(0)) == \"\" || null==sheet.getRow(i).getCell(0)) {  \n\t            continue;  \n\t        }  \n\t        else count++;\n\t    }\n\t    \n\t    return count;\n\t}\n```\n\n## 列编号(ABC...)与数字(123...)的转换\n\n```java\n/**********************************************************\n     * Excel column index begin 1\n     * @param colStr\n     * @param length\n     * @return\n     **********************************************************/\n    public static int excelColStrToNum(String colStr, int length) {\n        int num = 0;\n        int result = 0;\n        for(int i = 0; i < length; i++) {\n            char ch = colStr.charAt(length - i - 1);\n            num = (int)(ch - 'A' + 1) ;\n            num *= Math.pow(26, i);\n            result += num;\n        }\n        return result;\n    }\n\n    /**\n     * Excel column index begin 1\n     * @param columnIndex\n     * @return\n     */\n    public static String excelColIndexToStr(int columnIndex) {\n        if (columnIndex <= 0) {\n            return null;\n        }\n        String columnStr = \"\";\n        columnIndex--;\n        do {\n            if (columnStr.length() > 0) {\n                columnIndex--;\n            }\n            columnStr = ((char) (columnIndex % 26 + (int) 'A')) + columnStr;\n            columnIndex = (int) ((columnIndex - columnIndex % 26) / 26);\n        } while (columnIndex > 0);\n        return columnStr;\n    }\n```\n\n## 在不同工作簿(workbook)间，复制一个区域的单元格并保留格式，设置行宽\n\n```\n/********************************************************\n\t * function : copy a part of cells in different workbooks\n\t * *******************************************************\n\t * @param:\n\t * xbIn : the resource workbook\n\t * xbOut : the destination workbook\n\t * indexSheetIn : the index of the sheet in the xbIn (start from 0)\n\t * indexSheetOut : the index of the sheet in the xbOut (start from 0)\n\t * rowInStart : the number of the first row that we need in the indexSheetIn ( start from 1 )\n\t * rowInEnd : the number of the last row that we need in the indexSheetIn ( start from 1 )\n\t * colInStart : the number of the first column that we need in the indexSheetIn ( start from 1, represent A in the sheet )\n\t * colInEnd : the number of the last column that we need in the indexSheetIn ( start from 1, represent A in the sheet )\n\t * rowOutStart : the number of the first row that we want to put cells in the indexSheetOut ( start from 1 )\n\t * colOutStart : the number of the first column that we want to put cells in the indexSheetOut ( start from 1, represent A in the sheet )\n\t * *******************************************************/\n\tpublic static boolean copyCells(XSSFWorkbook wbIn,XSSFWorkbook wbOut,int indexSheetIn,int indexSheetOut, \n\t\t\tint rowInStart,int colInStart,int rowInEnd,int colINEnd,int rowOutStart,int colOutStart )\n\t{\n\t\tXSSFSheet sheetIn=wbIn.getSheetAt(indexSheetIn);\n\t\tXSSFRow rowIn;\n\t\tXSSFCell cellIn;\n\t\tXSSFCellStyle cellStyleIn;\n\t\tString cellInValue;\n\t\t\n\t\t\n\t\tXSSFSheet sheetOut=wbOut.getSheetAt(indexSheetOut);\n\t\tXSSFRow rowOut;\n\t\tXSSFCell cellOut;\n\t\tXSSFCellStyle cellStyleOut;\n\t\t\n\t\tint rowNum=rowInEnd-rowInStart;\n\t\tint colNum=colINEnd-colInStart;\n\t\tfor(int i=0;i<rowNum+1;i++)\n\t    {  \t    \t\n\t    \t\n\t    \trowIn=sheetIn.getRow(rowInStart+i-1); \t\t    \t\t\n\t    \trowOut = sheetOut.createRow(rowOutStart+i-1);\n\t\t\t//set the copied row's height\n\t    \trowOut.setHeight(rowIn.getHeight());\n\t    \tfor(int j=0;j<colNum+1;j++) {\n\t    \t\tcellIn=rowIn.getCell(colInStart+j-1);\n\t    \t\tif(cellIn!=null) {\n\t    \t\tcellInValue=getCellValue(cellIn);\n\t    \t    cellOut=rowOut.createCell(colOutStart+j-1);\n\t    \t    cellStyleIn=cellIn.getCellStyle();\n\t    \t    cellStyleOut=wbOut.createCellStyle();\n\t    \t    cellStyleOut.cloneStyleFrom(cellStyleIn);\n\t    \t    cellOut.setCellStyle(cellStyleOut);\n\t    \t    cellOut.setCellValue(cellInValue);\n\t    \t\t}\n\t    \t}\t\n\t    }\n\t\t\n\t\t//in order to deal with merged regions\n\t\tjava.util.List<CellRangeAddress> regions=sheetIn.getMergedRegions();\n\t\t\n\t\tfor(CellRangeAddress cellRangeAddress : regions)\n\t\t{\n\t\t\tif(cellRangeAddress.getFirstColumn()>=colInStart-1&&\n\t\t\t\t\tcellRangeAddress.getLastColumn()<=colINEnd-1&&\n\t\t\t\t\tcellRangeAddress.getFirstRow()>=rowInStart-1&&\n\t\t\t\t\tcellRangeAddress.getLastRow()<=rowInEnd-1)\n\t\t\t{\n\t\t\t\tint diffrow=rowOutStart-rowInStart;\n\t\t\t\tint diffcol=colOutStart-colInStart;\n\t\t\tint firstRow=cellRangeAddress.getFirstRow()+diffrow;\n\t\t\tint firstCol=cellRangeAddress.getFirstColumn()+diffcol;\n\t\t\tint lastRow=firstRow+cellRangeAddress.getLastRow()-cellRangeAddress.getFirstRow();\n\t\t\tint lastCol=firstCol+cellRangeAddress.getLastColumn()-cellRangeAddress.getFirstColumn();\n\t\t\tCellRangeAddress cellRangeAddressNew=new CellRangeAddress(firstRow, lastRow, firstCol, lastCol);\n\n\t\t\tsheetOut.addMergedRegion(cellRangeAddressNew);\n\t\t\t}\n\t\t}\n\t\t//set the copied column's width\n\t\tfor(int columnIndex=colInStart-1;columnIndex<=colINEnd-1;columnIndex++) {\n\t\t\tint width=sheetIn.getColumnWidth(columnIndex);\n\t\t\tsheetOut.setColumnWidth(columnIndex, width);\n\t\t}\n\t\t\n\t    return true;\n\t}\n```\n\n## 需要注意的\n\n- 在linux环境下，使用LibreOffice Calc，虽然在给每个电子表格(sheet)命名时，无论代码中还是软件中，名称可以包含空格或特殊字符，但用apahce poi获取sheet名时，只会读到空格或特殊符号之前的部分。我的解决方法是在创建每个sheet时统一用横杠(-)代替空格和特殊字符。\n- 对于合并单元格(merged region)，好的做法是在**同一个函数**中先把该表中**所有**要合并的单元格存到cellRangeAddress列表中，再进行复制之类的操作，避免在多个函数反复添加合并单元格。\n- 自动设置列宽方法autoSizeColumn，对于合并单元格不能很好适用，建议还是自己设置。\n- 在设置格式时，LibreOffice Calc中形如`=$表名.单元格编号`。但在java POI中形式为`cell.setcellformula(表名!单元格编号)`","tags":["Java","Apache POI"]},{"title":"WEB学习-Bootstrap框架学习","url":"/2018/02/20/2018-02-21-WEB-Bootstrap-learning/","content":"\n[TOC]\n\n# Grid system(网格系统)\n\n- 每一行rows应放在.container(fixed-width)或.container-fluid(full-width)中\n- 使用rows来创建水平列组(groupes of columns)\n- 内容放在column中，column是rows的子类\n\n# Chrome开发者工具\nctrl+shift+i\n\n# 应用框架\n要将 bootstrap CSS 应用于 bootstrap-prestructure.html 文件，需要：将 bootstrap-prestructure.html 文件移至你的 bootstrap 目录。打开 HTML 文件，在母体元素下方的 head 元素中添加一条指向 bootstrap CSS 文件的链接：\n`<link rel=\"stylesheet\" href=\"css/bootstrap.min.css\">`\n\n# 保存修改\n要将你在开发者工具中对 HTML 所做的更改保存至你的 HTML 文件，只需右键单击或 ctrl + 单击 <html> 元素，然后选择“复制为 HTML”，然后用复制的文本替换你文件中的 HTML。\n\n# 响应式页面\n响应式图片加上`class=\"img-responsive\" alt=\"Responsive image\"`\n\n# Bootstrap排版\n文字对齐加上`class=\"text-left\"`表示左对齐\n文字装换加上`class=\"text-uppercase\"`将文字变为大写\n*可添加在文字类型如h1，h3，最好是直接添加在包含他们的div上*\n\n# 自定义CSS\n在/css文件夹下添加style.css文件\n从大到小对网页中的元素添加定制","tags":["WEB入门","Bootstrap"]},{"title":"WEB学习-HTML和CSS入门","url":"/2018/02/20/2018-02-20-WEB-learning/","content":"\n* 目录\n{:toc}\n\n# WEB项目文件结构\n![文件结构](/img/post/WEB-structure.png)\n\n# 常用网页框架设计\n- 1个100%页面宽度的行类(.row)\n- 占页面1/12-12/12的列类(.col-n)*n为1-12的数字*\n*CSS类前有.*\n\n# flex\n- 为了让行中列元素并排显示，需要给row加上`display:flex`\n- 关于flex，查看[flex](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex),[flexbox](https://segmentfault.com/a/1190000007550042),[flex-wrap](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-wrap)\n\n# 负空间（space）\n- margin 外边距\n- padding 内边距\n- 加上后缀`-top -right -left -bottom`具体设置\n*border 边框*\n\n# 溢出\n- `overflow:auto;`\n\n# 响应\n例子：\n`@media only screen and (max-width:500px) and (orientation:landscape)`\n- `@media`实现页面响应\n- `only‘`用于兼容旧式浏览器\n- `screen`指示这个响应用于所有显示设备\n*print用于响应当用户要打印页面时*\n- `and`加上条件\n- `orientation`指的是手机方向：landscape mode横向，portrait mode纵向\n\n# 浏览器兼容\n在head中添加normalize.css样式表，该表格google搜索下载\n\n# 占位图片\n- `<img src=\"http://placehold.it/nxn\"`\n- `<img src=\"http://placekitten.com/n/n\"`\n\n# 字体\n1. 在[Google Fonts](https://fonts.google.com/)中找到字体\n2. 在html的head中加入链接`<link href=\"https://fonts.googleapis.com/css?family=Roboto\" rel=\"stylesheet\">`\n3. 在css中为需要使用该字体的元素添加`font-family: 'Roboto', sans-serif;`\n\n\n","tags":["WEB入门"]},{"title":"Git 学习","url":"/2018/02/06/2018-02-06-Git-learning/","content":"\n* 目录\n{:toc}\n\n# 基础\n*以在GitLab上创建一个project为例*\n\n## 1. SSH秘钥\n生成SSH秘钥指令：\n`$ ssh-keygen -t rsa -C \"votre.email@telecom-sudparis.eu\" -b 4096`\n保存在`$HOME/.ssh/id_rsa.pub`\n将获得的SSH秘钥填入GitLab网站\n**SSH秘钥用于GitLab网站识别Unix账号**\n\n## 2. 创建project并添加合作者\n命名规则：课程+年份+创作者\n*给合作者Master权限*\n\n## 3. 克隆project到本地\n`git clone git@gitlab.tem-tsp:votreprenom.votrenom/votrenomdeproject.git`\n\n## 4. 查看git状态\n`git status`\n\n## 5. 创建第一个文件README.md并提交\n1. `git add README.md`\n2. `git commit -m \"注释\"`\n3. `git push origin master`\n4. 其他合作者`git pull origin`\n\n- git add：\ni） `git add .` 或 `git add --all` 提交所有修改\n\n- git commit：\ni） `git commit`后会生产一个hash码，用于标记此次commit操作\n\n- git push：\ni） `git push`默认将master上传\nii）origin是远程仓库名，master是分支名\n\n- git pull：\ni）当有其他人想master分支推送了更新，则服务器上的master向前推进，本地的Master落后服务器版本，需要运行 `git fetch`来同步本地并用`git merge`合并，或直接用`git pull`。`git pull`=`git fetch` + `git merge`\n\n---\n\n# 分支操作\n*branch*\n\n## 1. 创建分支\n`git checkout -b module1`\n\ni） 创建并转到module1分支\nii）`git checkout 分支名` 转到已存在的分支\n\n## 2. 查看分支\n`git branch`\n\ni）一般而言，Master分支是默认创建的。\n**但若是在项目一开始，即项目为空时，创建分支，会丢失master分支。**\n\n## 3. 在分支上进行操作\n- 与在[基础部分](# 例子1-基础)操作相同\n- 在每个分支上做的add,commit操作是独立的\n\n## 4. 查看日志\n- `git log --graph --oneline --decorate`\n- 使用工具gitg/gitk\n\n## 5. 合并（Fusion）分支\n1. 转到Master`git checkout master`\n2. `git merge --no-ff moudle1 -m \"Merge branch 'modele1'\"`\n\ni)  有`--no-ff`则moudle1会保留，没有则不保留module1分支\n\n---\n\n# 冲突conflict\n\n## 设置冲突管理工具\n`git config merge.tool meld`\n\n## 冲突前提\n分支module1和Master中有同一个文件，且分别在不同分支修改了文件，并做了`add commit`操作。做第二次`commit`时冲突发送。\n\n解决方法：\n用`git mergetool`调用meld，查看修改冲突的地方，修改保存后会生成很多不必要的文件\n用`rm 文件名.文件类型.* 文件名_* *~`删除这些文件。\n\n---\n\n# Git-flow\n\n## Git-flow原则\n1. 两条长期分支\n**master**只保留官方的，实用的代码版本\n**develop**在这个分支进行开发，只有想正式对外发布且经过确认，才会和Master合并。\n- 新建develop分支：`git checkout -b develop master`\n- 将develop分支发布到Master分支：`git checkout Master`\n                             ​    `git merge --no-ff develop `\n2. 创建release(预发布)分支\n当要进行develop分支和Master合并时，先从develop分支上创建一个release分支，加上标签（tag)用于标记新的版本。\n*建议创建一个release分支，这个分支里commit只用于修改bugs。*\n\n3. 在develop的子分支（feature分支）上编码\n只有子分支状态满足，develop上的合并操作才会执行\n\n4. hotfix\n当master上发现bug，就在master上引出一个hotfix分支。\n这个分支有两个作用：\n1. 为Master提供一个新版本\n2. 为develop修复整个project的bug\n\n*注意：*release,feature和hotfix分支都是临时分支，使用完后，应该删除，使代码库的常设分支始终只有Master和Deve。\n\n![Git-flow图](/img/git/git-model.png)\n\n\n## Git-flow例子\n1. 在本地建立工作文件夹，初始化库\n\n```\nmkdir exercice-git-flow  \ncd exercice-git-flow  \ngit init  \ntouch README.md  \ngit add README.md  \ngit commit -m \"commit initial\"\n```\n\n2. 新建develop分支\n`git checkout -b develop`\n\n3. 新建feature分支，以功能名命名\n`git checkout -b navire1`\n\n4. 在这个分支中写一个文本文档\n\n```\ngedit navire.txt  \ngit add navire.txt  \ngit commit -m \"navire version 1`\n```\n\n5. 修改和二次提交\n为navire.txt中加入新的几行\n\n```\ngedit navire.txt  \ngit add navire.txt  \ngit commit -m \"navire version 2\"\n```\n\n现在我们已经实现了一定功能，合并这个分支和develop\n\n```\ngit checkout develop  \ngit merge --no-ff navire1 -m \"Merge branch 'navire1' into develop\"\n```\n\n6. 假设经过多次3-5，我们已经实现了很多功能，想把develop和master合并\n\n```\ngit checkout master  \ngit merge --no-ff develop -m \"commit release 1.0\"\n```\n\n因为这是一个正式版本，我们加上标签tag\n`git tag -a v1.0 -m \"release 1.0\"`\n\n# 版本控制\n=有待完成=\n","tags":["Git"]},{"title":"Vim学习（一）","url":"/2018/02/05/2018-02-05-Vim-learning-1/","content":"\n* 目录\n{:toc}\n\n# vim学习\n\n## Part 1\n```markdown\n- i → Insert 模式，按 ESC 回到 ormal 模式.\n- x → 删当前光标所在的一个字符。\n- :wq → 存盘 + 退出 (:w 存盘, :q 退出)   （注：:w 后可以跟文件名）\n- dd → 删除当前行，并把删除的行存到剪贴板里\n- p → 粘贴剪贴板\n```\n\n---\n\n## Part 2\n1. 插入模式\n\t- a → 在光标后插入\n\t- o → 在当前行后插入一个新行\n\t- O → 在当前行前插入一个新行\n\t- cw → 替换从光标所在位置后到一个单词结尾的字符\n2. 简单的移动光标\n\t- 0 → 数字零，到行头\n\t- ^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）\n\t- $ → 到本行行尾\n\t- g_ → 到本行最后一个不是blank字符的位置。\n\t- /pattern → 搜索 pattern 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个）\n3. 拷贝/粘贴 \n\t- P → 粘贴;p是表示在当前位置之后，P表示在当前位置之前\n\t- yy → 拷贝当前行当行于 ddP;y -> 拷贝\n4. Undo/Redo\n\t- u → undo\n\t- C-r → redo\n5. 打开/保存/退出/改变文件(Buffer)\n\t- :e <path/to/file> → 打开一个文件\n    - :w → 存盘\n    - :saveas <path/to/file> → 另存为 <path/to/file>\n    - :x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车)\n    - :q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。\n    - :bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。\n\n---\n\n## Part 3\n1. vim的重复\n\t- . 小数点，重复上一条命令\n\t- N加命令，重复N次\n2. 光标移动\n    - 数字加G，到第N行\n    - gg，到第一行\n    - G，到最后一行\n    - w，到下个词开k移动到与当前光标相匹配的词（×是下一个，#是上一个） \n3. 组合命令（开始位置+命令+结束位置）\n    - 0y$; 拷贝本行，+p粘贴\n    - 能与光标移动联动的还有\n\t\t- d，删除\n\t\t- v，可视化选择\n\t\t- gU，变大写\n\t\t- gu，变小写\n\t\t- 其他\n\n---\n\n## Part 4\n1. 当前行上移动光标\n\t- 0，到行头\n    - ^，到本行的第一个非blank字符\n    - $，到行尾\n    - f字符，到下一个字符处\n    - t字符，到符号前的第一个字符\n    - 3fa，到本行第三次出现的a处\n    - F和T，与f和t相似，方向相反 \n    - dt符号，删除符号前的所有内容\n2. 可视化选择v,V\n    - J，把所有行连在一起\n    - <和>,左右缩进\n    - =，自动缩进\n    - 选中行后，$到最后，a插入字符，Esc为每行添加字符\n3. 分屏\n    - ：split，创建分屏 \n    - ctrl-w，切屏\n","tags":["vim"]},{"title":"Markdown 学习","url":"/2018/01/27/2018-01-27-Markdown-learning/","content":"* 目录\n{:toc}\n\n# Markdown 学习\n[一个好的Markdown学习网站](http://xianbai.me/learn-md/index.html)\n\n## 注释comment\n\\<!-- 注释 -->\n\n---\n\n## 标题Header\n\\# 加空格实现\n\n---\n\n## 句段Sentence/Paragraph\n1. 换行 \n- 行末加两个空格 \n- \\<br>\n\n---\n\n## 符号Punctuation Charcaters\n- \\*倾斜* \n- \\-或+ 列表\n- \\>引用\n1. 字符实体\n    tab 预格式化 \n\n---\n\n## 分隔符Horizontal Rules\n\\--- 三个减号或星号或下划线需隔开上一行 \n\n---\n\n## 文本格式Text Styling\n- 星号（\\*）或下划线（\\_）包围的文字将会显示斜体 ex: *倾斜*\n- 两个星号（\\**）或下划线（\\__）包围的需要特别强调的文字将会加粗 ex: **加粗**\n- 两个等号（equalsigns：\\=）包围来突出高亮显示。ex: ==高亮==\n- 使用两个加号（plus sign：\\+）来标记下划线。\nex：++下划线++\n- 两个波浪符号（two wavy line:\\~~）包围来给文本添加删除线。ex: ~~删除线~~\n\n---\n\n## 脚标 Script\n标准 Markdown 不支持脚标，只能通过内嵌 HTML 的\\<sup\\>和\\<sub\\>标签来实现。\n* 脚标两边加上\\< > ex: 2^10^ \n* 脚标两边加上\\~ ~ ex: H~2~o\n\n---\n\n## 链接Hyperlink\n1. 文字\n- Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要用尖括号包起来的文字， Markdown 就会自动把它转化成链接。如果你还想要加上链接的 title ，只要在网址后面用双引号把 title 文字包起来即可。\n- \\[text\\]\\(url\"解释“\\) ex: [链接](href: \"this is a null ref\")\n- 先定义参考refid：\\[text]\\[refid]\n再定义refid所指：\\[refid]:URL\n2. 图片\n1. 插入图片\n- 需要在链接文字方括号之前添加一个感叹号（exclamation mark：!），其语法格式  \\!\\[alt_text](url) 其中alt_text可以置空    \n- Markdown中的段落（包括图片）默认顶格左对齐，若要将图片居中，可以直接内嵌 HTML 的 <img> 标签，设置align=\"middle\"。如果还不行，可以尝试封裹一层 div 设置 style=\"text-align:center\" 实现\n2. 图片链接\n- 我们在 Markdown 图片标记![]()外面再嵌套一层[]()即可建立图片超链接，点击图片即可跳转到链接地址。\n图片链接的格式看起来大概是这样的:\n\\[\\!\\[](img_url)](ref_url)\n\n---\n\n## 锚点inner link\n1. 书签Bookmark\n    先定义锚点id：<a href=\"#auchor_id\">bookmark_text</a>\n    再定义一个id为auchor_id的对象（这里以<p>为例）：<p id=\"auchor_id\">auchor_text</p>\n2. 脚注Footnote\n    先在需要脚注的单词（terminology）后面添 加 [^Footnote] ： terminology[^Footnote]\n    再在文末 glossary 区域定义脚注（添加注解）： [^Footnote]：explanatory notes\n\n---\n\n## 引用Blockquote\nMarkdown 标记区块引用是使用类似 email 的引用方式，在断好的行前加上 > （more than or greater than sign）：\n\n---\n\n## 代码Code\n1. 行内代码Inline Code\nUse the `printf()` function.(此处使用了反斜杠转义)\n2. 代码块Code Blocks\n- 可使用预格式化引用语法格式。Preformatted Code Block\n在句段的行首插入1个 tab 或4个空格，则表示代码块。\n- [Fenced Code Block]\n在句段行首和行末用三个反引号换行闭包，并在行首三个反引号后添加 YAML 语言标识。\n\n---\n\n## 列表List\n1. 无序列表Unordered List\n无序列表（unordered, bulleted）项目的行首使用星号（或加号，或减号）加空格作为列表标记list markers\n2. 有序列表Ordered List\n有序列表（ordered / numbered）项目的行首则使用数字接一个英文句点标记（use numbers followed by periods）\n3. 扩展支持把列表变成带勾选框的任务列表，只需要在列表标记后添加[ ]标记☐表示unchecked，在中括号中填写x（[x]）标记☑︎表示checked（filled）。\n\n---\n\n## 表格Table\nYou can create tables by assembling a list of words and dividing them with hyphens - (for the first row), and then separating each column with a pipe | (vertical bar):\n\n  t1 |  t2 \n --- | ---\n t11 | t12 \n t21 | t22 \n\n","tags":["Markdown"]}]